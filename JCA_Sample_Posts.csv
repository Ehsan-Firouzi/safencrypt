Id	AcceptedAnswerId	AnswerCount	Body	ClosedDate	CommentCount	CommunityOwnedDate	CreationDate	FavoriteCount	LastActivityDate	LastEditDate	LastEditorDisplayName	LastEditorUserId	OwnerUserId	ParentId	PostTypeId	Score	Tags	Title	ViewCount	AES	TEInit	TEEncDec	TETrans	REFr	REPerf	RERel	REPor	REInerop	RESecur	RESpace
61	0	NULL	"<p>Where can I find a list of all of the MIME types and the identifying characters for <strong>Microsoft Office 2007</strong> files?</p>

<p>I have an upload form that is restricting uploads based on the extensions and identifying characters, but I cannot seem to find the <strong>Office 2007 MIME</strong> types.</p>

<p>Can anyone help?</p>
"	NULL	NULL	NULL	17:20.6	NULL	NULL	NULL	NULL	NULL	0	0	1	52	<mime><file-type><office-2007>	"Microsoft Office 2007 file type, Mime types and identifying characters"	4186	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
340820	342610	1	"<p>I am using a AES cipher with a 16 byte block size. </p>

<p>If I try and encrypt a 16 byte string I have no problems, but any other length not a multiple of 16 is throwing an exception. </p>

<p>I know with 3-DES you can specify a padding type as part of the algorithm and it's handled with no extra work (e.g. DES/CBC/PKCS5Padding), but is there a way to specify this with AES? </p>

<p>Or do I need to pad the pytes manually to a multiple of 16, and then strip them when I decrypt? Here is an abbreviated code sample. </p>

<pre><code>encrypt = Cipher.getInstance(""AES"", provider);
encrypt.init(Cipher.ENCRYPT_MODE, key) ;
byte[] encrypted = encrypt.doFinal(plainTxt.getBytes()) ;
</code></pre>

<p>Any and all replies appreciated! </p>

<p>Thanks in advance,
Ciarán</p>
"	NULL	1	NULL	49:24.9	2	13:05.7	NULL	NULL	0	446733	0	1	6	<java><encryption><aes><padding>	Java Cipher - AES Padding Problem	24030	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
868776	0	4	"<p>I am trying to decrypt a file in Java which was encrypted in C# using Rijndael/CBC/PKCS7. I keep getting the following exception:</p>

<blockquote>
  <p>javax.crypto.BadPaddingException: pad block corrupted<br>
      at org.bouncycastle.jce.provider.JCEBlockCipher.engineDoFinal(Unknown Source)<br>
      at javax.crypto.Cipher.doFinal(DashoA13*..)<br>
      at AESFileDecrypter.decrypt(AESFileDecrypter.java:57)  </p>
</blockquote>

<p>when the <code>doFinal(inpbytes)</code> method is called by the web server for the first byte[]. I am guessing this is a problem with the key or IV. I have the encrypted files on my file system for testing. Is there anything that anyone can see glaringly wrong with my code below?</p>

<p>***keyStr is base64 encoded</p>

<pre><code>public AESFileDecrypter(String keyStr){
    try {
            Security.addProvider(new BouncyCastleProvider());   
            convertIvParameter();
            key = new sun.misc.BASE64Decoder().decodeBuffer(keyStr);

            //use the passed in Base64 decoded key to create a key object
            decryptKey = new SecretKeySpec(key, ""AES"");

            //specify the encryption algorithm
            decryptCipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");

            //make a parameter object for the initialization vector(IV)             
            IvParameterSpec ivs = new IvParameterSpec(_defaultIv);

            //initialize the decrypter to the correct mode, key used and IV
            decryptCipher.init(Cipher.DECRYPT_MODE, decryptKey, ivs);    
        } 
     catch (Exception e) {
             e.printStackTrace();
     } 
}

public void convertIvParameter() {

   int[] iv = new int[] {11, 190, 165, 33, 68, 88, 11, 200, 245, 35, 68, 23, 60, 24, 223, 67};

   _defaultIv = new byte[16];

   for(int x = 0; x &lt; _defaultIv.length; x++) {
      _defaultIv[x] = (byte)iv[x];
   }
}

public void decryptUpdate(byte[] inpBytes) throws Exception {
   //decrypt the byte passed in from the web server
   decryptCipher.update(inpBytes);  
}

public byte[] decryptFinal() throws Exception {
   //decrypt the byte passed in from the web server
   return decryptCipher.doFinal();
}

//sends bytes to the client for diaply
private void sendBytes(FileInputStream fis, OutputStream os)throws Exception {
    //set the buffer size to send 4k segments of data
aesFileDecrypter = new AESFileDecrypter(&lt;Insert Key string here&gt;);

    byte[] buffer = new byte[4096];
    int bytes = 0, totalBytes = fis.available();

    //while there is still data to be sent keep looping and write the data
    //to the output stream as the buffer is filled
    try {
       while ((bytes = fis.read(buffer)) != -1) {   
          aesFileDecrypter.decryptUpdate(buffer);
          //os.write(buffer, 0, bytes);
       }

       os.write(aesFileDecrypter.decryptFinal(), 0, totalBytes);
   }
   catch(Exception e) {
      e.printStackTrace();
   }
}
</code></pre>
"	NULL	0	NULL	48:05.9	4	28:16.0	28:16.0	Ken	597607	0	0	1	7	<java><exception><encryption>	BadPaddingException: pad block corrupted	26769	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
908672	908714	6	"<p>Consider:</p>

<pre><code>import java.awt.*;

import javax.swing.*;
import java.awt.event.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.security.*;
import java.io.*;


public class EncryptURL extends JApplet implements ActionListener {

    Container content;
    JTextField userName = new JTextField();
    JTextField firstName = new JTextField();
    JTextField lastName = new JTextField();
    JTextField email = new JTextField();
    JTextField phone = new JTextField();
    JTextField heartbeatID = new JTextField();
    JTextField regionCode = new JTextField();
    JTextField retRegionCode = new JTextField();
    JTextField encryptedTextField = new JTextField();

    JPanel finishPanel = new JPanel();


    public void init() {

        //setTitle(""Book - E Project"");
        setSize(800, 600);
        content = getContentPane();
        content.setBackground(Color.yellow);
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));

        JButton submit = new JButton(""Submit"");

        content.add(new JLabel(""User Name""));
        content.add(userName);

        content.add(new JLabel(""First Name""));
        content.add(firstName);

        content.add(new JLabel(""Last Name""));
        content.add(lastName);

        content.add(new JLabel(""Email""));
        content.add(email);

        content.add(new JLabel(""Phone""));
        content.add(phone);

        content.add(new JLabel(""HeartBeatID""));
        content.add(heartbeatID);

        content.add(new JLabel(""Region Code""));
        content.add(regionCode);

        content.add(new JLabel(""RetRegionCode""));
        content.add(retRegionCode);

        content.add(submit);

        submit.addActionListener(this);
    }


    public void actionPerformed(ActionEvent e) {

        if (e.getActionCommand() == ""Submit""){

            String subUserName = userName.getText();
            String subFName = firstName.getText();
            String subLName = lastName.getText();
            String subEmail = email.getText();
            String subPhone = phone.getText();
            String subHeartbeatID = heartbeatID.getText();
            String subRegionCode = regionCode.getText();
            String subRetRegionCode = retRegionCode.getText();

            String concatURL =
                ""user="" + subUserName + ""&amp;f="" + subFName +
                ""&amp;l="" + subLName + ""&amp;em="" + subEmail +
                ""&amp;p="" + subPhone + ""&amp;h="" + subHeartbeatID +
                ""&amp;re="" + subRegionCode + ""&amp;ret="" + subRetRegionCode;

            concatURL = padString(concatURL, ' ', 16);
            byte[] encrypted = encrypt(concatURL);
            String encryptedString = bytesToHex(encrypted);
            content.removeAll();
            content.add(new JLabel(""Concatenated User Input --&gt;"" + concatURL));

            content.add(encryptedTextField);
            setContentPane(content);
        }
    }

    public static byte[] encrypt(String toEncrypt) throws Exception{
        try{
            String plaintext = toEncrypt;
            String key = ""01234567890abcde"";
            String iv = ""fedcba9876543210"";

            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            byte[] encrypted = cipher.doFinal(toEncrypt.getBytes());

            return encrypted;
        }
        catch(Exception e){
        }
    }


    public static byte[] decrypt(byte[] toDecrypt) throws Exception{
        String key = ""01234567890abcde"";
        String iv = ""fedcba9876543210"";

        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

        Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        byte[] decrypted = cipher.doFinal(toDecrypt);

        return decrypted;
    }


    public static String bytesToHex(byte[] data) {
        if (data == null)
        {
            return null;
        }
        else
        {
            int len = data.length;
            String str = """";
            for (int i=0; i&lt;len; i++)
            {
                if ((data[i]&amp;0xFF) &lt; 16)
                    str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);
                else
                    str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
            }
            return str;
        }
    }


    public static String padString(String source, char paddingChar, int size)
    {
        int padLength = size-source.length() % size;
        for (int i = 0; i &lt; padLength; i++) {
            source += paddingChar;
        }
        return source;
    }
}
</code></pre>

<p>I'm getting an unreported exception:</p>

<pre><code>java.lang.Exception; must be caught or declared to be thrown
byte[] encrypted = encrypt(concatURL);
</code></pre>

<p>As well as:</p>

<pre><code>.java:109: missing return statement
</code></pre>

<p>How do I solve these problems?</p>
"	NULL	1	NULL	22:57.0	12	55:20.9	55:20.9	NULL	63550	51898	0	1	48	<java><exception>	"Why do I get ""Exception; must be caught or declared to be thrown"" when I try to compile my Java code?"	206426	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
992019	992413	9	"<p>I need to implement 256 bit AES encryption, but all the examples I have found online use a ""KeyGenerator"" to generate a 256 bit key, but I would like to use my own passkey. How can I create my own key? I have tried padding it out to 256 bits, but then I get an error saying that the key is too long. I do have the unlimited jurisdiction patch installed, so thats not the problem :)</p>

<p>Ie. The KeyGenerator looks like this ...</p>

<pre><code>// Get the KeyGenerator
KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
kgen.init(128); // 192 and 256 bits may not be available

// Generate the secret key specs.
SecretKey skey = kgen.generateKey();
byte[] raw = skey.getEncoded();
</code></pre>

<p><a href=""http://java.sun.com/developer/technicalArticles/Security/AES/AES_v1.html"" rel=""noreferrer"">Code taken from here</a></p>

<p><strong>EDIT</strong></p>

<p>I was actually padding the password out to 256 bytes, not bits, which is too long. The following is some code I am using now that I have some more experience with this.</p>

<pre><code>byte[] key = null; // TODO
byte[] input = null; // TODO
byte[] output = null;
SecretKeySpec keySpec = null;
keySpec = new SecretKeySpec(key, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
cipher.init(Cipher.ENCRYPT_MODE, keySpec);
output = cipher.doFinal(input)
</code></pre>

<p>The ""TODO"" bits you need to do yourself :-)</p>
"	NULL	6	NULL	39:02.2	307	52:12.9	51:19.2	NULL	3474	91414	0	1	417	<java><encryption><cryptography><passwords><aes>	Java 256-bit AES Password-Based Encryption	610361	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
1226083	1226156	2	"<p>I'm implementing encryption / decryption using Java Cipher and AES.  Everything is working well except that there's 5 extra bytes written on the call to doFinal().  So, I end up with a correctly decoded string with 5 extra bytes appended.</p>

<p>I believe the reason is that the entire block of 16-bytes is being written.  I see 3 16-byte blocks written, including the last one.  The input encrypted file is 64-bytes.  The unencrypted text should be 43 bytes.</p>

<p>The documentation for doFinal indicates that it can return the number of bytes written to the output buffer.  However, it's 0,16,16,16.  I've tried every form of doFinal and update and get no change in behavior.</p>

<p>It kind of makes sense that it's writing out a full-block, since that's how most of these algorithms operate.  However, if it's not going to tell me the size of the output data, how am I supposed to prevent excess data?</p>

<p>Should perhaps I be using another algorithm?  AES256 is a requirement, but I wonder if a different block type or padding type might allow it to write the correct number of bytes.</p>

<p>Any guidance?</p>

<p>Snipped for (some) brevity:</p>

<pre><code>decryptCipher = Cipher.getInstance(""AES"");
decryptCipher.init(Cipher.DECRYPT_MODE, aesKey);
</code></pre>

<p>Business part of the decryption routine.</p>

<pre><code>    long bytesToRead = inputFile.length();

    while ((inLen = in.read(buffer)) &gt; 0) {
        int bytesOut = 0;
        byte[] cryptBytes = null;
        int outLen = cipher.getOutputSize(inLen);
        cryptBytes = new byte[outLen];

        if (bytesToRead &lt;= buffer.length) {
            try {
                bytesOut = cipher.doFinal(buffer, 0, inLen, cryptBytes, 0);
            } catch (ShortBufferException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } else
            try {
                bytesOut = cipher.update(buffer, 0, inLen, cryptBytes, 0);
            } catch (ShortBufferException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

        out.write(cryptBytes, 0, bytesOut);
        bytesToRead -= inLen;

    }
    try {
        out.flush();
        in.close();
        out.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
</code></pre>
"	NULL	0	NULL	24:04.2	5	48:11.3	29:07.8	NULL	21234	136451	0	1	11	<java><encryption><aes>	Java cipher.doFinal() writing extra bytes	21937	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
1440030	1440197	2	"<p>I've read the following threads and they've helped a little, but I'm looking for a little more info.</p>

<p><a href=""https://stackoverflow.com/questions/915786/how-to-write-aes-cbc-pkcs5padding-encryption-and-decryption-with-initialization-v"">How to write AES/CBC/PKCS5Padding encryption and decryption with Initialization Vector Parameter for BlackBerry </a></p>

<p><a href=""https://stackoverflow.com/questions/992019/java-256bit-aes-encryption"">Java 256bit AES Encryption</a></p>

<p>Basically, what I am doing is writing a program that will encrypt a request to be sent over TCP/IP, and then decrypted by a server program. The encryption will need to be AES, and doing some research I found out I need to use CBC and PKCS5Padding. So basically I need a secret key and an IV as well. </p>

<p>The application I'm developing is for a phone, so I want to use the java security packages to keep the size down. I've got the design done, but unsure of the implementation of the IV and the shared key.</p>

<p>Here's some code:</p>

<pre><code>// My user name
byte[] loginId = ""login"".getBytes();

byte[] preSharedKey128 = ""ACME-1234AC"".getBytes();
byte[] preSharedKey192 = ""ACME-1234ACME-1234A"".getBytes();
// 256 bit key
byte[] preSharedKey256 = ""ACME-1234ACME-1234ACME-1234"".getBytes();
byte[] preSharedKey = preSharedKey256;

// Initialization Vector
// Required for CBC
byte[] iv ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
IvParameterSpec ips = new IvParameterSpec(iv);


byte[] encodedKey = new byte[loginId.length + preSharedKey.length];

System.arraycopy(loginId, 0, encodedKey, 0, loginId.length);
System.arraycopy(preSharedKey, 0, encodedKey, loginId.length, preSharedKey.length);

// The SecretKeySpec provides a mechanism for application-specific generation
// of cryptography keys for consumption by the Java Crypto classes.

// Create a key specification first, based on our key input.
SecretKey aesKey = new SecretKeySpec(encodedKey, ""AES"");

// Create a Cipher for encrypting the data using the key we created.
Cipher encryptCipher;

encryptCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
// Initialize the Cipher with key and parameters
encryptCipher.init(Cipher.ENCRYPT_MODE, aesKey, ips);

// Our cleartext
String clearString = ""33,8244000,9999,411,5012022517,0.00,0,1,V330"";
byte[] cleartext = clearString.getBytes();

// Encrypt the cleartext
byte[] ciphertext = encryptCipher.doFinal(cleartext);

// Now decrypt back again...
// Decryption cipher
Cipher decryptCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
// Initialize PBE Cipher with key and parameters
decryptCipher.init(Cipher.DECRYPT_MODE, aesKey, ips);

// Decrypt the cleartext
byte[] deciphertext = decryptCipher.doFinal(ciphertext);
</code></pre>

<p>In a nutshell what it should do is encrypt some message that can decrypted by the server without the server needing to get a key or IV from the phone. Is there a way I could do this  where I could secure the IV and key on the phone, and still have the key and IV known by the server as well? Feel free to tell me to make things more clear if they're not.</p>
"	NULL	7	NULL	49:26.4	10	31:20.7	44:22.7	NULL	-1	127929	0	1	16	<java><encryption><aes>	How to implement Java 256-bit AES encryption with CBC	50753	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
1760785	1760868	4	"<p>this code give invalid AES key length error. how can i correct it ? ( i want 128 bit key AES encryption )</p>

<pre><code>package org.temp2.cod1;
import java.security.*;

import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;

public class Code1 {

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {
    String s = ""9882623867"";
    byte[] plaintext = s.getBytes(""UTF-16"");
    String s2 = ""supernova"";
    byte[] key = s2.getBytes(""UTF-16"");
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec k =  new SecretKeySpec(key, ""AES"");
    c.init(Cipher.ENCRYPT_MODE, k);
    byte[] encryptedData = c.doFinal(plaintext);
    System.out.println(encryptedData);
}
}
</code></pre>

<p>any help appreciated </p>
"	NULL	0	NULL	52:52.3	10	51:40.4	NULL	NULL	0	193133	0	1	27	<java><encryption><aes>	invalid AES key length error	85221	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
2568841	0	5	"<p>I am trying to create an AES encryption method, but for some reason I keep getting</p>

<blockquote>
  <p><code>java.security.InvalidKeyException: Key length not 128/192/256 bits</code></p>
</blockquote>

<p>Here is the code:</p>

<pre><code>public static SecretKey getSecretKey(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException{
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
    // NOTE: last argument is the key length, and it is 256
    KeySpec spec = new PBEKeySpec(password, salt, 1024, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
    return(secret);
}


public static byte[] encrypt(char[] password, byte[] salt, String text) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException{
    SecretKey secret = getSecretKey(password, salt);

    Cipher cipher = Cipher.getInstance(""AES"");

    // NOTE: This is where the Exception is being thrown
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    byte[] ciphertext = cipher.doFinal(text.getBytes(""UTF-8""));
    return(ciphertext);
}
</code></pre>

<p>Can anyone see what I am doing wrong? I am thinking it may have something to do with the SecretKeyFactory algorithm, but that is the only one I can find that is supported on the end system I am developing against.  Any help would be appreciated.  Thanks.</p>
"	NULL	5	NULL	50:26.9	5	21:31.5	44:36.0	NULL	474189	291059	0	1	8	<java><encryption><aes>	AES Encryption Java Invalid Key length	46117	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
2758869	2759942	3	"<p>I am trying to make a program that Encrypts data using AES, then encrypts the AES key with RSA, and then decrypt. However, once i encrypt the AES key it comes out to 128 bytes. RSA will only allow me to decrypt 117 bytes or less, so when i go to decrypt the AES key it throws an error.</p>

<p>Relavent code:</p>

<pre><code>    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    KeyPair kpa = kpg.genKeyPair();
    pubKey = kpa.getPublic();
    privKey = kpa.getPrivate();

    updateText(""Private Key: "" +privKey +""\n\nPublic Key: "" +pubKey);

    updateText(""Encrypting "" +infile);
    //Genereate aes key
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    kgen.init(128); // 192/256
    SecretKey aeskey = kgen.generateKey();
    byte[] raw = aeskey.getEncoded();

    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

    updateText(""Encrypting data with AES"");
    //encrypt data with AES key
    Cipher aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    SealedObject aesEncryptedData = new SealedObject(infile, aesCipher);

    updateText(""Encrypting AES key with RSA"");
    //encrypt AES key with RSA
    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);
    byte[] encryptedAesKey = cipher.doFinal(raw);

    updateText(""Decrypting AES key with RSA. Encrypted AES key length: "" +encryptedAesKey.length);
    //decrypt AES key with RSA       
    Cipher decipher = Cipher.getInstance(""RSA"");
    decipher.init(Cipher.DECRYPT_MODE, privKey);
    byte[] decryptedRaw = decipher.doFinal(encryptedAesKey); //error thrown here because encryptedAesKey is 128 bytes
    SecretKeySpec decryptedSecKey = new SecretKeySpec(decryptedRaw, ""AES"");

    updateText(""Decrypting data with AES"");
    //decrypt data with AES key
    Cipher decipherAES = Cipher.getInstance(""AES"");
    decipherAES.init(Cipher.DECRYPT_MODE, decryptedSecKey);
    String decryptedText = (String) aesEncryptedData.getObject(decipherAES);

    updateText(""Decrypted Text: "" +decryptedText);
</code></pre>

<p>Any idea on how to get around this?</p>
"	NULL	1	NULL	48:48.4	3	43:27.3	23:07.8	NULL	183528	104998	0	1	3	<java><security><encryption><cryptography><rsa>	Encrypted AES key too large to Decrypt with RSA (Java)	5368	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3180878	0	3	"<p>I got an exception in the following code for AES algorithm in java.</p>

<p>Code decryptes an encrypted string and returns the original string. </p>

<p>Plz help me to fix this.</p>

<p>Code:</p>

<pre><code>public class AES 

{

public byte[] encrypted;

 public byte[] original;

 public String originalString;

public static String asHex (byte buf[]) 

{ 

StringBuffer strbuf = new StringBuffer(buf.length * 2);

 int i; for (i = 0; i &lt; buf.length; i++) 

{

 if (((int) buf[i] &amp; 0xff) &lt; 0x10) strbuf.append(""0""); 

strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16)); 

}

 return strbuf.toString();

 }

 public String AESencryptalgo(byte[] text)

 { 

String newtext=""""; 

// Get the KeyGenerator

 try

 {

    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");

    kgen.init(128); // 192 and 256 bits may not be available

 // Generate the secret key specs. 

SecretKey skey = kgen.generateKey();

 byte[] raw = skey.getEncoded();

 SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

 // Instantiate the cipher Cipher cipher = Cipher.getInstance(""AES""); 

cipher.init(Cipher.ENCRYPT_MODE, skeySpec); encrypted = cipher.doFinal(text); 

System.out.println(""encrypted string: "" + asHex(encrypted)); 

cipher.init(Cipher.DECRYPT_MODE, skeySpec); original = cipher.doFinal(encrypted); 

originalString = new String(original); System.out.println(""Original string: "" + originalString + "" "" + asHex(original));

 } 

catch(Exception e)

 { } 

finally 

{

 newtext=new String(encrypted);

 System.out.println(""ENCRYPTED ""+newtext);

//AESdecryptalgo(newtext.getBytes()); 

return newtext;

 }

 } 

public String AESdecryptalgo(byte[] text)

 { 

// Get the KeyGenerator

 try

 {

 KeyGenerator kgen = KeyGenerator.getInstance(""AES"");

 kgen.init(128); // 192 and 256 bits may not be available 

// Generate the secret key specs. 

SecretKey skey = kgen.generateKey();

 byte[] raw = skey.getEncoded(); 

SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES""); 

// Instantiate the cipher

 Cipher cipher = Cipher.getInstance(""AES""); 

cipher.init(Cipher.DECRYPT_MODE, skeySpec);

 original = cipher.doFinal(text); //Exception occurs here

 originalString = new String(original);

 System.out.println(""Original string: "" + originalString + "" "" + asHex(original)); 

}

 catch(Exception e)

 {

 System.out.println(""exception""); 

}

 finally

{ 

System.out.println(""DECRYPTED ""+originalString);

 return originalString;

 } 

} 

public static void main(String[] args)

{

AES a=new AES();

a.AESencryptalgo(""hello"".getBytes());

System.out.println(); 

}} 
`
</code></pre>

<p>exception:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded at  
com.sun.crypto.provider.SunJCE_f.b(DashoA13*..) at
com.sun.crypto.provider.SunJCE_f.b(DashoA13*..) at
com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..) at
javax.crypto.Cipher.doFinal(DashoA13*..) 
</code></pre>
"	NULL	5	NULL	11:03.6	11	02:56.2	28:09.9	NULL	238704	372066	0	1	5	<java><encryption>	Exception in AES decryption algorithm in java	15249	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3188171	3188211	8	"<p>I am new to encryption.</p>

<p>I have looked at the javax.crypto documentation and got encryption of a file to work using this code ...</p>

<pre><code>File saveFile = new File(""Settings.set"");
        saveFile.delete();
        FileOutputStream fout = new FileOutputStream(saveFile);

        //Encrypt the settings
        //Generate a key
        byte key[] = ""My Encryption Key98"".getBytes();
        DESKeySpec desKeySpec = new DESKeySpec(key);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");
        SecretKey skey = keyFactory.generateSecret(desKeySpec);

        //Prepare the encrypter
        Cipher ecipher = Cipher.getInstance(""DES"");
        ecipher.init(Cipher.ENCRYPT_MODE, skey);
        // Seal (encrypt) the object
        SealedObject so = new SealedObject(this, ecipher);

        ObjectOutputStream o = new ObjectOutputStream(fout);
        o.writeObject(so);
        o.close();
</code></pre>

<p>However if you were a clever hacker ( or maybe even amateur since I figured this out), all you would have to do is open the class file that contains this code, and the encryption key (My Encryption Key98) is plainly visible.</p>

<p>How do you encrypt the encryption key? ...LOL...  Can you?</p>

<p>Thanks for your help!</p>
"	NULL	1	NULL	25:47.4	4	22:32.6	NULL	NULL	0	384746	0	1	10	<java><encryption>	Java encryption alternitive to hardcoded key	14390	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3443457	3444713	1	"<p>I'm trying do some encrypt something using 3des on the iphone that must match the results from java and .NET.</p>

<p>the code i have is:</p>

<pre><code>+ (NSString*) doCipher:(NSString*)plainText:(CCOperation)encryptOrDecrypt {

const void *vplainText;
size_t plainTextBufferSize;

if (encryptOrDecrypt == kCCDecrypt)
{
    NSData *EncryptData = [NSData dataWithBase64EncodedString:plainText];
    plainTextBufferSize = [EncryptData length];
    vplainText = [EncryptData bytes];
}
else
{
    NSData *tempData = [plainText dataUsingEncoding:NSASCIIStringEncoding];
    plainTextBufferSize = [tempData length];
    vplainText =  [tempData bytes];
}

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
//  uint8_t ivkCCBlockSize3DES;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

NSString *key = [NSString MD5:@""HSDNIFFU""];

NSData *_keyData = [key dataUsingEncoding:NSASCIIStringEncoding];

NSLog(@""key byte is %s"", [_keyData bytes]);

// Initialization vector; dummy in this case 0's.
uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x0, (size_t) sizeof(iv));

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   (const void *)[_keyData bytes], //""123456789012345678901234"", //key
                   kCCKeySize3DES,
                   iv,  //iv,
                   vplainText,  //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

//if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
/*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{

//  result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
    result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSLog(@""data is: %@"", myData);
    result = [myData base64Encoding];
}
return result;
</code></pre>

<p>} </p>

<p>This code successfully encrypts and decrypts a string. As you can see, it uses md5 on the key. However, it does not match the results from .NET and java.</p>

<p>The java code from the java developer looks like:</p>

<pre><code>public static byte[] encryptTripleDES(String message) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(""--KEY--"".getBytes(""utf-8""));
    final SecretKey key = new SecretKeySpec(digestOfPassword, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    return cipher.doFinal(message.getBytes(""utf-8""));
}
</code></pre>

<p>Unfortunately I'm not too familiar with java encryption. I did notice that after using md5 on the KEY it creates a SecretKey with the method SecretKeySpec. My Java developer told me that he needed to create a secretkey using the byte array of the key so that it could match the .NET key. </p>

<p>Can anyone explain this better to me and help me with a solution to match the results of the .NET and java counterparts?</p>
"	NULL	0	NULL	26:30.7	3	35:23.0	NULL	NULL	0	135894	0	1	2	<java><.net><iphone><encryption><3des>	"iPhone 3Des Encrypting matching Java and .NET key issue, SecretKeySpec?"	1784	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3451670	3452620	6	"<p>I want to encrypt a string using AES with my own key. But I'm having trouble with the bit length of the key. Can you review my code and see what I need to fix/change.</p>

<pre><code>public static void main(String[] args) throws Exception {
    String username = ""bob@google.org"";
    String password = ""Password1"";
    String secretID = ""BlahBlahBlah"";
    String SALT2 = ""deliciously salty"";

    // Get the Key
    byte[] key = (SALT2 + username + password).getBytes();
    System.out.println((SALT2 + username + password).getBytes().length);

    // Need to pad key for AES
    // TODO: Best way?

    // Generate the secret key specs.
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

    // Instantiate the cipher
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

    byte[] encrypted = cipher.doFinal((secrectID).getBytes());
    System.out.println(""encrypted string: "" + asHex(encrypted));

    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
    byte[] original = cipher.doFinal(encrypted);
    String originalString = new String(original);
    System.out.println(""Original string: "" + originalString + ""\nOriginal string (Hex): "" + asHex(original));
}
</code></pre>

<p>Right now I get an exception ""<strong>Invalid AES key length: 86 bytes</strong>"". Do I need to pad my key? How should I do it?</p>

<p>Also do I need to set anything for ECB or CBC?</p>

<p>Thanks</p>
"	NULL	2	NULL	24:59.6	71	17:27.0	NULL	NULL	0	1992	0	1	94	<java><key><aes>	Java AES and using my own Key	226124	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3862800	3864276	6	"<p>I have a test which runs great on my development MacBook Pro, but fails to run in continuous integration TeamCity server.</p>

<p>The error is following:</p>

<pre><code>java.security.InvalidKeyException: Illegal key size
    at javax.crypto.Cipher.a(DashoA13*..)
    at javax.crypto.Cipher.init(DashoA13*..)
    at javax.crypto.Cipher.init(DashoA13*..)
</code></pre>

<p>Both development box and TeamCity uses Java 1.6 and I use BouncyCastle library for the need of special AES encryption.</p>

<p>The code is following:</p>

<pre><code>private byte[] aesEncryptedInfo(String info) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidAlgorithmParameterException, NoSuchProviderException {
    Security.addProvider(new BouncyCastleProvider());
    SecretKey secret = new SecretKeySpec(CUSTOMLONGSECRETKEY.substring(0, 32).getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");
    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(VECTOR_SECRET_KEY.getBytes()));
    return cipher.doFinal(info.getBytes(""UTF-8""));
}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>Looks like according to the selected answer I have to modify something on my TeamCity installation and it will possibly affect some user installations - so its not a good choice I have to switch to another crypto library to do that without limitations. So probably bouncy castle will help.</p>

<p><strong>UPDATE 2</strong></p>

<p>I actually switched to use BouncyCastle to avoid this limitation. Note this only works if you use own BC classes directly, not the BC provider.</p>
"	NULL	3	NULL	31:15.1	28	04:39.3	03:55.0	NULL	290050	290050	0	1	63	<java><aes><jce>	InvalidKeyException Illegal key size	87591	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
3954611	5760584	NULL	"<p>I have following program for encrypting data.</p>

<pre><code>import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Test {

    private static final String ALGORITHM = ""AES"";
    private static final byte[] keyValue = ""ADBSJHJS12547896"".getBytes();

    public static void main(String args[]) throws Exception {
        String encriptValue = encrypt(""dude5"");
        decrypt(encriptValue);

    }

    /**
     * @param args
     * @throws Exception
     */

    public static String encrypt(String valueToEnc) throws Exception {

        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.ENCRYPT_MODE, key);

        System.out.println(""valueToEnc.getBytes().length ""+valueToEnc.getBytes().length);
        byte[] encValue = c.doFinal(valueToEnc.getBytes());
        System.out.println(""encValue length"" + encValue.length);
        byte[] encryptedByteValue = new Base64().encode(encValue);
        String encryptedValue = encryptedByteValue.toString();
        System.out.println(""encryptedValue "" + encryptedValue);

        return encryptedValue;
    }

    public static String decrypt(String encryptedValue) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.DECRYPT_MODE, key);

        byte[] enctVal = c.doFinal(encryptedValue.getBytes());
        System.out.println(""enctVal length "" + enctVal.length);

        byte[] decordedValue = new Base64().decode(enctVal);

        return decordedValue.toString();
    }

    private static Key generateKey() throws Exception {
        Key key = new SecretKeySpec(keyValue, ALGORITHM);
        return key;
    }

}
</code></pre>

<p>Here I am getting the following out put with exception?</p>

<pre><code>valueToEnc.getBytes().length 5
encValue length16
encryptedValue [B@aa9835
Exception in thread ""main"" javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
    at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
    at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
</code></pre>

<p>Can some one explain me the cause? Why its only saying when decrypting that length should be 16. Doesn't it convert to 16 as like encrypting with the doFinal method.</p>

<p>And as the exception says ""<strong>how to decrypting without padded cipher?""</strong></p>
"	NULL	NULL	NULL	25:40.1	NULL	NULL	NULL	NULL	NULL	301957	0	1	35	<java><encryption><aes>	Encrypt and decrypt with AES and Base64 encoding	108381	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4062015	0	2	"<p>I am doing an assignment about use blowfish to do encryption &amp; decryption in java.</p>

<p>I had added a provider, and get instance ""Blowfish/ECB/NoPadding"", but I still get this error when I do the encryption. </p>

<pre><code>Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
</code></pre>

<p>e.g.:</p>

<pre><code>public static byte[] encrypt(byte to_encrypt[], byte strkey[]) {
    try {           
        SecretKeySpec key = new SecretKeySpec(strkey, ""Blowfish"");
        Cipher cipher = Cipher.getInstance(""Blowfish/ECB/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);  
        return cipher.doFinal(to_encrypt); // &lt;=========== error
    } catch (Exception e) { 
        e.printStackTrace();
        return null; 
    }
}
</code></pre>

<p>leads to</p>

<pre><code>javax.crypto.IllegalBlockSizeException: data not block size aligned
    at org.bouncycastle2.jce.provider.JCEBlockCipher.engineDoFinal(JCEBlockCipher.java:686)
    at javax.crypto.Cipher.doFinal(Cipher.java:1171)
</code></pre>

<p>Thank you.</p>
"	NULL	1	NULL	56:19.1	5	58:25.2	29:32.2	NULL	45664	492590	0	1	8	<java>	How to solve javax.crypto.IllegalBlockSizeException: data not block size aligned	25785	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4413023	4413290	2	"<p>I'm trying to encrypt a string on Android with AES. The symmetric key is determined previously with the Diffie-Hellman algorithm and seems to be ok (Key Length is 128 Bit, see below).<br>
Nevertheless, I get a  <code>InvalidKeyException: ""Key length not 128/192/256 bits.</code>""</p>

<p>Code:</p>

<pre><code>KeyAgreement keyAgree = KeyAgreement.getInstance(""DH"", ""BC"");
keyAgree.init(this.smartphonePrivKey);
keyAgree.doPhase(serverPubKey, true);
SecretKey key = keyAgree.generateSecret(""AES"");
System.out.println(""Key Length: "" + key.getEncoded().length);
System.out.println(""Key Algorithm: ""+ key.getAlgorithm());
System.out.println(""Key Format: ""+ key.getFormat());

byte[] encrypted = null;
  Cipher cipher;
  try {
   cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   System.out.println(""Allowed Key Length: ""
     + cipher.getMaxAllowedKeyLength(""AES""));
   cipher.init(Cipher.ENCRYPT_MODE, key);
   encrypted = cipher.doFinal(""YEAH"".getBytes(""UTF8""));
  } catch (NoSuchAlgorithmException e) {
   e.printStackTrace();
  } catch (NoSuchPaddingException e) {
   e.printStackTrace();
  } catch (InvalidKeyException e) {
   e.printStackTrace();
  } catch (IllegalBlockSizeException e) {
   e.printStackTrace();
  } catch (BadPaddingException e) {
   e.printStackTrace();
  } catch (UnsupportedEncodingException e) {
   e.printStackTrace();
  }
</code></pre>

<p>The above Code leads to the following output:  </p>

<pre><code>_12-10 20:24:53.119: INFO/System.out(757): Key Length: 128_  
_12-10 20:24:53.119: INFO/System.out(757): Key Algorithm: AES_   
_12-10 20:24:53.119: INFO/System.out(757): Key Format: RAW_  
_12-10 20:24:53.470: INFO/System.out(757): Allowed Key Length: 2147483647_ 
</code></pre>

<p>After that, I get the <code>InvalidKeyException: Key length not 128/192/256 bits.</code> But as you can see, the SecretKey has a length of 128 Bits!  </p>

<p>Any ideas?</p>
"	NULL	0	NULL	29:52.5	5	15:30.6	15:30.6	NULL	663604	502396	0	1	18	<android><encryption><aes><diffie-hellman>	AES encryption: InvalidKeyException: Key length not 128/192/256 bits	29426	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4551263	0	2	"<p>I want to convert String to secretKey</p>

<pre><code>public void generateCode(String keyStr){ 
KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
kgen.init(128); // 192 and 256 bits may not be available
// Generate the secret key specs.
secretKey skey=keyStr;  //How can I make the casting here
//SecretKey skey = kgen.generateKey();
byte[] raw = skey.getEncoded();
}
</code></pre>

<p>I try to use BASE64Decoder instead of secretKey, but I face a problem which is I cannot specify key length.</p>

<p><strong>EDIT:</strong>
I want to call this function from another place </p>

<pre><code> static public String encrypt(String message , String key , int keyLength) throws Exception {
     // Get the KeyGenerator
   KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    kgen.init(keyLength); // 192 and 256 bits may not be available
    // Generate the secret key specs.
     SecretKey skey = key; //here is the error
   byte[] raw = skey.getEncoded();
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    // Instantiate the cipher
    Cipher cipher = Cipher.getInstance(""AES"");

    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    System.out.println(""msg is"" + message + ""\n raw is"" + raw);
    byte[] encrypted = cipher.doFinal(message.getBytes());
    String cryptedValue = new String(encrypted);
    System.out.println(""encrypted string: "" + cryptedValue);
    return cryptedValue;
}
</code></pre>

<p>If anybody could help, I'd be very thankful.</p>
"	NULL	1	NULL	28:53.9	14	13:25.9	13:25.9	NULL	2083854	2067571	0	1	10	<java><encryption>	How can I convert a String to a SecretKey	33356	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4560461	0	3	"<p>I have the following code.</p>

<pre><code>    byte[] input = etInput.getText().toString().getBytes();
    byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
        0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

    // encryption pass
    cipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
    ctLength += cipher.doFinal(cipherText, ctLength);

    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
    int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);

    String strLength = new String(cipherText,""US-ASCII"");
    byte[] byteCiphterText = strLength.getBytes(""US-ASCII"");
    Log.e(""Decrypt"", Integer.toString(byteCiphterText.length));

    etOutput.setText(new String(cipherText,""US-ASCII""));

    cipherText  = etOutput.getText().toString().getBytes(""US-ASCII"");
    Log.e(""Decrypt"", Integer.toString(cipherText.length));

    ptLength += cipher.doFinal(plainText, ptLength);
    Log.e(""Decrypt"", new String(plainText));
    Log.e(""Decrypt"", Integer.toString(ptLength));
</code></pre>

<p>It works perfectly.
But once I convert it to the class. It always hit the error in this line.</p>

<pre><code> ptLength += cipher.doFinal(plainText, ptLength);

 Error:Pad block corrupted
</code></pre>

<p>I have checked and both code are exactly the same. Even the value passed in conversion string to byte all is no different from the code above. Any idea what's wrong with the code?</p>

<pre><code>public String Encrypt(String strPlainText) throws Exception, NoSuchProviderException,
        NoSuchPaddingException {
    byte[] input = strPlainText.getBytes();
    byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
            0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

    // encryption pass
    cipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
    ctLength += cipher.doFinal(cipherText, ctLength);

    return new String(cipherText, ""US-ASCII"");
}

public String Decrypt(String strCipherText) throws Exception,
        NoSuchProviderException, NoSuchPaddingException {
    byte[] cipherText = strCipherText.getBytes(""US-ASCII"");
    int ctLength = cipherText.length;
    byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
            0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

    // decryption pass
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
    int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);
    ptLength += cipher.doFinal(plainText, ptLength);

    return new String(plainText);
}
</code></pre>
"	NULL	2	NULL	18:32.5	3	39:13.9	39:13.9	NULL	2806497	557964	0	1	7	<java><android><encryption>	Decryption Error: Pad block corrupted	34630	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4580982	4581156	5	"<p>I am working on AES algorithm, and I have this exception which I couldn't solve.</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
at javax.crypto.Cipher.doFinal(DashoA13*..)
</code></pre>

<p>the exception happens in the decryption part.
I initialize the key in a different place from where the decryption algorithm is </p>

<pre><code>KeyGenerator kgen = KeyGenerator.getInstance(""AES"");//key generation for AES
kgen.init(128); // 192 and 256 bits may not be available
</code></pre>

<p>then I pass it with the cipher text which I read from file to the following method</p>

<pre><code> public String decrypt(String message, SecretKey skey) {

    byte[] raw = skey.getEncoded();
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    // Instantiate the cipher
    Cipher cipher;

    byte[] original = null;
    try {
        cipher = Cipher.getInstance(""AES"");

        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        System.out.println(""Original string: ""
                + message);
        original = cipher.doFinal(message.trim().getBytes());  //here where I got the exception
        String originalString = new String(original);
       }
 //catches
</code></pre>

<p><strong>EDIT</strong>
here's the encryption method.</p>

<pre><code>public String encrypt(String message, SecretKey skey) {
    byte[] raw = skey.getEncoded();
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

    // Instantiate the cipher

    Cipher cipher;
    byte[] encrypted = null;
    try {
        cipher = Cipher.getInstance(""AES"");

        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        encrypted = cipher.doFinal(message.getBytes());
        System.out.println(""raw is "" + encrypted);

    } catches
    return asHex(encrypted);
}
</code></pre>

<p>and here's the asHex method</p>

<pre><code>  public static String asHex(byte buf[]) {
    StringBuffer strbuf = new StringBuffer(buf.length * 2);
    int i;

    for (i = 0; i &lt; buf.length; i++) {
        if (((int) buf[i] &amp; 0xff) &lt; 0x10) {
            strbuf.append(""0"");
        }

        strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
    }

    return strbuf.toString();
}
</code></pre>

<p>Here's where I read the cipher text form the file</p>

<pre><code>static public String readFile(String filePath) {
    StringBuilder file = new StringBuilder();
    String line = null;
    try {
        FileReader reader = new FileReader(filePath);
        BufferedReader br = new BufferedReader(reader);
        if (br != null) {
            line = br.readLine();
            while (line != null) {
                file.append(line);
                //      System.out.println(""line is "" + line);
                line = br.readLine();

            }
        }
        br.close();
        reader.close();
    } catch (IOException ex) {
        Logger.getLogger(FileManagement.class.getName()).log(Level.SEVERE, null, ex);
    }
    System.out.println(""line is "" + file.toString());
    return String.valueOf(file);

}
</code></pre>

<p>can someone help?</p>
"	NULL	3	NULL	59:01.7	14	45:23.2	41:28.9	NULL	940217	2067571	0	1	25	<java><exception><cryptography><encryption>	javax.crypto.BadPaddingException	112428	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4663912	4669213	2	"<p>I tried to decrypt a 4.2 MB .dcf file using AES 128 bit key, but it took 33 seconds to decrypt (on function cipher.doFinal(data)), is it normal ?</p>

<p>Here is a code snippet:</p>

<pre><code>long start = System.currentTimeMillis()/1000L;
            try {
                SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);

                 android.util.Log.d(""TEST"", ""Start decoding...."" + String.valueOf(length));

                byte[] decrypted = cipher.doFinal(content);

                File file2 = new File(Environment.getExternalStorageDirectory().getPath() + ""/test.mp3"");
                OutputStream os = new FileOutputStream(file2);
                os.write(decrypted);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            long end = System.currentTimeMillis()/1000L;

            android.util.Log.d(""TEST"",""Time ""+ String.valueOf(end-start));
</code></pre>
"	NULL	5	NULL	38:01.0	8	36:54.5	NULL	NULL	0	431041	0	1	6	<android><encryption><aes>	Slow AES decryption in Android	5443	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
4951468	4952335	3	"<p>from what I know, CTR mode doesn't use an Initial Vector.
It just takes a counter, encrypts it with a given key and then XOR's the result with the plaintext in order to get the ciphertext.</p>

<p>Other block cipher modes like CBC before doing the encryption they XOR the plaintext with an Initial Vector.</p>

<p>So here is my problem. I have the following code in Java(using bouncycastle library):</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CTR/PKCS5Padding"", ""BC"");

cipher.init(Cipher.ENCRYPT_MODE, key);

byte[] result = cipher.doFinal(""Some plaintext"");
</code></pre>

<p>Every different call of the above code with the same key gives different output! But when doing:</p>

<pre><code>byte[] IV = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

Cipher cipher = Cipher.getInstance(""AES/CTR/PKCS5Padding"", ""BC"");

cipher.init(Cipher.ENCRYPT_MODE, key, IV);

byte[] result = cipher.doFinal(""Some plaintext"");
</code></pre>

<p>I take the same result in every call of the above code.
But why is this? I mean, CTR doesn't need an IV, so why when I don't give an IV in every call I get a different result and when I given an IV it returns the same result? 
If I always use the above IV(all zeroes) when using CTR, would that be safe?</p>

<p>Any ideas would be very helpful.
Thank you</p>
"	NULL	3	NULL	45:13.9	6	54:52.2	54:52.2	NULL	21234	610549	0	1	8	<java><cryptography><initialization-vector><block-cipher>	CTR mode use of Initial Vector(IV)	10130	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
5354313	5354740	1	"<p>I have an issue with AES encryptio and decryption: I can change my IV entirely and still I'm able to decode my data.</p>

<pre><code>public static final byte[] IV = { 65, 1, 2, 23, 4, 5, 6, 7, 32, 21, 10, 11, 12, 13, 84, 45 };
public static final byte[] IV2 = { 65, 1, 2, 23, 45, 54, 61, 81, 32, 21, 10, 121, 12, 13, 84, 45 };
public static final byte[] KEY = { 0, 42, 2, 54, 4, 45, 6, 7, 65, 9, 54, 11, 12, 13, 60, 15 };
public static final byte[] KEY2 = { 0, 42, 2, 54, 43, 45, 16, 17, 65, 9, 54, 11, 12, 13, 60, 15 };
//public static final int BITS = 256;

public static void test()
{
    try
    {
        // encryption
        Cipher c = Cipher.getInstance(""AES"");
        SecretKeySpec keySpec = new SecretKeySpec(KEY, ""AES"");
        c.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(IV));

        String s = ""Secret message"";
        byte[] data = s.getBytes();

        byte[] encrypted = c.doFinal(data);

        String encryptedStr = """";
        for (int i = 0; i &lt; encrypted.length; i++)
            encryptedStr += (char) encrypted[i];


        //decryoption
        Cipher d_c = Cipher.getInstance(""AES"");
        SecretKeySpec d_keySpec = new SecretKeySpec(KEY, ""AES"");
        d_c.init(Cipher.DECRYPT_MODE, d_keySpec, new IvParameterSpec(IV2));

        byte[] decrypted = d_c.doFinal(encrypted);
        String decryptedStr = """";
        for (int i = 0; i &lt; decrypted.length; i++)
            decryptedStr += (char) decrypted[i];
        Log.d("""", decryptedStr);

    }
    catch (Exception ex)
    {
        Log.d("""", ex.getMessage());
    }
}
</code></pre>

<p>Any ideas what I'm doing wrong? How can I get 256 bit AES encryption (only change key to 32-byte long array?)</p>

<p>Encryption is a new topic for me so please for newbie friendly answers.</p>
"	NULL	0	NULL	36:21.2	9	09:25.1	NULL	NULL	0	662699	0	1	5	<android><encryption><initialization><aes>	Android AES and init vector	7413	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
5520640	5520679	NULL	"<p>I am trying to learn and test the java 1.6 encryption/decryption API. I want to know what I am doing wrong and what I am missing in terms of knowledge. </p>

<p>In the code that follows below, I create two ciphers: one to encrypt and another to decrypt. When I use these ciphers, I initialize them with different SecretKey's, but I am still able to get the same value back out. Why is this?</p>

<pre><code>    String algorithm = ""DES"";
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);

    byte[] encBytes = ""12345678"".getBytes(""UTF8"");
    byte[] decBytes = ""56781234"".getBytes(""UTF8"");

    DESKeySpec keySpecEncrypt = new DESKeySpec(encBytes);
    DESKeySpec keySpecDecrypt = new DESKeySpec(decBytes);


    SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);
    SecretKey keyDecrypt = keyFactory.generateSecret(keySpecDecrypt);

    Cipher cipherEncrypt = Cipher.getInstance(algorithm);
    Cipher cipherDecrypt = Cipher.getInstance(algorithm);

    String input = ""john doe"";

    cipherEncrypt.init(Cipher.ENCRYPT_MODE, keyEncrypt);
    byte[] inputBytes = cipherEncrypt.doFinal(input.getBytes());
    System.out.println(""inputBytes: "" + new String(inputBytes));

    cipherDecrypt.init(Cipher.DECRYPT_MODE, keyDecrypt);
    byte[] outputBytes = cipherDecrypt.doFinal(inputBytes);
    System.out.println(""outputBytes: "" + new String(outputBytes));
</code></pre>
"	NULL	NULL	NULL	06:57.5	NULL	NULL	NULL	NULL	NULL	373312	0	1	6	<java><encryption>	Encrypting and Decrypting Using Java: Unable to get same output	32505	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
5763723	5763743	1	"<p>So I'm writing a program to encrypt and decrypt text files but I seem to be always getting this error when I use an encrypthion other than ""Blowfish"" (e.g. ""Blowfish/CBC/PKCS5Padding""). The excepthiong I get is:</p>

<pre><code>Exception in thread ""main"" java.security.NoSuchAlgorithmException: Blowfish/CBC/PKCS5Padding KeyGenerator not available
    at javax.crypto.KeyGenerator.&lt;init&gt;(DashoA13*..)
    at javax.crypto.KeyGenerator.getInstance(DashoA13*..)
    at Encryptor.&lt;init&gt;(Encryptor.java:87)
    at Encryptor.main(Encryptor.java:30)
</code></pre>

<p>A portion of my code:</p>

<pre><code>import java.security.MessageDigest;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encryptor2 {
    private IvParameterSpec ivSpec;
    private SecretKeySpec keySpec;
    private Cipher cipher;

    public static void main(String[] args) throws Exception {
        Encryptor2 e = new Encryptor2(
                ""averylongtext!@$@#$#@$#*&amp;(*&amp;}{23432432432dsfsdf"");
        String enc = e.encrypt(""john doe"");
        String dec = e.decrypt(enc);
    }

    public Encryptor2(String pass) throws Exception {
        // setup AES cipher in CBC mode with PKCS #5 padding
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        // setup an IV (initialization vector) that should be
        // randomly generated for each input that's encrypted
        byte[] iv = new byte[cipher.getBlockSize()];
        new SecureRandom().nextBytes(iv);
        ivSpec = new IvParameterSpec(iv);

        // hash keyString with SHA-256 and crop the output to 128-bit for key
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(pass.getBytes());
        byte[] key = new byte[16];
        System.arraycopy(digest.digest(), 0, key, 0, key.length);
        keySpec = new SecretKeySpec(key, ""AES"");
    }

    public String encrypt(String original) throws Exception {
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
        byte[] encrypted = cipher.doFinal(original.getBytes(""UTF-8""));
        System.out.println(""encrypted: `"" + new String(encrypted) + ""`"");
        return new String(encrypted);
    }

    public String decrypt(String encrypted) throws Exception {
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
        byte[] decrypted = cipher.doFinal(encrypted.getBytes(""UTF-8""));
        System.out.println(""decrypted: `"" + new String(decrypted, ""UTF-8"")
                + ""`"");
        return new String(decrypted, ""UTF-8"");
    }
}
</code></pre>

<p>But now it fails with <code>Input length must be multiple of 16 when decrypting with padded cipher</code></p>
"	NULL	0	NULL	44:41.4	3	23:29.1	23:29.1	NULL	2074706	2074706	0	1	4	<java><encryption><blowfish>	How to fix the NoSuchAlgorithmException in Java when using Blowfish?	14602	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6258047	0	4	"<p>Does anyone know what the default Java crypto behavior is for:</p>

<pre><code>SecretKeySpec localSecretKeySpec = new SecretKeySpec(arrayOfByte, ""AES"");
Cipher localCipher = Cipher.getInstance(""AES"");
</code></pre>

<p>Specifically I am looking to understand how those classes generate the IV, as well as what is the default encryption mode when just specifying ""AES"".  Thanks.</p>
"	NULL	2	NULL	07:11.7	9	03:24.8	NULL	NULL	0	291059	0	1	36	<java><cryptography><aes>	Java default Crypto/AES behavior	28553	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6538485	6538834	5	"<p>I am new in cipher technology. I found this code to do Symmetric Encryption.</p>

<pre><code>byte[] key = //... secret sequence of bytes
byte[] dataToSend = ...
Cipher c = Cipher.getInstance(""AES"");
SecretKeySpec k = new SecretKeySpec(key, ""AES"");
c.init(Cipher.ENCRYPT_MODE, k);
byte[] encryptedData = c.doFinal(dataToSend);
</code></pre>

<p>Its working. Here I can use my own password. And thats what exactly I needed. But I dont know how to do 128 or 256 Symmetric Enctryption.
How can I use 128 and 256 key into my code ?</p>
"	NULL	4	NULL	09:53.3	16	22:51.1	34:33.3	NULL	823496	823496	0	1	15	<java><aes><encryption>	Java using AES 256 and 128 Symmetric-key encryption	71984	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6608529	6609983	1	"<p>I have a problem in encrypting/decrypting log file generated by log4j's RollingFileAppender. For the encryption I have tried to extend the RollingFileAppender, just call it EncryptedRollingFileAppender. I override the method</p>

<pre><code>setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)
</code></pre>

<p>and basically I use CipherOutputStream and Base64OutputStream to encrypt and encode everything written to the output stream. Here's part of the code:</p>

<pre><code>...
setImmediateFlush(true);

FileOutputStream ostream = null;
CipherOutputStream cstream = null;
Base64OutputStream b64stream = null;
try {        
    byte[] keyBytes = ""1234123412341234"".getBytes();  //example
    final byte[] ivBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 
         0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f }; //example

    final SecretKey key = new SecretKeySpec(keyBytes, ""AES"");
    final IvParameterSpec IV = new IvParameterSpec(ivBytes);
    final Cipher cipher = Cipher.getInstance(""AES/CFB8/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, IV);

    ostream = new FileOutputStream(fileName, true);
    b64stream = new Base64OutputStream(ostream);
    cstream = new CipherOutputStream(b64stream, cipher);

    } catch(Exception ex) {
        ex.printStackTrace();
    }

Writer cw = createWriter(cstream);
...
</code></pre>

<p>And then i decrypt the file with this code:</p>

<pre><code>private static void decryptFile(String filename) throws Exception {
    FileInputStream fis = null;
    BufferedReader br = new BufferedReader(new FileReader(filename));

    File file = new File(filename + ""-decrypted"");
    file.createNewFile();
    Writer out = new OutputStreamWriter(new FileOutputStream(filename + ""-decrypted""), ""UTF-8"");

    String line = null;
    try {
         while (( line = br.readLine()) != null){
             line = decrypt(Base64.decodeBase64(line));
             out.write(line);
         }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (br != null) {
            br.close();
        }
        if (fis != null) {
            fis.close();
        }
        if (out != null) {
            out.close();
        }
    }
}

public static String decrypt(byte[] line) throws Exception {
    byte[] keyBytes = ""1234123412341234"".getBytes();
    final byte[] ivBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

    final SecretKey secretkey = new SecretKeySpec(keyBytes, ""AES"");
    final IvParameterSpec IV = new IvParameterSpec(ivBytes);
    final Cipher decipher = Cipher.getInstance(""AES/CFB8/NoPadding"");
    decipher.init(Cipher.DECRYPT_MODE, secretkey, IV);
    final byte[] plainText = decipher.doFinal(line);

    return new String(plainText, ""UTF-8"").trim();
}
</code></pre>

<p>It worked but only partially. Some texts in the result file were decrypted correctly but some others were not. If you're curious, this is what I mean by partially:</p>

<pre><code>07 Jul 11 13:13:13, DEBUG  MrBean.java:checkUserVal????V;??????? - username: squall,password: 4GROmr95Qcf????v?M?7?y?5?@CGO09 ,active: true 
</code></pre>

<p>I also have tried changing the algorithm to ""DESede"" but it was still partially decrypted. Then I tried to use ""CBC/PKCS5Padding"" in both ends but I got an exception</p>

<pre><code>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
</code></pre>

<p>I assume the encryption is not properly padding the input but I wonder why... because when I use the same encryption and decryption algorithms without the CipherOutputStream the padding worked just fine.
Anyone can help me to make this works? Any help will be appreciated.</p>

<p>PS: Sorry for my English, it's not my native language.</p>
"	NULL	2	NULL	35:15.0	3	35:59.3	35:59.3	NULL	519743	519743	0	1	10	<java><file><log4j><encryption>	How to use CipherOutputStream correctly to encrypt and decrypt log created with log4j (RollingFileAppender)	25425	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6679734	6681342	1	"<p>I've built a QR code generator and a QR code scanner for passing data about phones and their users between phones (the phones are being loaned out so there will be a master phone with the scanner app and the rest with the generator app). The QR code generated is a JSON format string containing a persons name/number/imei of their phone but for security I have tried to encrypt the string before encoding to QR, but the scanned QR code throws up a 'pad block corrupted' error.</p>

<p>The JSON data encodes into QR/decodes from QR fine as plain text, and I checked the encryption/decryption before encoding to QR and the data encrypts/decrypts fine, so it's something to do with when the encrypted text is encoded into QR but I've no idea where to begin with it!</p>

<p>Does anyone know how i can sort the issue? Or if theres any QR friendly encryption methods?!!</p>

<p>I took the QRCodeEncoder straight from ZXings source and placed it into my activity:</p>

<pre><code>/**QR ENCODER CLASS****************************************************/

    public class QRCodeEncoder
    {
        private final String TAG = QRCodeEncoder.class.getSimpleName();

          private static final int WHITE = 0xFFFFFFFF;
          private static final int BLACK = 0xFF000000;

          private final Activity activity;
          private String contents;
          private String displayContents;
          private String title;
          private BarcodeFormat format;
          private final int dimension;

          QRCodeEncoder(Activity activity, Intent intent, int dimension) {
                this.activity = activity;
                if (intent == null) {
                  throw new IllegalArgumentException(""No valid data to encode. intent is null"");
                }

                String action = intent.getAction();
                if (action.equals(Intents.Encode.ACTION)) {
                  if (!encodeContentsFromZXingIntent(intent)) {
                    throw new IllegalArgumentException(""No valid data to encode. Zxing intent returned false"");
                  }
                } else if (action.equals(Intent.ACTION_SEND)) {
                  if (!encodeContentsFromShareIntent(intent)) {
                    throw new IllegalArgumentException(""No valid data to encode. Share Intent returned false"");
                  }
                }

                this.dimension = dimension;
              }

              public String getContents() {
                return contents;
              }

              public String getDisplayContents() {
                return displayContents;
              }

              public String getTitle() {
                return title;
              }

              // It would be nice if the string encoding lived in the core ZXing library,
              // but we use platform specific code like PhoneNumberUtils, so it can't.
              private boolean encodeContentsFromZXingIntent(Intent intent) {
                 // Default to QR_CODE if no format given.
                String formatString = intent.getStringExtra(Intents.Encode.FORMAT);
                try {
                  format = BarcodeFormat.valueOf(formatString);
                } catch (IllegalArgumentException iae) {
                  // Ignore it then
                  format = null;
                }
                if (format == null || BarcodeFormat.QR_CODE.equals(format)) {
                  String type = intent.getStringExtra(Intents.Encode.TYPE);
                  if (type == null || type.length() == 0) {
                    return false;
                  }
                  this.format = BarcodeFormat.QR_CODE;
                  encodeQRCodeContents(intent, type);
                } else {
                  String data = intent.getStringExtra(Intents.Encode.DATA);
                  if (data != null &amp;&amp; data.length() &gt; 0) {
                    contents = data;
                    displayContents = data;
                    title = ""QR Encoder"";
                  }
                }
                return contents != null &amp;&amp; contents.length() &gt; 0;
              }

              // Handles send intents from multitude of Android applications
              private boolean encodeContentsFromShareIntent(Intent intent) {
                // Check if this is a plain text encoding, or contact
                if (intent.hasExtra(Intent.EXTRA_TEXT)) {
                  return encodeContentsFromShareIntentPlainText(intent);
                }
                // Attempt default sharing.
                return encodeContentsFromShareIntentDefault(intent);
              }

              private boolean encodeContentsFromShareIntentPlainText(Intent intent) {
                // Notice: Google Maps shares both URL and details in one text, bummer!
                contents = intent.getStringExtra(Intent.EXTRA_TEXT);
                Toast.makeText(getApplicationContext(),""contents read = ""+contents,Toast.LENGTH_SHORT).show();
                // We only support non-empty and non-blank texts.
                // Trim text to avoid URL breaking.
                if (contents == null) {
                  return false;
                }
                contents = contents.trim();
                if (contents.length() == 0) {
                  return false;
                }
                // We only do QR code.
                format = BarcodeFormat.QR_CODE;
                if (intent.hasExtra(Intent.EXTRA_SUBJECT)) {
                  displayContents = intent.getStringExtra(Intent.EXTRA_SUBJECT);
                } else if (intent.hasExtra(Intent.EXTRA_TITLE)) {
                  displayContents = intent.getStringExtra(Intent.EXTRA_TITLE);
                } else {
                  displayContents = contents;
                }
                title = ""QR Encoder"";
                return true;
              }

              // Handles send intents from the Contacts app, retrieving a contact as a VCARD.
              // Note: Does not work on HTC devices due to broken custom Contacts application.
              private boolean encodeContentsFromShareIntentDefault(Intent intent) {
                format = BarcodeFormat.QR_CODE;
                try {
                  Uri uri = (Uri)intent.getExtras().getParcelable(Intent.EXTRA_STREAM);
                  InputStream stream = activity.getContentResolver().openInputStream(uri);
                  int length = stream.available();
                  if (length &lt;= 0) {
                    Log.w(TAG, ""Content stream is empty"");
                    return false;
                  }
                  byte[] vcard = new byte[length];
                  int bytesRead = stream.read(vcard, 0, length);
                  if (bytesRead &lt; length) {
                    Log.w(TAG, ""Unable to fully read available bytes from content stream"");
                    return false;
                  }
                  String vcardString = new String(vcard, 0, bytesRead, ""UTF-8"");
                  Log.d(TAG, ""Encoding share intent content:"");
                  Log.d(TAG, vcardString);
                  Result result = new Result(vcardString, vcard, null, BarcodeFormat.QR_CODE);
                  ParsedResult parsedResult = ResultParser.parseResult(result);
                  if (!(parsedResult instanceof AddressBookParsedResult)) {
                    Log.d(TAG, ""Result was not an address"");
                    return false;
                  }
                  if (!encodeQRCodeContents((AddressBookParsedResult) parsedResult)) {
                    Log.d(TAG, ""Unable to encode contents"");
                    return false;
                  }
                } catch (IOException e) {
                  Log.w(TAG, e);
                  return false;
                } catch (NullPointerException e) {
                  Log.w(TAG, e);
                  // In case the uri was not found in the Intent.
                  return false;
                }
                return contents != null &amp;&amp; contents.length() &gt; 0;
              }

              private void encodeQRCodeContents(Intent intent, String type) {
                if (type.equals(Contents.Type.TEXT)) {
                  String data = intent.getStringExtra(Intents.Encode.DATA);
                  if (data != null &amp;&amp; data.length() &gt; 0) {
                    contents = data;
                    displayContents = data;
                    title = ""QR Encoder"";
                  }
                } else if (type.equals(Contents.Type.EMAIL)) {
                  String data = trim(intent.getStringExtra(Intents.Encode.DATA));
                  if (data != null) {
                    contents = ""mailto:"" + data;
                    displayContents = data;
                    title = ""QR Encoder"";
                  }
                } else if (type.equals(Contents.Type.PHONE)) {
                  String data = trim(intent.getStringExtra(Intents.Encode.DATA));
                  if (data != null) {
                    contents = ""tel:"" + data;
                    displayContents = PhoneNumberUtils.formatNumber(data);
                    title = ""QR Encoder"";
                  }
                } else if (type.equals(Contents.Type.SMS)) {
                  String data = trim(intent.getStringExtra(Intents.Encode.DATA));
                  if (data != null) {
                    contents = ""sms:"" + data;
                    displayContents = PhoneNumberUtils.formatNumber(data);
                    title = ""QR Encoder"";
                  }
                } else if (type.equals(Contents.Type.CONTACT)) {
                  Bundle bundle = intent.getBundleExtra(Intents.Encode.DATA);
                  if (bundle != null) {
                    StringBuilder newContents = new StringBuilder(100);
                    StringBuilder newDisplayContents = new StringBuilder(100);
                    newContents.append(""MECARD:"");
                    String name = trim(bundle.getString(Contacts.Intents.Insert.NAME));
                    if (name != null) {
                      newContents.append(""N:"").append(escapeMECARD(name)).append(';');
                      newDisplayContents.append(name);
                    }
                    String address = trim(bundle.getString(Contacts.Intents.Insert.POSTAL));
                    if (address != null) {
                      newContents.append(""ADR:"").append(escapeMECARD(address)).append(';');
                      newDisplayContents.append('\n').append(address);
                    }
                    for (int x = 0; x &lt; Contents.PHONE_KEYS.length; x++) {
                      String phone = trim(bundle.getString(Contents.PHONE_KEYS[x]));
                      if (phone != null) {
                        newContents.append(""TEL:"").append(escapeMECARD(phone)).append(';');
                        newDisplayContents.append('\n').append(PhoneNumberUtils.formatNumber(phone));
                      }
                    }
                    for (int x = 0; x &lt; Contents.EMAIL_KEYS.length; x++) {
                      String email = trim(bundle.getString(Contents.EMAIL_KEYS[x]));
                      if (email != null) {
                        newContents.append(""EMAIL:"").append(escapeMECARD(email)).append(';');
                        newDisplayContents.append('\n').append(email);
                      }
                    }
                    // Make sure we've encoded at least one field.
                    if (newDisplayContents.length() &gt; 0) {
                      newContents.append(';');
                      contents = newContents.toString();
                      displayContents = newDisplayContents.toString();
                      title = ""QR Encoder"";
                    } else {
                      contents = null;
                      displayContents = null;
                    }
                  }
                } else if (type.equals(Contents.Type.LOCATION)) {
                  Bundle bundle = intent.getBundleExtra(Intents.Encode.DATA);
                  if (bundle != null) {
                    // These must use Bundle.getFloat(), not getDouble(), it's part of the API.
                    float latitude = bundle.getFloat(""LAT"", Float.MAX_VALUE);
                    float longitude = bundle.getFloat(""LONG"", Float.MAX_VALUE);
                    if (latitude != Float.MAX_VALUE &amp;&amp; longitude != Float.MAX_VALUE) {
                      contents = ""geo:"" + latitude + ',' + longitude;
                      displayContents = latitude + "","" + longitude;
                      title = ""QR Encoder"";
                    }
                  }
                }
              }

              private boolean encodeQRCodeContents(AddressBookParsedResult contact) {
                StringBuilder newContents = new StringBuilder(100);
                StringBuilder newDisplayContents = new StringBuilder(100);
                newContents.append(""MECARD:"");
                String[] names = contact.getNames();
                if (names != null &amp;&amp; names.length &gt; 0) {
                  String name = trim(names[0]);
                  if (name != null) {
                    newContents.append(""N:"").append(escapeMECARD(name)).append(';');
                    newDisplayContents.append(name);
                  }
                }
                String[] addresses = contact.getAddresses();
                if (addresses != null) {
                  for (String address : addresses) {
                    address = trim(address);
                    if (address != null) {
                      newContents.append(""ADR:"").append(escapeMECARD(address)).append(';');
                      newDisplayContents.append('\n').append(address);
                    }
                  }
                }
                String[] phoneNumbers = contact.getPhoneNumbers();
                if (phoneNumbers != null) {
                  for (String phone : phoneNumbers) {
                    phone = trim(phone);
                    if (phone != null) {
                      newContents.append(""TEL:"").append(escapeMECARD(phone)).append(';');
                      newDisplayContents.append('\n').append(PhoneNumberUtils.formatNumber(phone));
                    }
                  }
                }
                String[] emails = contact.getEmails();
                if (emails != null) {
                  for (String email : emails) {
                    email = trim(email);
                    if (email != null) {
                      newContents.append(""EMAIL:"").append(escapeMECARD(email)).append(';');
                      newDisplayContents.append('\n').append(email);
                    }
                  }
                }
                String url = trim(contact.getURL());
                if (url != null) {
                  newContents.append(""URL:"").append(escapeMECARD(url)).append(';');
                  newDisplayContents.append('\n').append(url);
                }
                // Make sure we've encoded at least one field.
                if (newDisplayContents.length() &gt; 0) {
                  newContents.append(';');
                  contents = newContents.toString();
                  displayContents = newDisplayContents.toString();
                  title = ""QR Encoder"";
                  return true;
                } else {
                  contents = null;
                  displayContents = null;
                  return false;
                }
              }

              Bitmap encodeAsBitmap() throws WriterException {
                Hashtable&lt;EncodeHintType,Object&gt; hints = null;
                String encoding = guessAppropriateEncoding(contents);
                if (encoding != null) {
                  hints = new Hashtable&lt;EncodeHintType,Object&gt;(2);
                  hints.put(EncodeHintType.CHARACTER_SET, encoding);
                }
                MultiFormatWriter writer = new MultiFormatWriter();
                BitMatrix result = writer.encode(contents, format, dimension, dimension, hints);
                int width = result.getWidth();
                int height = result.getHeight();
                int[] pixels = new int[width * height];
                // All are 0, or black, by default
                for (int y = 0; y &lt; height; y++) {
                  int offset = y * width;
                  for (int x = 0; x &lt; width; x++) {
                    pixels[offset + x] = result.get(x, y) ? BLACK : WHITE;
                  }
                }

                Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                bitmap.setPixels(pixels, 0, width, 0, 0, width, height);
                return bitmap;
              }

              private String guessAppropriateEncoding(CharSequence contents) {
                // Very crude at the moment
                for (int i = 0; i &lt; contents.length(); i++) {
                  if (contents.charAt(i) &gt; 0xFF) {
                    return ""UTF-8"";
                  }
                }
                return null;
              }

              private String trim(String s) {
                if (s == null) {
                  return null;
                }
                s = s.trim();
                return s.length() == 0 ? null : s;
              }

              private String escapeMECARD(String input) {
                if (input == null || (input.indexOf(':') &lt; 0 &amp;&amp; input.indexOf(';') &lt; 0)) {
                  return input;
                }
                int length = input.length();
                StringBuilder result = new StringBuilder(length);
                for (int i = 0; i &lt; length; i++) {
                  char c = input.charAt(i);
                  if (c == ':' || c == ';') {
                    result.append('\\');
                  }
                  result.append(c);
                }
                return result.toString();
              }
    }
</code></pre>

<p>And the encryption/decryption class from <a href=""http://www.androidsnippets.com/encryptdecrypt-strings"" rel=""nofollow"">this website (unedited)</a></p>

<p>Here's a snippet of the onCreate() method in my activity:</p>

<pre><code>QRCodeEncoder myQRCodeEncoder;

protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.qr_view);
            ImageView imageView = (ImageView)findViewById(R.id.qr_image);

            extStorageDirectory = Environment.getExternalStorageDirectory().toString();
            try
            {

                //JSON data is passed from another activity to this one
                qrMessage = getIntent().getStringExtra(""QR_JSON"");

                Intent encode = new Intent(Intents.Encode.ACTION);
                encode.putExtra(Intents.Encode.TYPE, Contents.Type.TEXT);
                encode.putExtra(Intents.Encode.FORMAT, ""QR_CODE"");
                    //This is the original plain text way that works:
                //encode.putExtra(Intents.Encode.DATA, qrMessage);

                    //This is the encyption way
                String encMessage = SimpleCrypto.encrypt(""my s3cr3t k3y"", qrMessage);
                encode.putExtra(Intents.Encode.DATA,encMessage);


                myQRCodeEncoder = new QRCodeEncoder(this, encode, 200);
            }
            catch(Exception e)
            {
                Toast.makeText(getApplicationContext(),""Could not encode:""+e.getMessage(),Toast.LENGTH_SHORT).show();
            }
            catch(Error e)
            {
                Toast.makeText(getApplicationContext(),""Could not encode:""+e.getMessage(),Toast.LENGTH_SHORT).show();
            }


            try {
                Bitmap qrBitmap = myQRCodeEncoder.encodeAsBitmap();
                imageView.setImageBitmap(qrBitmap);
            } catch (Exception e) {
                Toast.makeText(getApplicationContext(),""Could not set image:""+e.getMessage(),Toast.LENGTH_SHORT).show(); 
            }
    }
</code></pre>

<p>And here's the onActivityResult method from the scanner (I use ZXing's barcode scanner to retrieve the data)</p>

<pre><code>public void onActivityResult(int requestCode, int resultCode, Intent intent) {
    if (requestCode == 0) {
        if (resultCode == RESULT_OK) {
            String contents = intent.getStringExtra(""SCAN_RESULT"");//contents of the scan
            String format = intent.getStringExtra(""SCAN_RESULT_FORMAT"");
            // Handle successful scan

            /* display the scanned persons info*/
            try {
                String decryptedcontents = SimpleCrypto.decrypt(""my s3cr3t k3y"",contents);
                String result = getJSONFromScanData(decryptedcontents);

            } catch (Exception e) {
                // TODO Auto-generated catch block
                Toast.makeText(this, ""Scanned data could not be decrypted:""+e.getMessage(), Toast.LENGTH_SHORT).show();//says 'pad block corrupted' as the message
            }



        } else if (resultCode == RESULT_CANCELED) {
            // Handle cancel
            Toast.makeText(this, ""Scan cancelled"", Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre>

<p>EDIT: after some further investigation it seems that the encyption/decyption process seems to 'shave off' part of the data:</p>

<pre><code> JSONObject example = new JSONObject(""{\""user_firstname\"":\""Ben\"",\""user_lastname\"":\"" Ten\"",\""user_login\"":\""benten\"",\""user_pass\"":\""password\"",\""user_email\"":\""benten@domain.com\""}"");
                String mess = SimpleCrypto.encrypt(""my s3cr3t k3y"",example.toString());
String decrmess = SimpleCrypto.decrypt(""my s3cr3t k3y"",mess));
//decypts as:{""user_pass"":""password"",""user_email"":""benten@domain.com"",""user_login"":""benten"",""user_lastname"":""
</code></pre>

<p>as you can see only 96 characters are decrypted, theres no user_firstname or the users actual last name, the data is missing, but this number is inconsistent, I changed the user_email to ""benbenten@domain.com"" and the user_firstname to ""benben"" and 112 characters were decrypted...I am completely stumped</p>

<p>EDIT 2: Yngve Ådlandsvik has kindly pointed me in the right direction (many thanks again!) that the string length needed to be a multiple of 16, so I set the Cipher.getInstance in both the encrypt and decrypt methods to:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"",""BC"");
</code></pre>

<p>and in my main activity set a loop to add 0's on the end of my string as custom padding before encrypting:</p>

<pre><code>boolean carryOn = true;
                while(carryOn)
                {
                    int paddedLength = qrMessage.getBytes().length;
                    int checkMultiple16 = paddedLength%16;
                    if(checkMultiple16==0)
                    {
                        carryOn = false;
                    }
                    else
                    qrMessage+=""0"";
                }
</code></pre>

<p>EDIT 3: It looks like QR encoding still screws with the encryption, I can't decrypt the scanned in data properly, looks like QR encoding does something with strings before it encodes to QR which seems to break the thing, guess I'll have to stick to unencrypted text in the QR...</p>
"	NULL	0	NULL	32:06.1	2	20:13.7	20:13.7	NULL	816071	755370	0	1	2	<android><cryptography><aes><encryption>	Android - decryption issues with AES encrypted string in QR code	2983	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6729834	6729947	6	"<p>I'm trying to implement AES in Java and this is the code I use:</p>

<pre><code> byte[] sessionKey = {00000000000000000000000000000000};
 byte[] iv = {00000000000000000000000000000000};
 byte[] plaintext = ""6a84867cd77e12ad07ea1be895c53fa3"".getBytes();
 Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

 cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sessionKey, ""AES""), new IvParameterSpec(iv));
 byte[] ciphertext = cipher.doFinal(plaintext);

 cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(sessionKey, ""AES""), new IvParameterSpec(iv));
 byte[] deciphertext = cipher.doFinal(ciphertext);
</code></pre>

<p>I need this fixed key and IV for test purpose but I get the following exception:</p>

<pre><code>Exception in thread ""main""
java.security.InvalidAlgorithmParameterException: 
  Wrong IV length: must be 16 bytes long    at
com.sun.crypto.provider.SunJCE_h.a(DashoA12275)     at
com.sun.crypto.provider.AESCipher.engineInit(DashoA12275)   at
javax.crypto.Cipher.a(DashoA12275)  at
javax.crypto.Cipher.a(DashoA12275)  at
javax.crypto.Cipher.init(DashoA12275)   at
javax.crypto.Cipher.init(DashoA12275)
</code></pre>

<p>How can I use this fixed IV with this implementation of AES? Is there any way?</p>
"	NULL	1	NULL	30:35.1	8	46:33.2	58:44.1	NULL	648313	849550	0	1	9	<java><aes><initialization-vector>	Need solution for wrong IV length in AES	66580	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6765240	6899330	2	"<p>I have been able to use the algorithm to encrypt and decrypt files , but when I go to try and send a file from Android to a WAS server, it fails. Here is the encrypt side</p>

<pre><code>    Security.addProvider(new BouncyCastleProvider());
    KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
    SecureRandom random = new SecureRandom();
    keygen.init(random);
    SecretKey key = keygen.generateKey();

    // wrap with RSA public key
    ObjectInputStream keyIn = new ObjectInputStream(new FileInputStream (getFileLocation(PUBLIC_KEY, localTest)));
    Key publicKey = (Key) keyIn.readObject();
    keyIn.close();

    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.WRAP_MODE, publicKey);
    byte[] wrappedKey = cipher.wrap(key);
    DataOutputStream out = new DataOutputStream(new FileOutputStream(getFileLocation(SIGN_FILE, localTest)));
    out.writeInt(wrappedKey.length);
    out.write(wrappedKey);

    InputStream in = new ByteArrayInputStream(message.getBytes());
    cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key);
    crypt(in, out, cipher);
    in.close();
    out.close();

    FileInputStream fis = new FileInputStream(getFileLocation(SIGN_FILE, localTest));
    byte[] buffer = new byte[fis.available()];
    int i =0;
    while (i&lt; buffer.length ){
         buffer[i]= (byte)fis.read();
         i++;
    }
    String ss = encodeMsg(buffer);
    return ss;
</code></pre>

<p>Here is the decrypt side</p>

<pre><code>        Security.addProvider(new BouncyCastleProvider());

        byte[] arr = decodeMsg(encrypted);

            DataInputStream in = new DataInputStream(new ByteArrayInputStream(arr));
            int length = in.readInt();
            byte[] wrappedKey = new byte[length];
            in.read(wrappedKey, 0, length);
            // unwrap with RSA private key
            ObjectInputStream keyIn = new ObjectInputStream(new FileInputStream (getFileLocation(PRIVATE_KEY, localTest)));
            Key privateKey = (Key) keyIn.readObject();
            keyIn.close();
            Cipher cipher = Cipher.getInstance(""RSA"");
            cipher.init(Cipher.UNWRAP_MODE, privateKey);
            Key key = cipher.unwrap(wrappedKey, ""AES"", Cipher.SECRET_KEY);

            OutputStream out = new FileOutputStream(getFileLocation(DECRYPTED, localTest));
            cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.DECRYPT_MODE, key);
            crypt(in, out, cipher);
            in.close();
            out.close();

            FileInputStream fis = new FileInputStream(getFileLocation(DECRYPTED, localTest));
            byte[] buffer = new byte[fis.available()];
            int i =0;
            while (i&lt; buffer.length ){//!= 0) {
                 buffer[i]= (byte)fis.read();
                 i++;
            }
            String ss = new String(buffer);
            return ss;
</code></pre>

<p>Again, on my workstation, this works. When doing the mobile request to the WAS web server, it fails. At first, it argued with the object class and so I recreated the keys using Java 1.6.  I have recompiled the war into Java 1.6 as well. It errors as below.</p>

<p>--cipher unwrap </p>

<pre><code>java.security.InvalidKeyException com.ibm.crypto.provider.RSA.engineUnwrap(Unknown Source)
javax.crypto.Cipher.unwrap(Unknown Source)
com.webapp.web.security.RSAEncrypt.decrypt(RSAEncrypt.java:161)
com.webapp.web.MobileRequest.doPost(MobileRequest.java:81)
javax.servlet.http.HttpServlet.service(HttpServlet.java:738)
javax.servlet.http.HttpServlet.service(HttpServlet.java:831)
</code></pre>

<p>...</p>

<p>Does the WAS environment have to be updated to handle this? ideas?
UPDATE the keysize is set to 2048</p>
"	NULL	1	NULL	27:34.8	3	21:13.2	44:02.2	NULL	552782	552782	0	1	2	<java><android><encryption><rsa>	RSA AES decryption fails - InvalidKeyException	3173	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
6813151	6815215	2	"<p>I need a little help here.So basically I have to make a test of AES encryption/decryption of an image in Android.I'm new in android programming and that's why a friend of mine give me an example of how to do it, but the problem is that when I run the sample it crashes after like 20-30 seconds and I'm not really sure what's happening.So can anyone please look at the code and tell me where is the problem.The sample code needs to do this : Encrypt and Decrypt the same image and show me a log with info, how long it takes to encrypt and decrypt the image.Thanks anyway!</p>

<p>Code : </p>

<pre><code>    package com.cryptooo.lol;

import java.io.ByteArrayOutputStream;
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;

public class SimpleCryptoActivity extends Activity {

    @Override
    public void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);


        new Thread() {
            public void run(){
                Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.shit);
                ByteArrayOutputStream baos = new ByteArrayOutputStream();  
                bm.compress(Bitmap.CompressFormat.PNG, 100, baos); // bm is the bitmap object   
                byte[] b = baos.toByteArray();  

                try {
                byte[] keyStart = ""MARTIN_123_MARTIN_123"".getBytes();
                KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
                SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                sr.setSeed(keyStart);
                kgen.init(128, sr); // 192 and 256 bits may not be available
                SecretKey skey = kgen.generateKey();
                byte[] key = skey.getEncoded();    

                // encrypt
                byte[] encryptedData = encrypt(key,b);
                // decrypt
                long start = System.currentTimeMillis()/1000L;
                byte[] decryptedData = decrypt(key,encryptedData);
                long end = System.currentTimeMillis()/1000L;
                android.util.Log.d(""TEST"",""Time ""+ String.valueOf(end-start));
                }
                catch(Exception e){
                    e.fillInStackTrace();
                }
            }

            private byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
                SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                Cipher cipher = Cipher.getInstance(""AES"");
                cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
                byte[] encrypted = cipher.doFinal(clear);
                return encrypted;
            }

            private byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
                SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                Cipher cipher = Cipher.getInstance(""AES"");
                cipher.init(Cipher.DECRYPT_MODE, skeySpec);
                        byte[] decrypted = cipher.doFinal(encrypted);
            return decrypted;
            }
        }.start(); 
    } 

}
</code></pre>

<p>and here is the LogCat : </p>

<pre><code>07-25 09:53:01.243: DEBUG/AndroidRuntime(624): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
07-25 09:53:01.253: DEBUG/AndroidRuntime(624): CheckJNI is ON
07-25 09:53:01.463: DEBUG/AndroidRuntime(624): --- registering native functions ---
07-25 09:53:01.843: DEBUG/ddm-heap(624): Got feature list request
07-25 09:53:02.234: DEBUG/PackageParser(52): Scanning package: /data/app/vmdl26130.tmp
07-25 09:53:02.364: INFO/PackageManager(52): Removing non-system package:com.cryptooo.lol
07-25 09:53:02.373: DEBUG/PackageManager(52): Removing package com.cryptooo.lol
07-25 09:53:02.373: DEBUG/PackageManager(52):   Activities: com.cryptooo.lol.SimpleCryptoActivity
07-25 09:53:02.464: DEBUG/PackageManager(52): Scanning package com.cryptooo.lol
07-25 09:53:02.464: INFO/PackageManager(52): /data/app/vmdl26130.tmp changed; unpacking
07-25 09:53:02.484: DEBUG/installd(32): DexInv: --- BEGIN '/data/app/vmdl26130.tmp' ---
07-25 09:53:02.713: DEBUG/dalvikvm(630): DexOpt: load 44ms, verify 27ms, opt 1ms
07-25 09:53:02.723: DEBUG/installd(32): DexInv: --- END '/data/app/vmdl26130.tmp' (success) ---
07-25 09:53:02.723: DEBUG/PackageManager(52):   Activities: com.cryptooo.lol.SimpleCryptoActivity
07-25 09:53:02.745: DEBUG/ActivityManager(52): Uninstalling process com.cryptooo.lol
07-25 09:53:02.833: INFO/installd(32): move /data/dalvik-cache/data@app@vmdl26130.tmp@classes.dex -&gt; /data/dalvik-cache/data@app@com.cryptooo.lol.apk@classes.dex
07-25 09:53:02.843: DEBUG/PackageManager(52): New package installed in /data/app/com.cryptooo.lol.apk
07-25 09:53:02.973: DEBUG/AndroidRuntime(624): Shutting down VM
07-25 09:53:02.973: DEBUG/dalvikvm(624): DestroyJavaVM waiting for non-daemon threads to exit
07-25 09:53:02.985: DEBUG/dalvikvm(624): DestroyJavaVM shutting VM down
07-25 09:53:02.985: DEBUG/dalvikvm(624): HeapWorker thread shutting down
07-25 09:53:02.985: DEBUG/dalvikvm(624): HeapWorker thread has shut down
07-25 09:53:02.985: DEBUG/jdwp(624): JDWP shutting down net...
07-25 09:53:02.985: INFO/dalvikvm(624): Debugger has detached; object registry had 1 entries
07-25 09:53:02.985: DEBUG/dalvikvm(624): VM cleaning up
07-25 09:53:03.004: DEBUG/ActivityManager(52): Uninstalling process com.cryptooo.lol
07-25 09:53:03.024: DEBUG/dalvikvm(624): LinearAlloc 0x0 used 623916 of 5242880 (11%)
07-25 09:53:03.024: ERROR/AndroidRuntime(624): ERROR: thread attach failed
07-25 09:53:03.223: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f0700e5
07-25 09:53:03.235: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f020031
07-25 09:53:03.235: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f020030
07-25 09:53:03.235: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f050000
07-25 09:53:03.284: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f060000
07-25 09:53:03.284: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f060001
07-25 09:53:03.473: DEBUG/dalvikvm(98): GC freed 149 objects / 7384 bytes in 244ms
07-25 09:53:03.583: WARN/dalvikvm(52): threadid=15: spin on suspend #0 threadid=21 (h=1324960)
07-25 09:53:03.593: WARN/dalvikvm(52): dumping state: process - 52
07-25 09:53:03.593: INFO/dalvikvm(52): ""android.server.ServerThread"" prio=5 tid=15 RUNNABLE
07-25 09:53:03.593: INFO/dalvikvm(52):   | group=""main"" sCount=0 dsCount=0 s=N obj=0x44c017e0 self=0x147d30
07-25 09:53:03.593: INFO/dalvikvm(52):   | sysTid=61 nice=-2 sched=0/0 cgrp=default handle=1306264
07-25 09:53:03.593: INFO/dalvikvm(52):   at java.lang.Runtime.gc(Native Method)
07-25 09:53:03.593: INFO/dalvikvm(52):   at com.android.internal.os.BinderInternal.forceGc(BinderInternal.java:83)
07-25 09:53:03.593: INFO/dalvikvm(52):   at android.app.ActivityThread.doGcIfNeeded(ActivityThread.java:2296)
07-25 09:53:03.593: INFO/dalvikvm(52):   at android.app.ActivityThread$GcIdler.queueIdle(ActivityThread.java:2010)
07-25 09:53:03.593: INFO/dalvikvm(52):   at android.os.MessageQueue.next(MessageQueue.java:116)
07-25 09:53:03.593: INFO/dalvikvm(52):   at android.os.Looper.loop(Looper.java:110)
07-25 09:53:03.593: INFO/dalvikvm(52):   at com.android.server.ServerThread.run(SystemServer.java:428)
07-25 09:53:03.605: INFO/dalvikvm(52): ""PackageManager"" prio=5 tid=21 RUNNABLE
07-25 09:53:03.605: INFO/dalvikvm(52):   | group=""main"" sCount=1 dsCount=0 s=N obj=0x44c37b10 self=0x11fb40
07-25 09:53:03.605: INFO/dalvikvm(52):   | sysTid=67 nice=10 sched=0/0 cgrp=bg_non_interactive handle=1324960
07-25 09:53:03.695: INFO/dalvikvm(52):   at com.android.server.am.ActivityManagerService.broadcastIntent(ActivityManagerService.java:~12017)
07-25 09:53:03.695: INFO/dalvikvm(52):   at com.android.server.PackageManagerService.sendPackageBroadcast(PackageManagerService.java:3662)
07-25 09:53:03.695: INFO/dalvikvm(52):   at com.android.server.PackageManagerService.access$1400(PackageManagerService.java:109)
07-25 09:53:03.695: INFO/dalvikvm(52):   at com.android.server.PackageManagerService$PackageRemovedInfo.sendBroadcast(PackageManagerService.java:4533)
07-25 09:53:03.695: INFO/dalvikvm(52):   at com.android.server.PackageManagerService$5.run(PackageManagerService.java:3792)
07-25 09:53:03.695: INFO/dalvikvm(52):   at android.os.Handler.handleCallback(Handler.java:587)
07-25 09:53:03.695: INFO/dalvikvm(52):   at android.os.Handler.dispatchMessage(Handler.java:92)
07-25 09:53:03.695: INFO/dalvikvm(52):   at android.os.Looper.loop(Looper.java:123)
07-25 09:53:03.695: INFO/dalvikvm(52):   at android.os.HandlerThread.run(HandlerThread.java:60)
07-25 09:53:03.714: WARN/dalvikvm(52): threadid=15: spin on suspend resolved in 373 msec
07-25 09:53:03.984: DEBUG/dalvikvm(52): GC freed 22016 objects / 1235352 bytes in 643ms
07-25 09:53:04.064: DEBUG/AndroidRuntime(635): &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
07-25 09:53:04.083: DEBUG/AndroidRuntime(635): CheckJNI is ON
07-25 09:53:04.404: DEBUG/AndroidRuntime(635): --- registering native functions ---
07-25 09:53:04.905: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f0700e5
07-25 09:53:04.905: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f020031
07-25 09:53:04.905: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f020030
07-25 09:53:04.905: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f050000
07-25 09:53:05.013: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f060000
07-25 09:53:05.034: WARN/ResourceType(52): Resources don't contain package for resource number 0x7f060001
07-25 09:53:05.064: DEBUG/ddm-heap(635): Got feature list request
07-25 09:53:05.824: DEBUG/dalvikvm(52): GC freed 4805 objects / 259312 bytes in 480ms
07-25 09:53:05.933: DEBUG/ActivityManager(52): Uninstalling process com.cryptooo.lol
07-25 09:53:05.933: INFO/ActivityManager(52): Starting activity: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.cryptooo.lol/.SimpleCryptoActivity }
07-25 09:53:05.984: DEBUG/AndroidRuntime(635): Shutting down VM
07-25 09:53:05.984: DEBUG/dalvikvm(635): DestroyJavaVM waiting for non-daemon threads to exit
07-25 09:53:05.993: DEBUG/dalvikvm(635): DestroyJavaVM shutting VM down
07-25 09:53:05.993: DEBUG/dalvikvm(635): HeapWorker thread shutting down
07-25 09:53:06.003: DEBUG/dalvikvm(635): HeapWorker thread has shut down
07-25 09:53:06.003: DEBUG/jdwp(635): JDWP shutting down net...
07-25 09:53:06.003: INFO/dalvikvm(635): Debugger has detached; object registry had 1 entries
07-25 09:53:06.003: DEBUG/dalvikvm(635): VM cleaning up
07-25 09:53:06.043: DEBUG/dalvikvm(635): LinearAlloc 0x0 used 639500 of 5242880 (12%)
07-25 09:53:06.074: ERROR/AndroidRuntime(635): ERROR: thread attach failed
07-25 09:53:06.114: INFO/ActivityManager(52): Start proc com.cryptooo.lol for activity com.cryptooo.lol/.SimpleCryptoActivity: pid=643 uid=10038 gids={}
07-25 09:53:06.344: DEBUG/ddm-heap(643): Got feature list request
07-25 09:53:06.484: WARN/ActivityThread(643): Application com.cryptooo.lol is waiting for the debugger on port 8100...
07-25 09:53:06.513: INFO/System.out(643): Sending WAIT chunk
07-25 09:53:06.584: INFO/dalvikvm(643): Debugger is active
07-25 09:53:06.723: INFO/System.out(643): Debugger has connected
07-25 09:53:06.723: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:06.924: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:07.133: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:07.333: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:07.533: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:07.574: DEBUG/dalvikvm(119): GC freed 10191 objects / 487632 bytes in 4140ms
07-25 09:53:07.734: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:07.937: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:08.204: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:08.414: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:08.644: INFO/System.out(643): waiting for debugger to settle...
07-25 09:53:08.854: INFO/System.out(643): debugger has settled (1465)
07-25 09:53:09.053: ERROR/gralloc(52): [unregister] handle 0x1338a8 still locked (state=40000001)
07-25 09:53:09.473: DEBUG/dalvikvm(643): GC freed 650 objects / 52080 bytes in 159ms
07-25 09:53:09.993: INFO/ActivityManager(52): Displayed activity com.cryptooo.lol/.SimpleCryptoActivity: 4007 ms (total 4007 ms)
07-25 09:53:13.174: DEBUG/dalvikvm(643): GC freed 73 objects / 93640 bytes in 73ms
07-25 09:53:18.924: DEBUG/dalvikvm(264): GC freed 43 objects / 2024 bytes in 3859ms
07-25 09:53:21.714: DEBUG/dalvikvm(98): GC freed 2725 objects / 159280 bytes in 1649ms
07-25 09:53:22.123: DEBUG/dalvikvm(643): GC freed 126 objects / 900328 bytes in 69ms
07-25 09:53:22.154: INFO/dalvikvm-heap(643): Grow heap (frag case) to 12.648MB for 2092136-byte allocation
07-25 09:53:22.335: DEBUG/dalvikvm(643): GC freed 41 objects / 1592 bytes in 176ms
07-25 09:53:30.224: DEBUG/dalvikvm(643): GC freed 3 objects / 1042080 bytes in 70ms
07-25 09:53:30.294: INFO/dalvikvm-heap(643): Grow heap (frag case) to 15.651MB for 4192360-byte allocation
07-25 09:53:30.474: DEBUG/dalvikvm(643): GC freed 0 objects / 0 bytes in 172ms
07-25 09:53:36.184: DEBUG/dalvikvm(643): GC freed 4 objects / 2096320 bytes in 75ms
07-25 09:53:36.214: INFO/dalvikvm-heap(643): Grow heap (frag case) to 16.091MB for 2557851-byte allocation
07-25 09:53:36.413: DEBUG/dalvikvm(643): GC freed 0 objects / 0 bytes in 200ms
07-25 09:53:36.543: DEBUG/dalvikvm(643): GC freed 54 objects / 2936 bytes in 73ms
07-25 09:53:36.583: INFO/dalvikvm-heap(643): Grow heap (frag case) to 18.537MB for 2557856-byte allocation
07-25 09:53:36.766: DEBUG/dalvikvm(643): GC freed 0 objects / 0 bytes in 180ms
</code></pre>
"	NULL	5	NULL	56:18.3	4	16:24.7	54:37.5	NULL	1511776	1511776	0	1	4	<android><encryption><aes>	Android encryption/decryption issue (AES)	4049	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
7094777	0	2	"<p>We have code for AES-128 encryption in Java and we want some equivalent code in WP7.</p>

<p>However, we run into a problem: The two implementations yield different encrypted texts</p>

<p>Here is the code we're using:</p>

<p><strong>Java Code</strong></p>

<pre><code>package com.emap.services;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AESEcrypt1 {

    static byte[] ibv = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};

    public String encryptData() {
        String message = ""Testing AES encryption-decryption amlgorithm for WP7."";
        String encryptedStr = """";
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(""Passkey"".getBytes(), ""AES"");
            IvParameterSpec iv = new IvParameterSpec(ibv);
            // Instantiate the cipher
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
            byte[] encrypted = cipher.doFinal(message.getBytes());
            encryptedStr = Base64.encode(encrypted);
        } catch (BadPaddingException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (IllegalBlockSizeException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (InvalidAlgorithmParameterException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (InvalidKeyException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (NoSuchAlgorithmException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (NoSuchPaddingException ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        } catch (Exception ex) {
            System.out.println(""Error: "" + ex.getMessage());
            encryptedStr = ""error"";
        }
        System.out.println(""Encrypted: "" + encryptedStr);
        return encryptedStr;
    }
}
</code></pre>

<p><strong>WP7 Code</strong></p>

<pre><code>static byte[] ibv = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};

public string Encrypt(string dataToEncrypt, string password)
//public string Encrypt(string dataToEncrypt)  
{
    AesManaged aes = null;
    MemoryStream memStream = null;
    CryptoStream crStream = null;
    try
    {
        //Generate a Key based on a Password and Salt      
        //Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes(password, Encoding.UTF8.GetBytes(salt));
        Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes(password, ibv);                
        aes = new AesManaged();
        aes.Key = rfc2898.GetBytes(aes.KeySize / 8);
        aes.IV = rfc2898.GetBytes(aes.BlockSize / 8);
        memStream = new MemoryStream();
        crStream = new CryptoStream(memStream, aes.CreateEncryptor(), CryptoStreamMode.Write);
        byte[] data = Encoding.UTF8.GetBytes(dataToEncrypt);
        crStream.Write(data, 0, data.Length);
        crStream.FlushFinalBlock();

        //Return Base 64 String                
        return Convert.ToBase64String(memStream.ToArray());
    }
    finally
    {
        //cleanup                
        if (crStream != null)
            crStream.Close();
        if (memStream != null)
            memStream.Close();
        if (aes != null)
            aes.Clear();
     }
}
</code></pre>

<p>Any help would be greatly appreciated.</p>
"	NULL	4	NULL	46:18.7	2	53:26.0	23:30.1	NULL	82682	772832	0	1	0	<c#><java><.net><windows-phone-7><encryption>	AES Encryption with java and WP7	1077	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
7108402	0	1	"<p>We have implemented Deflate Compression and AES-128 Encryption in both java and WP7.</p>

<p>When Compression and encryption was implemented as seprate modules they were providing same output on both the platforms.</p>

<p>Later we tried to integrate both modules(ie. input String is compressed first, then compressed string is encrypted), After this integration we are not getting same output on both platforms.</p>

<p>Code is given below</p>

<p>String we are using as input is :   ""Testing compression(Deflate Algorothjm), encrption(AES algorithm) for WP7.""</p>

<p>output for Java : ""iJSblymVMAD94KdHSrLt1xLC3lioNc4mNtk4kobuk+qkBEiV4x9Em7ShPxdtXO1EKLjepZVcEvtzCTsmwc5/uGzr4yscgLOvsYvBL8Ku0FM=""</p>

<p>output from WP7 :  ""muMPnBPUG6Ad+zolHtE7Mi9YWTgmm9dOtTWTtZP19oRucf0I02MiHdwIs488y33EGaaZJjQhd3ymaEDOR+HvVb9quQvRu7nkJwXW3uyZEcI=""</p>

<p><strong>Java Integrated Code</strong></p>

<pre><code>package com.emap.services;

import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.zip.Deflater;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class CompressEncrypt {
    static byte[] ibv = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};

    public String compressEncryptData() {

        String strData = ""Testing compression(Deflate Algorothjm), encrption(AES algorithm) for WP7."";
        byte[] inputData = strData.getBytes();
        // supporting maximum 10 MB of data
        byte[] outputData = new byte[1024 * 1024 * 10];
        // initiate compressor instance
        Deflater compresser = new Deflater();
        // compressed base64 encoded string

        byte [] compressedByte = null;

        int compressedDataLength = 0;
        //Encrypted String
        String encryptedStr = """";

        try {
            compresser.setInput(inputData, 0, inputData.length);
            compresser.finish();
            compressedDataLength = compresser.deflate(outputData);
            compressedByte = Arrays.copyOfRange(outputData, 0, compressedDataLength);
            System.out.println(""Compressed String is : "" + compressedByte.toString());
        } catch (Exception ex) {
            System.out.println(""Error : "" + ex.getMessage());
        }

        try {
            SecretKeySpec skeySpec = new SecretKeySpec(""E2D5@eMap_AndIBB"".getBytes(), ""AES"");

            IvParameterSpec iv = new IvParameterSpec(ibv);
            // Instantiate the cipher
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(compressedByte);
            System.out.println(""Encrypted String is : "" + encrypted.toString());
            encryptedStr = Base64.encode(encrypted);
        }  catch (Exception ex) {
            System.out.println(""No Such Padding Error: "" + ex.getMessage());
            encryptedStr = ""No Such Padding Error: "" + ex.getMessage();
        }
        System.out.println(""Compressed Encrypted Encoded String is : "" + encryptedStr);
        return encryptedStr;
    }
}
</code></pre>

<p><strong>WP7 Integrated Code</strong></p>

<pre><code>using System;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using System.IO;
using ICSharpCode.SharpZipLib.Zip;
using ICSharpCode.SharpZipLib.Zip.Compression;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System.Text;
using System.Security;
using System.Security.Cryptography;


namespace CompressEncrypt
{
    public class Code
    {
        static byte[] ibv = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};
        //public string CompressEncode(string strOrigianl)
        public string CompressEncode(string strOrigianl)
        {
            MemoryStream memoryStream = new MemoryStream();
            byte[] getBytes = System.Text.Encoding.UTF8.GetBytes(strOrigianl);

            memoryStream = Deflate(getBytes);
            byte[] objByte = new byte[memoryStream.Length];
            memoryStream.Read(objByte, 0, (int)(memoryStream.Length));
            string strResult = Convert.ToBase64String(memoryStream.ToArray());

            strResult = Encrypt(memoryStream.ToArray(), ""E2D5@eMap_AndIBB"");
            return strResult;
        }

        MemoryStream Deflate(byte[] data)
        {
            MemoryStream memoryStream = new MemoryStream();
            {
                Deflater deflater = new Deflater();
                using (DeflaterOutputStream outStream = new DeflaterOutputStream(memoryStream, deflater))
                {
                    outStream.IsStreamOwner = false;
                    outStream.Write(data, 0, data.Length);
                    outStream.Flush();
                    outStream.Finish();

                }
                return memoryStream;
            }
        }

        //********************Encryption*************************************
        public string Encrypt(byte[] data, string password)
        {
            AesManaged aes = null;
            MemoryStream memStream = null;
            CryptoStream crStream = null;
            try
            {

                aes = new AesManaged();
                aes.Key = Encoding.UTF8.GetBytes(password);

                aes.IV = ibv;
                memStream = new MemoryStream();
                crStream = new CryptoStream(memStream, aes.CreateEncryptor(), CryptoStreamMode.Write);
                //byte[] data = Encoding.UTF8.GetBytes(dataToEncrypt);
                crStream.Write(data, 0, data.Length);
                crStream.FlushFinalBlock();
                //Return Base 64 String                       
                return Convert.ToBase64String(memStream.ToArray());
            }
            finally
            {
                //cleanup      
                if (crStream != null)
                    crStream.Close();
                if (memStream != null)
                    memStream.Close();
                if (aes != null)
                    aes.Clear();
            }
        }

    }
}
</code></pre>

<p>Thanks and Regards
Mohit Leekha</p>

<hr>

<p>As i already Said Seprate Encryption and Compression are Providing same output on both modules.</p>

<p>What i found till now is:</p>

<p>Using ""Testing compression(Deflate Algorothjm), encrption(AES algorithm) for WP7."" as input string</p>

<p><strong>Compression</strong>
we converted the string in bytes using 
byte[] inputData = strData.getBytes(); 
than compressed these bytes(inputData) using deflater(compressor) we get compressed bytes, after we converted compressd bytes to strin using base64</p>

<p>but in case of WP7 Deflator provide Stream, not bytes
Still when we get the same out put on both platforms.</p>

<p><strong>Encryption</strong>
Same 3 steps(1. conversion to bytes, 2. Encryption 3. conversion to string using base64) we followed for encryption and get same output from both platforms</p>

<p><strong>Integration</strong>
Problem starts here
In java code we converted input string to bytes, compressed it.
The Compresser provided Byte Araay , Which is directly passed to Encryption Module
ie. skipped 3rd step of compression(conversion of compressed bytes to base64 string) and first step of encryption(conversion of srting to bytes)</p>

<p>When we did this in WP7 we got a stream from the compressor, we converted it to byte array and passed to encryption module, here the output we are getting is different.</p>

<p>Problem with me is my java code is finalized and cannot be altered.</p>

<p>i have a</p>

<p>thanks</p>
"	NULL	0	NULL	44:19.8	2	08:35.7	08:35.7	NULL	419	772832	0	1	0	<c#><java><.net><windows-phone-7><encryption>	Compression and Encryption in java and Wp7 mismatch	705	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
7166275	7171899	1	"<p>I'm attempting to write a web app that uses AES encryption over AJAX to interact with a Java backend.</p>

<p>I've spent some time looking for and testing libraries and none of them have proven fruitful.</p>

<p>I have Java &lt;-> PHP working correctly with the following Java code:</p>

<pre><code>public static String encrypt(String input, String key){
    IvParameterSpec ips = new IvParameterSpec(""sixteenbyteslong"".getBytes());
    try {
        key = md5(key);
    } catch (NoSuchAlgorithmException e1) {
        e1.printStackTrace();
    }
    byte[] crypted = null;
    try{
        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skey, ips);
        crypted = cipher.doFinal(input.getBytes());
    }catch(Exception e){
        System.out.println(e.toString());
    }
    return new String(Base64.encodeBase64(crypted));
}

public static String decrypt(String input, String key){
    IvParameterSpec ips = new IvParameterSpec(""sixteenbyteslong"".getBytes());
    try {
        key = md5(key);
    } catch (NoSuchAlgorithmException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }
    byte[] output = null;
    try{
        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skey,ips);
        output = cipher.doFinal(Base64.decodeBase64(input));
    }catch(Exception e){
        System.out.println(e.toString());
    }
    return new String(output);
}
</code></pre>

<p>Base64 is <code>org.apache.commons.codec.binary.Base64</code>.</p>

<p>I tried SlowAES, but it didn't support ""PKCS5Padding"", but even if this was present the actual encryption may not have been working.</p>
"	NULL	3	NULL	12:39.6	2	17:43.0	17:43.0	NULL	472495	661464	0	1	2	<java><javascript><aes>	Javascript <-> Java AES	5322	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
7615743	7615936	3	"<p>What are some of the simplest ways to AES encrypt and decrypt a 16 byte array without the automatic padding? I have found solutions that use external libraries, but I want to avoid that if possible.</p>

<p>My current code is</p>

<pre><code>SecretKeySpec skeySpec = new SecretKeySpec(getCryptoKeyByteArray(length=16)); // 128 bits
Cipher encryptor = Cipher.getInstance(""AES"");
encryptor.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] encrypted = encryptor.doFinal(plain);
</code></pre>

<p>How can I prevent the padding? The <code>plain</code> data is always fixed length and includes its own padding. How can I allow <code>plain</code> to be 16 bytes without causing <code>encrypted</code> to become 32 bytes?</p>
"	NULL	5	NULL	28:39.1	7	38:03.6	33:49.8	NULL	820127	463304	0	1	14	<java><encryption><aes><padding>	Java AES without padding	49879	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8049872	8053459	6	"<p>I am trying to implement password based encryption algorithm, but I get this exception:</p>

<blockquote>
  <p>javax.crypto.BadPaddingException: Given final block not properly padded</p>
</blockquote>

<p>What might be the problem?</p>

<p>Here is my code:</p>

<pre><code>public class PasswordCrypter {

    private Key key;

    public PasswordCrypter(String password)  {
        try{
            KeyGenerator generator;
            generator = KeyGenerator.getInstance(""DES"");
            SecureRandom sec = new SecureRandom(password.getBytes());
            generator.init(sec);
            key = generator.generateKey();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    public byte[] encrypt(byte[] array) throws CrypterException {
        try{
            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key);

            return cipher.doFinal(array);
        } catch (Exception e) { 
            e.printStackTrace();
        }
        return null;
    }

    public byte[] decrypt(byte[] array) throws CrypterException{
        try{
            Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key);

            return cipher.doFinal(array);
        } catch(Exception e ){
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>(The JUnit Test)</p>

<pre><code>public class PasswordCrypterTest {

    private static final byte[] MESSAGE = ""Alpacas are awesome!"".getBytes();
    private PasswordCrypter[] passwordCrypters;
    private byte[][] encryptedMessages;

    @Before
    public void setUp() {
        passwordCrypters = new PasswordCrypter[] {
            new PasswordCrypter(""passwd""),
            new PasswordCrypter(""passwd""),
            new PasswordCrypter(""otherPasswd"")
        };

        encryptedMessages = new byte[passwordCrypters.length][];
        for (int i = 0; i &lt; passwordCrypters.length; i++) {
            encryptedMessages[i] = passwordCrypters[i].encrypt(MESSAGE);
        }
    }

    @Test
    public void testEncrypt() {
        for (byte[] encryptedMessage : encryptedMessages) {
            assertFalse(Arrays.equals(MESSAGE, encryptedMessage));
        }

        assertFalse(Arrays.equals(encryptedMessages[0], encryptedMessages[2]));
        assertFalse(Arrays.equals(encryptedMessages[1], encryptedMessages[2]));
    }

    @Test
    public void testDecrypt() {
        for (int i = 0; i &lt; passwordCrypters.length; i++) {
            assertArrayEquals(MESSAGE, passwordCrypters[i].decrypt(encryptedMessages[i]));
        }

        assertArrayEquals(MESSAGE, passwordCrypters[0].decrypt(encryptedMessages[1]));
        assertArrayEquals(MESSAGE, passwordCrypters[1].decrypt(encryptedMessages[0]));

        try {
            assertFalse(Arrays.equals(MESSAGE, passwordCrypters[0].decrypt(encryptedMessages[2])));
        } catch (CrypterException e) {
            // Anything goes as long as the above statement is not true.
        }

        try {
            assertFalse(Arrays.equals(MESSAGE, passwordCrypters[2].decrypt(encryptedMessages[1])));
        } catch (CrypterException e) {
            // Anything goes as long as the above statement is not true.
        }
    }
}
</code></pre>
"	NULL	0	NULL	45:38.7	28	12:02.4	26:58.3	NULL	1788806	659417	0	1	138	<java><exception><encryption><cryptography><javax.crypto>	Given final block not properly padded	393551	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8141959	8142733	1	"<p>I have the following test code to encrypt and decrypt a string. It works fine if I leave out the wrapping and unwrapping code for my key in test(), but when I try to wrap my key, and then unwrap it again and use it for the decryption, it fails and I don't get ""Test"" back as the resulting decrypted string but ""?J??"" instead.</p>

<p>Does anybody see the error I'm doing with the wrapping and unwrapping? Thanks.</p>

<pre><code>private static void test() throws Exception {

    // create wrap key
    KeyGenerator keyGenerator = KeyGenerator.getInstance(""AESWrap"");
    keyGenerator.init(256);
    Key wrapKey = keyGenerator.generateKey();

    SecretKey key = generateKey(PASSPHRASE);
    Cipher cipher;

    // wrap key
    cipher = Cipher.getInstance(""AESWrap"");
    cipher.init(Cipher.WRAP_MODE, wrapKey);
    byte[] wrappedKeyBytes = cipher.wrap(key);

    // unwrap key again
    cipher.init(Cipher.UNWRAP_MODE, wrapKey);
    key = (SecretKey)cipher.unwrap( wrappedKeyBytes, ""AES/CTR/NOPADDING"", Cipher.SECRET_KEY);

    // encrypt
    cipher = Cipher.getInstance(""AES/CTR/NOPADDING"");
    cipher.init(Cipher.ENCRYPT_MODE, key, generateIV(cipher), random);
    byte[] b = cipher.doFinal(""Test"".toString().getBytes());

    // decrypt
    cipher = Cipher.getInstance(""AES/CTR/NOPADDING"");
    cipher.init(Cipher.DECRYPT_MODE, key, generateIV(cipher), random);
    b = cipher.doFinal(b);

    System.out.println(new String(b));  
    // should output ""Test"", but outputs ?J?? if wrapping/unwrapping

}
</code></pre>

<p>And the two helper methods that are called in the code above:</p>

<pre><code>private static IvParameterSpec generateIV(Cipher cipher) throws Exception {
    byte [] ivBytes = new byte[cipher.getBlockSize()];
    random.nextBytes(ivBytes);    // random = new SecureRandom();
    return new IvParameterSpec(ivBytes);
}

private static SecretKey generateKey(String passphrase) throws Exception {
    PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(), salt.getBytes(), iterations, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBE_ALGORITHM); //""PBEWITHSHA256AND256BITAES-CBC-BC""
    return keyFactory.generateSecret(keySpec);
}
</code></pre>
"	NULL	0	NULL	26:23.4	5	28:49.7	NULL	NULL	0	241475	0	1	1	<java><bouncycastle><encryption><encryption-symmetric>	Wrapping and unwrapping encryption key fails (javax.crypto)	6693	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8622367	8683672	5	"<p><strong>Why I ask this question:</strong></p>

<p>I know there have been a lot of questions about AES encryption, even for Android. And there are lots of code snippets if you search the Web. But on every single page, in every Stack Overflow question, I find another implementation with major differences.</p>

<p>So I created this question to find a ""best practice"". I hope we can collect a list of the most important requirements and set up an implementation that is really secure!</p>

<p>I read about initialization vectors and salts. Not all implementations I found had these features. So do you need it? Does it increase the security a lot? How do you implement it? Should the algorithm raise exceptions if the encrypted data cannot be decrypted? Or is that insecure and it should just return an unreadable string? Can the algorithm use Bcrypt instead of SHA?</p>

<p>What about these two implementations I found? Are they okay? Perfect or some important things missing? What of these is secure?</p>

<p>The algorithm should take a string and a ""password"" for encryption and then encrypt the string with that password. The output should be a string (hex or base64?) again. Decryption should be possible as well, of course.</p>

<p><strong>What is the perfect AES implementation for Android?</strong></p>

<p><strong>Implementation #1:</strong></p>

<pre><code>import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class AdvancedCrypto implements ICrypto {

        public static final String PROVIDER = ""BC"";
        public static final int SALT_LENGTH = 20;
        public static final int IV_LENGTH = 16;
        public static final int PBE_ITERATION_COUNT = 100;

        private static final String RANDOM_ALGORITHM = ""SHA1PRNG"";
        private static final String HASH_ALGORITHM = ""SHA-512"";
        private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";
        private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";
        private static final String SECRET_KEY_ALGORITHM = ""AES"";

        public String encrypt(SecretKey secret, String cleartext) throws CryptoException {
                try {

                        byte[] iv = generateIv();
                        String ivHex = HexEncoder.toHex(iv);
                        IvParameterSpec ivspec = new IvParameterSpec(iv);

                        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);
                        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);
                        byte[] encryptedText = encryptionCipher.doFinal(cleartext.getBytes(""UTF-8""));
                        String encryptedHex = HexEncoder.toHex(encryptedText);

                        return ivHex + encryptedHex;

                } catch (Exception e) {
                        throw new CryptoException(""Unable to encrypt"", e);
                }
        }

        public String decrypt(SecretKey secret, String encrypted) throws CryptoException {
                try {
                        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);
                        String ivHex = encrypted.substring(0, IV_LENGTH * 2);
                        String encryptedHex = encrypted.substring(IV_LENGTH * 2);
                        IvParameterSpec ivspec = new IvParameterSpec(HexEncoder.toByte(ivHex));
                        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);
                        byte[] decryptedText = decryptionCipher.doFinal(HexEncoder.toByte(encryptedHex));
                        String decrypted = new String(decryptedText, ""UTF-8"");
                        return decrypted;
                } catch (Exception e) {
                        throw new CryptoException(""Unable to decrypt"", e);
                }
        }

        public SecretKey getSecretKey(String password, String salt) throws CryptoException {
                try {
                        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), HexEncoder.toByte(salt), PBE_ITERATION_COUNT, 256);
                        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM, PROVIDER);
                        SecretKey tmp = factory.generateSecret(pbeKeySpec);
                        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), SECRET_KEY_ALGORITHM);
                        return secret;
                } catch (Exception e) {
                        throw new CryptoException(""Unable to get secret key"", e);
                }
        }

        public String getHash(String password, String salt) throws CryptoException {
                try {
                        String input = password + salt;
                        MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM, PROVIDER);
                        byte[] out = md.digest(input.getBytes(""UTF-8""));
                        return HexEncoder.toHex(out);
                } catch (Exception e) {
                        throw new CryptoException(""Unable to get hash"", e);
                }
        }

        public String generateSalt() throws CryptoException {
                try {
                        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
                        byte[] salt = new byte[SALT_LENGTH];
                        random.nextBytes(salt);
                        String saltHex = HexEncoder.toHex(salt);
                        return saltHex;
                } catch (Exception e) {
                        throw new CryptoException(""Unable to generate salt"", e);
                }
        }

        private byte[] generateIv() throws NoSuchAlgorithmException, NoSuchProviderException {
                SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
                byte[] iv = new byte[IV_LENGTH];
                random.nextBytes(iv);
                return iv;
        }

}
</code></pre>

<p>Source: <a href=""http://pocket-for-android.1047292.n5.nabble.com/Encryption-method-and-reading-the-Dropbox-backup-td4344194.html"" rel=""noreferrer"">http://pocket-for-android.1047292.n5.nabble.com/Encryption-method-and-reading-the-Dropbox-backup-td4344194.html</a></p>

<p><strong>Implementation #2:</strong></p>

<pre><code>import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * Usage:
 * &lt;pre&gt;
 * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)
 * ...
 * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)
 * &lt;/pre&gt;
 * @author ferenc.hechler
 */
public class SimpleCrypto {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
    }

}
</code></pre>

<p>Source: <a href=""http://www.tutorials-android.com/learn/How_to_encrypt_and_decrypt_strings.rhtml"" rel=""noreferrer"">http://www.tutorials-android.com/learn/How_to_encrypt_and_decrypt_strings.rhtml</a></p>
"	NULL	9	NULL	50:35.6	74	08:19.7	24:12.9	NULL	815724	89818	0	1	90	<android><encryption><aes>	What are best practices for using AES encryption in Android?	45977	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8763597	8791701	3	"<p>I am trying to encrypt in C++ using CryptoAPI and decrypt Java using SunJCE.  I have gotten the RSA key to work -- and verified on a test string.  However, my AES key is not working -- I get <code>javax.crypto.BadPaddingException: Given final block not properly padded</code>.</p>

<p>C++ Encryption:</p>

<pre><code>// init and gen key
HCRYPTPROV provider;
CryptAcquireContext(&amp;provider, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);

// Use symmetric key encryption
HCRYPTKEY sessionKey;
DWORD exportKeyLen;
CryptGenKey(provider, CALG_AES_128, CRYPT_EXPORTABLE, &amp;sessionKey);

// Export key
BYTE exportKey[1024];
CryptExportKey(sessionKey, NULL, PLAINTEXTKEYBLOB, 0, exportKey, &amp;exportKeyLen);

// skip PLAINTEXTKEYBLOB header
//      { uint8_t bType, uint8_t version, uint16_t reserved, uint32_t aiKey, uint32_t keySize }
DWORD keySize =  *((DWORD*)(exportKey + 8));
BYTE * rawKey = exportKey + 12;

// reverse bytes for java
for (unsigned i=0; i&lt;keySize/2; i++) {
    BYTE temp = rawKey[i];
    rawKey[i] = rawKey[keySize-i-1];
    rawKey[keySize-i-1] = temp;
}

// Encrypt message
BYTE encryptedMessage[1024];
const char * message = ""Decryption Works"";
BYTE messageLen = (BYTE)strlen(message);
memcpy(encryptedMessage, message, messageLen);
DWORD encryptedMessageLen = messageLen;
CryptEncrypt(sessionKey, NULL, TRUE, 0, encryptedMessage, &amp;encryptedMessageLen, sizeof(encryptedMessage));

// reverse bytes for java
for (unsigned i=0; i&lt;encryptedMessageLen/2; i++) {
    BYTE temp = encryptedMessage[i];
    encryptedMessage[i] = encryptedMessage[encryptedMessageLen - i - 1];
    encryptedMessage[encryptedMessageLen - i - 1] = temp;
}

BYTE byteEncryptedMessageLen = (BYTE)encryptedMessageLen;
FILE * f = fopen(""test.aes"", ""wb"");
fwrite(rawKey, 1, keySize, f);
fwrite(&amp;byteEncryptedMessageLen, 1, sizeof(byteEncryptedMessageLen), f);
fwrite(encryptedMessage, 1, encryptedMessageLen, f);
fclose(f);

// destroy session key
CryptDestroyKey(sessionKey);
CryptReleaseContext(provider, 0);
</code></pre>

<p>Java Decryption:</p>

<pre><code>try
{
    FileInputStream in = new FileInputStream(""test.aes"");
    DataInputStream dataIn = new DataInputStream(in);

    // stream key and message
    byte[] rawKey = new byte[16];
    dataIn.read(rawKey);
    byte encryptedMessageLen = dataIn.readByte();
    byte[] encryptedMessage = new byte[encryptedMessageLen];
    dataIn.read(encryptedMessage);

    // use CBC/PKCS5PADDING, with 0 IV -- default for Microsoft Base Cryptographic Provider
    SecretKeySpec sessionKey = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    cipher.init(Cipher.DECRYPT_MODE, sessionKey, new IvParameterSpec(new byte[16]));

    cipher.doFinal(encryptedMessage);
}
catch (Exception e) {
  e.printStackTrace();
}
</code></pre>

<p>In a similar example I have tried permutations of not reversing the bytes of the key and not reversing bytes in the message.  If I encrypt and decrypt with the imported key in java, I get valid results.  I can also encrypt and decrypt exclusively in C++.</p>

<p>Questions:</p>

<ol>
<li>Should I use CBC/PKCS5PADDING?  Is this the default for <code>MS_ENH_RSA_AES_PROV</code>?</li>
<li>Is a zeroed IV indeed the default for <code>MS_ENH_RSA_AES_PROV</code>?</li>
<li>Are there any ways to diagnose the specifics of how the key is behaving?</li>
<li>I'd like to stick with standard Java packages instead of installing BouncyCastle, but are there any differences that would make a 3rd party package work better?</li>
</ol>
"	NULL	2	NULL	50:25.6	3	38:10.6	NULL	NULL	0	1113528	0	1	1	<java><interop><cryptography><aes><cryptoapi>	CryptoAPI C++ interop with Java using AES	6297	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8767593	8770003	1	"<p>Ok, I'm using the following AES JavaScript library:</p>

<p><a href=""http://www.movable-type.co.uk/scripts/aes.html"" rel=""nofollow"">http://www.movable-type.co.uk/scripts/aes.html</a></p>

<p>I'm trying to write Java that can decrypt the resulting packaged that was encrypted by JavaScript, but I keep doing something wrong and keep getting all sorts of errors:</p>

<p>e.g. javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher</p>

<p>Below is my Java code. Can anyone please help point me in the right direction?</p>

<pre><code>package com.thebodgeitstore.util;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.regex.Pattern;
import javax.crypto.*;
import javax.crypto.spec.*;


   public class AES {
       private SecretKeySpec key;
       private Cipher cipher;
       private int size = 128;

       public AES() throws NoSuchAlgorithmException, NoSuchPaddingException{
           KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
           kgen.init(size); // 192 and 256 bits may not be available
           SecretKey skey = kgen.generateKey();
           byte[] raw = skey.getEncoded();
           key = new SecretKeySpec(raw, ""AES"");
           cipher = Cipher.getInstance(""AES"");
       }

       public void setKey(String keyText){
           byte[] bText = new byte[size];
           bText = keyText.getBytes();
           key = new SecretKeySpec(bText, ""AES"");
       }

       public String encrypt(String message) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException{
           cipher.init(Cipher.ENCRYPT_MODE, key);
           byte[] encrypted = cipher.doFinal(message.getBytes());
           return byteArrayToHexString(encrypted);
       }
       public String decrypt(String hexCiphertext) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException{
           cipher.init(Cipher.DECRYPT_MODE, key);
           byte[] decrypted = cipher.doFinal(hexStringToByteArray(hexCiphertext));
           return byteArrayToHexString(decrypted);
       }

       private static String byteArrayToHexString( byte [] raw ) {
            String hex = ""0x"";
            String s = new String(raw);
            for(int x = 0; x &lt; s.length(); x++){
                char[] t = s.substring(x, x + 1).toCharArray();
                hex += Integer.toHexString((int) t[0]).toUpperCase();
            }
            return hex;
       }

       private static byte[] hexStringToByteArray(String hex) {
            Pattern replace = Pattern.compile(""^0x"");
            String s = replace.matcher(hex).replaceAll("""");

            byte[] b = new byte[s.length() / 2];
            for (int i = 0; i &lt; b.length; i++){
              int index = i * 2;
              int v = Integer.parseInt(s.substring(index, index + 2), 16);
              b[i] = (byte)v;
            }
            return b;
       }


   }
</code></pre>

<p>Javascript code I'm using:</p>

<pre><code>/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  AES implementation in JavaScript (c) Chris Veness 2005-2011                                   */
/*   - see http://csrc.nist.gov/publications/PubsFIPS.html#197                                    */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Aes = {};  // Aes namespace

/**
 * AES Cipher function: encrypt 'input' state with Rijndael algorithm
 *   applies Nr rounds (10/12/14) using key schedule w for 'add round key' stage
 *
 * @param {Number[]} input 16-byte (128-bit) input state array
 * @param {Number[][]} w   Key schedule as 2D byte-array (Nr+1 x Nb bytes)
 * @returns {Number[]}     Encrypted output state array
 */
Aes.cipher = function(input, w) {    // main Cipher function [§5.1]
  var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
  var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys

  var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [§3.4]
  for (var i=0; i&lt;4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];

  state = Aes.addRoundKey(state, w, 0, Nb);

  for (var round=1; round&lt;Nr; round++) {
    state = Aes.subBytes(state, Nb);
    state = Aes.shiftRows(state, Nb);
    state = Aes.mixColumns(state, Nb);
    state = Aes.addRoundKey(state, w, round, Nb);
  }

  state = Aes.subBytes(state, Nb);
  state = Aes.shiftRows(state, Nb);
  state = Aes.addRoundKey(state, w, Nr, Nb);

  var output = new Array(4*Nb);  // convert state to 1-d array before returning [§3.4]
  for (var i=0; i&lt;4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
  return output;
}

/**
 * Perform Key Expansion to generate a Key Schedule
 *
 * @param {Number[]} key Key as 16/24/32-byte array
 * @returns {Number[][]} Expanded key schedule as 2D byte-array (Nr+1 x Nb bytes)
 */
Aes.keyExpansion = function(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [§5.2]
  var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
  var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
  var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys

  var w = new Array(Nb*(Nr+1));
  var temp = new Array(4);

  for (var i=0; i&lt;Nk; i++) {
    var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
    w[i] = r;
  }

  for (var i=Nk; i&lt;(Nb*(Nr+1)); i++) {
    w[i] = new Array(4);
    for (var t=0; t&lt;4; t++) temp[t] = w[i-1][t];
    if (i % Nk == 0) {
      temp = Aes.subWord(Aes.rotWord(temp));
      for (var t=0; t&lt;4; t++) temp[t] ^= Aes.rCon[i/Nk][t];
    } else if (Nk &gt; 6 &amp;&amp; i%Nk == 4) {
      temp = Aes.subWord(temp);
    }
    for (var t=0; t&lt;4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
  }

  return w;
}

/*
 * ---- remaining routines are private, not called externally ----
 */

Aes.subBytes = function(s, Nb) {    // apply SBox to state S [§5.1.1]
  for (var r=0; r&lt;4; r++) {
    for (var c=0; c&lt;Nb; c++) s[r][c] = Aes.sBox[s[r][c]];
  }
  return s;
}

Aes.shiftRows = function(s, Nb) {    // shift row r of state S left by r bytes [§5.1.2]
  var t = new Array(4);
  for (var r=1; r&lt;4; r++) {
    for (var c=0; c&lt;4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
    for (var c=0; c&lt;4; c++) s[r][c] = t[c];         // and copy back
  }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
  return s;  // see asmaes.sourceforge.net/rijndael/rijndaelImplementation.pdf
}

Aes.mixColumns = function(s, Nb) {   // combine bytes of each col of state S [§5.1.3]
  for (var c=0; c&lt;4; c++) {
    var a = new Array(4);  // 'a' is a copy of the current column from 's'
    var b = new Array(4);  // 'b' is a{02} in GF(2^8)
    for (var i=0; i&lt;4; i++) {
      a[i] = s[i][c];
      b[i] = s[i][c]&amp;0x80 ? s[i][c]&lt;&lt;1 ^ 0x011b : s[i][c]&lt;&lt;1;

    }
    // a[n] ^ b[n] is a{03} in GF(2^8)
    s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
    s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
    s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
    s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
  }
  return s;
}

Aes.addRoundKey = function(state, w, rnd, Nb) {  // xor Round Key into state S [§5.1.4]
  for (var r=0; r&lt;4; r++) {
    for (var c=0; c&lt;Nb; c++) state[r][c] ^= w[rnd*4+c][r];
  }
  return state;
}

Aes.subWord = function(w) {    // apply SBox to 4-byte word w
  for (var i=0; i&lt;4; i++) w[i] = Aes.sBox[w[i]];
  return w;
}

Aes.rotWord = function(w) {    // rotate 4-byte word w left by one byte
  var tmp = w[0];
  for (var i=0; i&lt;3; i++) w[i] = w[i+1];
  w[3] = tmp;
  return w;
}

// sBox is pre-computed multiplicative inverse in GF(2^8) used in subBytes and keyExpansion [§5.1.1]
Aes.sBox =  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
             0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
             0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
             0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
             0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
             0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
             0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
             0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
             0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
             0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
             0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
             0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
             0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
             0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
             0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
             0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];

// rCon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [§5.2]
Aes.rCon = [ [0x00, 0x00, 0x00, 0x00],
             [0x01, 0x00, 0x00, 0x00],
             [0x02, 0x00, 0x00, 0x00],
             [0x04, 0x00, 0x00, 0x00],
             [0x08, 0x00, 0x00, 0x00],
             [0x10, 0x00, 0x00, 0x00],
             [0x20, 0x00, 0x00, 0x00],
             [0x40, 0x00, 0x00, 0x00],
             [0x80, 0x00, 0x00, 0x00],
             [0x1b, 0x00, 0x00, 0x00],
             [0x36, 0x00, 0x00, 0x00] ]; 


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  AES Counter-mode implementation in JavaScript (c) Chris Veness 2005-2011                      */
/*   - see http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf                       */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

Aes.Ctr = {};  // Aes.Ctr namespace: a subclass or extension of Aes

/** 
 * Encrypt a text using AES encryption in Counter mode of operation
 *
 * Unicode multi-byte character safe
 *
 * @param {String} plaintext Source text to be encrypted
 * @param {String} password  The password to use to generate a key
 * @param {Number} nBits     Number of bits to be used in the key (128, 192, or 256)
 * @returns {string}         Encrypted text
 */
Aes.Ctr.encrypt = function(plaintext, password, nBits) {
  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
  if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  plaintext = Utf8.encode(plaintext);
  password = Utf8.encode(password);
  //var t = new Date();  // timer

  // use AES itself to encrypt password to get cipher key (using plain password as source for key 
  // expansion) - gives us well encrypted key (though hashed key might be preferred for prod'n use)
  var nBytes = nBits/8;  // no bytes in key (16/24/32)
  var pwBytes = new Array(nBytes);
  for (var i=0; i&lt;nBytes; i++) {  // use 1st 16/24/32 chars of password for key
    pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
  }
  var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));  // gives us 16-byte key
  key = key.concat(key.slice(0, nBytes-16));  // expand key to 16/24/32 bytes long

  // initialise 1st 8 bytes of counter block with nonce (NIST SP800-38A §B.2): [0-1] = millisec, 
  // [2-3] = random, [4-7] = seconds, together giving full sub-millisec uniqueness up to Feb 2106
  var counterBlock = new Array(blockSize);

  var nonce = (new Date()).getTime();  // timestamp: milliseconds since 1-Jan-1970
  var nonceMs = nonce%1000;
  var nonceSec = Math.floor(nonce/1000);
  var nonceRnd = Math.floor(Math.random()*0xffff);

  for (var i=0; i&lt;2; i++) counterBlock[i]   = (nonceMs  &gt;&gt;&gt; i*8) &amp; 0xff;
  for (var i=0; i&lt;2; i++) counterBlock[i+2] = (nonceRnd &gt;&gt;&gt; i*8) &amp; 0xff;
  for (var i=0; i&lt;4; i++) counterBlock[i+4] = (nonceSec &gt;&gt;&gt; i*8) &amp; 0xff;

  // and convert it to a string to go on the front of the ciphertext
  var ctrTxt = '';
  for (var i=0; i&lt;8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);

  // generate key schedule - an expansion of the key into distinct Key Rounds for each round
  var keySchedule = Aes.keyExpansion(key);

  var blockCount = Math.ceil(plaintext.length/blockSize);
  var ciphertxt = new Array(blockCount);  // ciphertext as array of strings

  for (var b=0; b&lt;blockCount; b++) {
    // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
    // done in two stages for 32-bit ops: using two words allows us to go past 2^32 blocks (68GB)
    for (var c=0; c&lt;4; c++) counterBlock[15-c] = (b &gt;&gt;&gt; c*8) &amp; 0xff;
    for (var c=0; c&lt;4; c++) counterBlock[15-c-4] = (b/0x100000000 &gt;&gt;&gt; c*8)

    var cipherCntr = Aes.cipher(counterBlock, keySchedule);  // -- encrypt counter block --

    // block size is reduced on final block
    var blockLength = b&lt;blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
    var cipherChar = new Array(blockLength);

    for (var i=0; i&lt;blockLength; i++) {  // -- xor plaintext with ciphered counter char-by-char --
      cipherChar[i] = cipherCntr[i] ^ plaintext.charCodeAt(b*blockSize+i);
      cipherChar[i] = String.fromCharCode(cipherChar[i]);
    }
    ciphertxt[b] = cipherChar.join(''); 
  }

  // Array.join is more efficient than repeated string concatenation in IE
  var ciphertext = ctrTxt + ciphertxt.join('');
  ciphertext = stringToHex(ciphertext);  // encode in base64

  //alert((new Date()) - t);
  return ciphertext;
}

/** 
 * Decrypt a text encrypted by AES in counter mode of operation
 *
 * @param {String} ciphertext Source text to be encrypted
 * @param {String} password   The password to use to generate a key
 * @param {Number} nBits      Number of bits to be used in the key (128, 192, or 256)
 * @returns {String}          Decrypted text
 */
Aes.Ctr.decrypt = function(ciphertext, password, nBits) {
  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
  if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  ciphertext = hexToString(ciphertext);
  password = Utf8.encode(password);
  //var t = new Date();  // timer

  // use AES to encrypt password (mirroring encrypt routine)
  var nBytes = nBits/8;  // no bytes in key
  var pwBytes = new Array(nBytes);
  for (var i=0; i&lt;nBytes; i++) {
    pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
  }
  var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));
  key = key.concat(key.slice(0, nBytes-16));  // expand key to 16/24/32 bytes long

  // recover nonce from 1st 8 bytes of ciphertext
  var counterBlock = new Array(8);
  ctrTxt = ciphertext.slice(0, 8);
  for (var i=0; i&lt;8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);

  // generate key schedule
  var keySchedule = Aes.keyExpansion(key);

  // separate ciphertext into blocks (skipping past initial 8 bytes)
  var nBlocks = Math.ceil((ciphertext.length-8) / blockSize);
  var ct = new Array(nBlocks);
  for (var b=0; b&lt;nBlocks; b++) ct[b] = ciphertext.slice(8+b*blockSize, 8+b*blockSize+blockSize);
  ciphertext = ct;  // ciphertext is now array of block-length strings

  // plaintext will get generated block-by-block into array of block-length strings
  var plaintxt = new Array(ciphertext.length);

  for (var b=0; b&lt;nBlocks; b++) {
    // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
    for (var c=0; c&lt;4; c++) counterBlock[15-c] = ((b) &gt;&gt;&gt; c*8) &amp; 0xff;
    for (var c=0; c&lt;4; c++) counterBlock[15-c-4] = (((b+1)/0x100000000-1) &gt;&gt;&gt; c*8) &amp; 0xff;

    var cipherCntr = Aes.cipher(counterBlock, keySchedule);  // encrypt counter block

    var plaintxtByte = new Array(ciphertext[b].length);
    for (var i=0; i&lt;ciphertext[b].length; i++) {
      // -- xor plaintxt with ciphered counter byte-by-byte --
      plaintxtByte[i] = cipherCntr[i] ^ ciphertext[b].charCodeAt(i);
      plaintxtByte[i] = String.fromCharCode(plaintxtByte[i]);
    }
    plaintxt[b] = plaintxtByte.join('');
  }

  // join array of blocks into single plaintext string
  var plaintext = plaintxt.join('');
  plaintext = Utf8.decode(plaintext);  // decode from UTF8 back to Unicode multi-byte chars

  //alert((new Date()) - t);
  return plaintext;
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Base64 class: Base 64 encoding / decoding (c) Chris Veness 2002-2011                          */
/*    note: depends on Utf8 class                                                                 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Base64 = {};  // Base64 namespace

Base64.code = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="";

/**
 * Encode string into Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, no newlines are added.
 *
 * @param {String} str The string to be encoded as base-64
 * @param {Boolean} [utf8encode=false] Flag to indicate whether str is Unicode string to be encoded 
 *   to UTF8 before conversion to base64; otherwise string is assumed to be 8-bit characters
 * @returns {String} Base64-encoded string
 */ 
Base64.encode = function(str, utf8encode) {  // http://tools.ietf.org/html/rfc4648
  utf8encode =  (typeof utf8encode == 'undefined') ? false : utf8encode;
  var o1, o2, o3, bits, h1, h2, h3, h4, e=[], pad = '', c, plain, coded;
  var b64 = Base64.code;

  plain = utf8encode ? str.encodeUTF8() : str;

  c = plain.length % 3;  // pad string to length of multiple of 3
  if (c &gt; 0) { while (c++ &lt; 3) { pad += '='; plain += '\0'; } }
  // note: doing padding here saves us doing special-case packing for trailing 1 or 2 chars

  for (c=0; c&lt;plain.length; c+=3) {  // pack three octets into four hexets
    o1 = plain.charCodeAt(c);
    o2 = plain.charCodeAt(c+1);
    o3 = plain.charCodeAt(c+2);

    bits = o1&lt;&lt;16 | o2&lt;&lt;8 | o3;

    h1 = bits&gt;&gt;18 &amp; 0x3f;
    h2 = bits&gt;&gt;12 &amp; 0x3f;
    h3 = bits&gt;&gt;6 &amp; 0x3f;
    h4 = bits &amp; 0x3f;

    // use hextets to index into code string
    e[c/3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  }
  coded = e.join('');  // join() is far faster than repeated string concatenation in IE

  // replace 'A's from padded nulls with '='s
  coded = coded.slice(0, coded.length-pad.length) + pad;

  return coded;
}

/**
 * Decode string from Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, newlines are not catered for.
 *
 * @param {String} str The string to be decoded from base-64
 * @param {Boolean} [utf8decode=false] Flag to indicate whether str is Unicode string to be decoded 
 *   from UTF8 after conversion from base64
 * @returns {String} decoded string
 */ 
Base64.decode = function(str, utf8decode) {
  utf8decode =  (typeof utf8decode == 'undefined') ? false : utf8decode;
  var o1, o2, o3, h1, h2, h3, h4, bits, d=[], plain, coded;
  var b64 = Base64.code;

  coded = utf8decode ? str.decodeUTF8() : str;


  for (var c=0; c&lt;coded.length; c+=4) {  // unpack four hexets into three octets
    h1 = b64.indexOf(coded.charAt(c));
    h2 = b64.indexOf(coded.charAt(c+1));
    h3 = b64.indexOf(coded.charAt(c+2));
    h4 = b64.indexOf(coded.charAt(c+3));

    bits = h1&lt;&lt;18 | h2&lt;&lt;12 | h3&lt;&lt;6 | h4;

    o1 = bits&gt;&gt;&gt;16 &amp; 0xff;
    o2 = bits&gt;&gt;&gt;8 &amp; 0xff;
    o3 = bits &amp; 0xff;

    d[c/4] = String.fromCharCode(o1, o2, o3);
    // check for padding
    if (h4 == 0x40) d[c/4] = String.fromCharCode(o1, o2);
    if (h3 == 0x40) d[c/4] = String.fromCharCode(o1);
  }
  plain = d.join('');  // join() is far faster than repeated string concatenation in IE

  return utf8decode ? plain.decodeUTF8() : plain; 
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */
/*              single-byte character encoding (c) Chris Veness 2002-2011                         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Utf8 = {};  // Utf8 namespace

/**
 * Encode multi-byte Unicode string into utf-8 multiple single-byte characters 
 * (BMP / basic multilingual plane only)
 *
 * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars
 *
 * @param {String} strUni Unicode string to be encoded as UTF-8
 * @returns {String} encoded string
 */
Utf8.encode = function(strUni) {
  // use regular expressions &amp; String.replace callback function for better efficiency 
  // than procedural approaches
  var strUtf = strUni.replace(
      /[\u0080-\u07ff]/g,  // U+0080 - U+07FF =&gt; 2 bytes 110yyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0);
        return String.fromCharCode(0xc0 | cc&gt;&gt;6, 0x80 | cc&amp;0x3f); }
    );
  strUtf = strUtf.replace(
      /[\u0800-\uffff]/g,  // U+0800 - U+FFFF =&gt; 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0); 
        return String.fromCharCode(0xe0 | cc&gt;&gt;12, 0x80 | cc&gt;&gt;6&amp;0x3F, 0x80 | cc&amp;0x3f); }
    );
  return strUtf;
}

/**
 * Decode utf-8 encoded string back into multi-byte Unicode characters
 *
 * @param {String} strUtf UTF-8 string to be decoded back to Unicode
 * @returns {String} decoded string
 */
Utf8.decode = function(strUtf) {
  // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!
  var strUni = strUtf.replace(
      /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = ((c.charCodeAt(0)&amp;0x0f)&lt;&lt;12) | ((c.charCodeAt(1)&amp;0x3f)&lt;&lt;6) | ( c.charCodeAt(2)&amp;0x3f); 
        return String.fromCharCode(cc); }
    );
  strUni = strUni.replace(
      /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = (c.charCodeAt(0)&amp;0x1f)&lt;&lt;6 | c.charCodeAt(1)&amp;0x3f;
        return String.fromCharCode(cc); }
    );
  return strUni;
}

function encryptForm(key, form){
    var params = form_to_params(form);

    if(params.length &gt; 0)
        return Aes.Ctr.encrypt(params, key, 128);
    return false;
}


function stringToHex (s) {
  var r = ""0x"";
  var hexes = new Array (""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f"");
  for (var i=0; i&lt;s.length; i++) {r += hexes [s.charCodeAt(i) &gt;&gt; 4] + hexes [s.charCodeAt(i) &amp; 0xf];}
  return r;
}

function hexToString (h) {
  var r = """";
  for (var i= (h.substr(0, 2)==""0x"")?2:0; i&lt;h.length; i+=2) {r += String.fromCharCode (parseInt (h.substr (i, 2), 16));}
  return r;
}
</code></pre>

<p>For the purpose of what I'm doing, it really doesn't mater what format of AES encryption is used, I just need something where they both agree. I'm thinking I have different padding settings between the two, but I'm not entirely sure.</p>
"	NULL	0	NULL	18:28.0	3	24:00.4	36:10.2	NULL	238704	543770	0	1	1	<java><javascript><encryption><aes>	AES JavaScript & Java	5481	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
8990891	9137048	2	"<p>I noticed that an application I was running was throwing exceptions upon simultaneous decryption. I wrote the following to test this:</p>

<pre><code>public void run() {
    for(int i=0; i&lt;100000; i++){
        String encrypted = Crypt.encrypt(
                ""Lorem ipsum dolor sit amet."",
                ""password""
        );

        String decrypted = Crypt.decrypt(encrypted, ""password"")[0];
        System.out.println(decrypted);
    }
}


public static void main(String[] args) {

    Thread t1 = new Thread(new Main());
    Thread t2 = new Thread(new Main());

    t1.start();
    t2.start();

}
</code></pre>

<p>The Crypt methods are as follows:</p>

<pre><code>public static String encrypt(String input, String key){

    try {

        byte[] ivBytes = new byte[16];
        SecureRandom.getInstance(""SHA1PRNG"").nextBytes(ivBytes);

        IvParameterSpec ips = new IvParameterSpec(ivBytes);
        byte[] keybytes = md5(key);//This isn't final. Don't worry ;)
        byte[] crypted = null;
        SecretKeySpec skey = new SecretKeySpec(keybytes, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skey, ips);
        byte[] ptext = input.getBytes(""UTF-8"");
        crypted = cipher.doFinal(ptext);

        return Base64.encodeBase64String(ivBytes)+Base64.encodeBase64String(crypted);
    }catch(Exception e){
        e.printStackTrace();
    }
    return null;
}

public static String[] decrypt(String input, String key){

    String iv = input.substring(0, 24);
    String encrypted = input.substring(24);
    try {
        IvParameterSpec ips = new IvParameterSpec(Base64.decodeBase64(iv));
        byte[] keybytes = md5(key);//This isn't final. Don't worry ;)
        byte[] output = null;
        SecretKeySpec skey = new SecretKeySpec(keybytes, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skey, ips);
        output = cipher.doFinal(Base64.decodeBase64(encrypted));
        if(output==null){
            throw new Exception();
        }

        return new String[]{new String(output),iv};
    }catch(Exception e){
        e.printStackTrace();
    }
}
</code></pre>

<p>Sure enough the first attempt on both threads fail:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
at javax.crypto.Cipher.doFinal(DashoA13*..)
at common.Crypt.decrypt(Crypt.java:122)
at bootstrap.Main.run(Main.java:427)
at java.lang.Thread.run(Thread.java:680)
</code></pre>

<p>There are successes for approximately 20 attempts on each thread (presumably where the unsafe calls don't intersect) and then exceptions are thrown. This pattern seems to continue.</p>

<p>I'm running this on OS X 10.7.2 if that helps.</p>

<p>If I understand correctly this could simply be a vendor issue as it's using the Sun JDK which I could easily swap out, but I thought it would be best to get some more experienced opinions on this and put it up in case someone having the same issue stumbles across it.</p>

<p>If someone could point me in the direction of a thread safe encryption+decryption scheme which achieves the same results I'd be really grateful.</p>

<p>Thanks,
Marcus</p>
"	NULL	5	NULL	02:16.5	3	53:11.2	NULL	NULL	0	661464	0	1	1	<java><multithreading><cryptography><aes>	AES Java Multithreading exceptions	2274	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
9483069	9483154	2	"<p>In my application i want to store some secure data by encrypting it. When the user wants i need to show it to him by decrypting it.
This is working fine.
But the problem is i need to store both encrypted message and initialization vector for every message. This initialization vector is generated while encrypting and i have to use this while decrypting to get the original message.</p>

<p>So if the user stores 1000 messages i need to store those 1000 encrypted messages and corresponding 1000 initialization vectors.I want to avoid storing initialization vector for every message. </p>

<p>Please tell me the way to AES-256 encryption with out Initialization vector.</p>

<p>Below is my code for encrypting and decrypting</p>

<pre><code>/*
     * This method will do the AES-256 encryption.
     */
    private byte[] encrypt(char[] raw, String cardno) {
     //  This raw is some unique key like password.      
        SecretKeyFactory factory = null;
        SecretKey tmp = null;
        Cipher cipher = null;
        byte[] ciphertext = null;
        AlgorithmParameters params = null;
        try {
            factory = SecretKeyFactory.getInstance(""PBEWITHSHA-256AND256BITAES-CBC-BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        KeySpec spec = new PBEKeySpec(raw, mSalt, 1024, 256);

        try {
            if (factory != null)
                tmp = factory.generateSecret(spec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        if (tmp != null)
            mSecret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
        try {
            if (cipher != null)
                cipher.init(Cipher.ENCRYPT_MODE, mSecret);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        }
        if (cipher != null)
            params = cipher.getParameters();
        try {

            mIV = params.getParameterSpec(IvParameterSpec.class).getIV();

        } catch (InvalidParameterSpecException e) {
            e.printStackTrace();
        }
        try {
            ciphertext = cipher.doFinal(cardno.getBytes(""UTF-8""));
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return ciphertext;

    }





/*
     * This will decrypt the encrypted data based on provided key
     */
    private byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        //This raw is initialization vector generated while encrypting 
        Cipher cipher = null;
        byte[] decrypted = null;

        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
        try {
            cipher.init(Cipher.DECRYPT_MODE, mSecret, new IvParameterSpec(raw));
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
        try {
            decrypted = cipher.doFinal(encrypted);
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }


        return decrypted;
    }
</code></pre>
"	NULL	0	NULL	47:18.9	4	25:08.4	NULL	NULL	0	737442	0	1	2	<android><encryption><aes>	How to do AES-256 Encryption and Decryption with out Initialization Vector in android	6578	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
9496447	9496626	2	"<p>I am using this method for encrypting a video file:</p>

<pre><code>public static void encryptToBinaryFile(String password, byte[] bytes, File file) throws EncrypterException {
    try {
        final byte[] rawKey = getRawKey(password.getBytes());
        final FileOutputStream ostream = new FileOutputStream(file, false);

        ostream.write(encrypt(rawKey, bytes));
        ostream.flush();
        ostream.close();

    } catch (IOException e) {
        throw new EncrypterException(e);
    }
}

private static byte[] encrypt(byte[] raw, byte[] clear) throws EncrypterException {
    try {
       final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
       final Cipher cipher = Cipher.getInstance(""AES"");
       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

       return cipher.doFinal(clear);

    } catch (Exception e) {
        throw new EncrypterException(e);
    }
}
</code></pre>

<p>But It gives an error Outofmemoryerror saying rejecting allocation of 301023321 element.</p>

<p>1.Is the method I am using correct for such big files?</p>

<p>2.If yes why I am getting this error?What is solution?</p>

<p>3.If no please suggest some good method for that?</p>
"	NULL	4	NULL	23:01.8	24	53:36.7	16:52.1	NULL	194544	1151433	0	1	15	<java><android><file><encryption><out-of-memory>	Encryption of video files?	25236	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
9839754	9862394	2	"<p>I need help on encryption/decryption on Android application.</p>

<p>I explain the situation. I'm actually wrote an application that used content generated and encrypted by an iPhone application.</p>

<p>And for securisation, the user provide his own passphrase to correctly encrypt/decrypt data between different platform...</p>

<p>But, I encount a problem with the encryption/decryption of this passphrase on Android.</p>

<p>I have two functions:</p>

<pre><code>public byte[] crypt(String pStringToCrypt) throws Exception{

    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, this.passphrase.getBytes().length);
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(pStringToCrypt.getBytes());
    return encrypted;

}
</code></pre>

<p>for the crypting of String, and this function:</p>

<pre><code>public String decrypt(byte[] pCryptedStringtoDecrypt) throws Exception{
    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, this.passphrase.getBytes().length);
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    byte[] encrypted = pCryptedStringtoDecrypt;
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] original = cipher.doFinal(encrypted);
    String originalString = new String(original);
    return originalString;
}
</code></pre>

<p>for the decrypting of String.</p>

<p>When I use the crypt method to encrypt data, I haven't error and the string was encrypted:</p>

<pre><code>encrypted = [26, 119, -108, -24, 81, -128, 18, 35, -96, 10, -38, 69, 111, 40, 109, 107]
</code></pre>

<p>If I try to transform this byte into a string, I obtain this string:</p>

<pre><code>encryptedString = ""w??Q?#?\n?Eo(mk""
</code></pre>

<p>I think the crypting phase was good.
Now when I try to decrypt this encrypted String, the application crashed:</p>

<pre><code>javax.crypto.IllegalBlockSizeException: last block incomplete in decryption
    at org.bouncycastle.jce.provider.JCEBlockCipher.engineDoFinal(JCEBlockCipher.java:711)
    at javax.crypto.Cipher.doFinal(Cipher.java:1090)
    at org.vincentsaluzzo.lightrpc.common.security.AES256.decrypt(AES256.java:61)
    at com.vincentsaluzzo.LoginBox.model.SettingsManager.getUserPassphrase(SettingsManager.java:67)
    at com.vincentsaluzzo.LoginBox.mainActivity.onCreate(mainActivity.java:26)
    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1047)
    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:1586)
    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:1638)
    at android.app.ActivityThread.access$1500(ActivityThread.java:117)
    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:928)
    at android.os.Handler.dispatchMessage(Handler.java:99)
    at android.os.Looper.loop(Looper.java:123)
    at android.app.ActivityThread.main(ActivityThread.java:3647)
    at java.lang.reflect.Method.invokeNative(Native Method)
    at java.lang.reflect.Method.invoke(Method.java:507)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:839)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:597)
    at dalvik.system.NativeStart.main(Native Method)
</code></pre>

<p>And I don't understand why this error appear...</p>

<p><strong>Do you have some solutions ? or some explanation for me ?</strong></p>
"	NULL	5	NULL	07:32.4	4	25:24.7	NULL	NULL	0	1288277	0	1	3	<android><cryptography><aes><encryption>	AES encrypt/decrypt on Android doesn't run	5660	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10247896	10248237	2	"<p>I'm getting crazy to encrypt/decrypt between c and Java but so far the encrypted string in Java and the one in c don't look the same.
I've investigated base64 encoding/decoding but after getting crazy to find a library for java and c the respective base64 results looked different!
I think it's a problem of converting between Java UTF16 string, saving Byte in java or perhaps AES options (128/256 key, PK5 padding or who knows what), or maybe the UTF8 conversion of the terminal or an absurd combination of the above.
So far I get:</p>

<pre><code>  user1@comp1:~/Desktop$ gcc AES.c /usr/lib/libmcrypt.a -lssl -lcrypto -lpthread
  user1@comp1:~/Desktop$ /usr/java/jdk1.6.0_25/bin/javac AES.java
  user1@comp1:~/Desktop$ ./a.out 
      Before encryption: test text 123
      After encryption: 49 -60 66 43 -8 66 -106 0 -14 -44 3 47 65 127 -110 117 
      After decryption: test text 123
  user1@comp1:~/Desktop$ java AES 
     Before encryption: test text 123
     After encryption: -110 21 23 59 47 120 70 -93 -54 -93 -12 -70 -91 83 -113 85 
     After decryption: test text 123
</code></pre>

<p>I think I really need help here from someone into low level coding, below is the code for Java and c respectively:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AES {
  public static void main(String [] args) {
      try {
  String text = ""test text 123"";
  /*fixed here now it is 128 bits = 16 Bytes*/
  String encryptionKey = ""E072EDF9534053A0"";

  System.out.println(""Before encryption: "" + text);

  byte[] cipher = encrypt(text, encryptionKey);

  System.out.print(""After encryption: "");
  for (int i=0; i&lt;cipher.length; i++)
        System.out.print(new Integer(cipher[i])+"" "");
  System.out.println("""");

  String decrypted = decrypt(cipher, encryptionKey);

  System.out.println(""After decryption: "" + decrypted);

      } catch (Exception e) {
  e.printStackTrace();
      } 
  }

  public static byte[] encrypt(String plainText, String encryptionKey) throws Exception {
      Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
      SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
      cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));
      return cipher.doFinal(plainText.getBytes(""UTF-8""));
  }

  public static String decrypt(byte[] cipherText, String encryptionKey) throws Exception{
      Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
      SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
      cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));
      return new String(cipher.doFinal(cipherText),""UTF-8"");
  }
  }
</code></pre>

<p>and</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;mcrypt.h&gt;

#include &lt;math.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
MCRYPT td, td2;
const char * plaintext = ""test text 123"";
int i;
char *key; /* created using mcrypt_gen_key */
char *IV;
char * block_buffer;
int blocksize;
int keysize = 16; /* 128 bits == 16 bytes */
size_t* sizet;

key = calloc(1, keysize);

/*below dirty trick to be sure the entire key has been padded with \0's */
strcpy(key, ""E072EDF9534053A0"");
memset(key, '\0', sizeof(key));
strcpy(key, ""E072EDF9534053A0"");

/*  MCRYPT mcrypt_module_open( char *algorithm, char* algorithm_directory, char* mode, char* mode_directory);
 * This function normally returns an encryption descriptor, or MCRYPT_FAILED on error. 
 */
td = mcrypt_module_open(""rijndael-128"", NULL, ""cbc"", NULL);
/*we need two encryption descriptors td and td2 for decryption*/
td2 = mcrypt_module_open(""rijndael-128"", NULL, ""cbc"", NULL);

blocksize = mcrypt_enc_get_block_size(td);
block_buffer = calloc(1, blocksize);
/*below to be sure the entire block_buffer has been padded with \0's */
memset(block_buffer, '\0', blocksize);

IV = malloc(mcrypt_enc_get_iv_size(td));
if ((block_buffer == NULL) || (IV == NULL)) {
fprintf(stderr, ""Failed to allocate memory\n"");
exit(EXIT_FAILURE);
}
for (i = 0; i &lt; mcrypt_enc_get_iv_size(td); i++) {
IV[i] = 0;
}
/*as we can see both td and td2 get same key and IV*/
mcrypt_generic_init(td, key, keysize, IV);
mcrypt_generic_init(td2, key, keysize, IV);

memset(block_buffer, '\0', sizeof(plaintext));
strcpy(block_buffer, plaintext);

printf(""Before encryption: %s\n"", block_buffer);
mcrypt_generic (td, block_buffer, blocksize);

printf(""After encryption: "");
for (i=0; i &lt; blocksize; i++)
    printf(""%d "", block_buffer[i]);
printf(""\n"");

mdecrypt_generic (td2, block_buffer, blocksize);
printf(""After decryption: %s\n"", block_buffer);

/* deinitialize the encryption thread */
mcrypt_generic_deinit (td);
mcrypt_generic_deinit(td2);
/* Unload the loaded module */
mcrypt_module_close(td);
mcrypt_module_close(td2);
return 0;
}
</code></pre>
"	NULL	12	NULL	08:32.6	4	30:39.1	09:02.8	NULL	140264	1085703	0	1	2	<java><c><cryptography><aes><mcrypt>	AES rijndael encrypt between c and java	14242	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10341150	10341629	2	"<p>I'm looking for a way to, given a password of any size, encrypt a file I'm receiving over a stream with <code>AES</code>. To make things easier to start with, I was trying to just write some encrypted message to a file. But I'm having trouble:</p>

<ol>
<li>I'd like to be able to define a password of any size. Is it possible to accomplish it in a ""standard"" form or will I have to pad the passwords to 2^k sizes? I'm currently circumventing the problem providing a temporary ""aaaaaaaaaaaaaaaa"" password, but I'd like to get rid of it as soon as possible.</li>
<li>If I try to write a long string to <code>cos</code>, something encrypted will be written to the file. But if I try something smaller, as ""abc"", nothing will be written. I've played with several padding options but they seem of no avail (PKCS5Padding, SSL3Padding, NoPadding).</li>
</ol>

<p>Here is the code I'm using:</p>

<pre><code>    SecretKeySpec localSecretKeySpec = new SecretKeySpec(""aaaaaaaaaaaaaaaa"".getBytes(), ""AES"");
    Cipher localCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    localCipher.init(Cipher.ENCRYPT_MODE, localSecretKeySpec);

    CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(""abc""), localCipher);
    IOUtils.write(""abc"", cos);
    cos.flush();
</code></pre>
"	NULL	0	NULL	43:03.7	2	25:33.1	49:13.9	NULL	130758	130758	0	1	0	<java><security><encryption>	Using CipherOutputStream + AES to write a string to a file	4062	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10416828	10417575	3	"<p>Does anyone know what's wrong with this code?</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/ECB128/PKCS5Padding"", ""SunJCE"");
</code></pre>

<ul>
<li>Algorithm: AES</li>
<li>Mode of operation: ECB (with 128 appended to specify the block size)</li>
<li>PaddingSchemce: PKCS5Padding</li>
</ul>

<p>This seems correct to me but it keeps throwing the ""No such algorithm"" exception during instantiation.</p>
"	NULL	1	NULL	26:56.4	3	41:41.8	37:13.8	NULL	589259	1293653	0	1	2	<java><encryption><cryptography><padding><ecb>	"Cipher with AES/ECB128/PKCS5Padding keeps throwing ""No such algorithm"" exception"	8694	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10427205	0	NULL	"<p>I have to <em>decrypt</em> a frame on my server. Encrypted frame comes from client device through GPRS on socket.<em>Encryption</em> is done with <strong>TripleDes</strong> and with a given key.I use same algorithm and key on server side. Frame is a combination of Hex and Ascii String. Now the  problem is : When I pad my byte array with zeros I get the following exception.</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
</code></pre>

<p>Following is my code :</p>

<pre><code>byte[] key = new byte[]{31, 30, 31, 36, 32, 11, 11, 11, 22, 26,
               30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30};
myKeySpec = new DESedeKeySpec(key);
mySecretKeyFactory = SecretKeyFactory.getInstance(""TripleDES"");
de = mySecretKeyFactory.generateSecret(myKeySpec);

    Cipher c = Cipher.getInstance(""TripleDES"");
c.init(Cipher.DECRYPT_MODE, key);

    int l = completeHexStr.length();

    if (l%8==1){
        completeHexStr = completeHexStr + ""0000000"";
    }else if (l%8==7){
        completeHexStr = completeHexStr + ""0"";
    }
byte decordedValue[] =completeHexString.getBytes();
byte[] decValue = c.doFinal(decordedValue);
String decryptedValue = new String(decValue);
System.out.println(""decryptedValue= "" + decryptedValue);
</code></pre>

<p>Here are the functions which I am using inside the code:</p>

<pre><code>    public String stringToHex(String base) {
            StringBuffer buffer = new StringBuffer();
            int intValue = 0;
            for (int x = 0; x &lt; base.length(); x++) {
                intValue = base.charAt(x);
                String hex = Integer.toHexString(intValue);
                if (hex.length() == 1) {
                    buffer.append(""0"" + hex + """");
                } else {
                    buffer.append(hex + """");
                }
            }
            return buffer.toString();
        }
    public String byteToAscii(byte[] b, int length) {
            String returnString = """";
            for (int i = 0; i &lt; length; i++) {
                returnString += (char) (b[i] &amp; 0xff);
            }
            return returnString;
        }
</code></pre>

<p>this is the code in c used for encryption at client side.</p>

<pre><code>#include &lt;svc_sec.h&gt;
const unsigned char fixed_key[] = { 0x31, 0x30, 0x31, 0x36, 0x32, 0x11, 0x11, 0x11, 0x22, 0x26, 0x30,
0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};
int Comm_Encrypt_Data(unsigned char *Test_Input_Data, int Len_Input_Data)
{
int Count_Input_Data, Counter_Input_Data;
unsigned long Timer_1;
unsigned char Init_Vector[8];
int Counter_Init_Vector, Temp_Byte_Count;
unsigned char *Temp_Dst_Ptr, *Temp_Src_Ptr;
unsigned char Temp_Input_Frame[9], Temp_Output_Frame[9];
unsigned char Test_Output_Data[500];
unsigned char Test_Key_Arr[9];

memset(&amp;Init_Vector[0], '\0', sizeof(Init_Vector));
memset(Test_Key_Arr, '0', sizeof(Test_Key_Arr));
memcpy(Test_Key_Arr, &amp;fixed_key[0], 8);
Test_Key_Arr[sizeof(Test_Key_Arr)-1] = '\0';

Display_Data(""KEY: "", Test_Key_Arr, sizeof(Test_Key_Arr)-1);

memset(Test_Output_Data, '\0', sizeof(Test_Output_Data));
memcpy(Test_Output_Data, Test_Input_Data, 48);

Count_Input_Data = Len_Input_Data -48 -3; //minus Data before payload, 3 bytes of '|' and CRC
Counter_Input_Data = 0;
while(Counter_Input_Data &lt; Count_Input_Data)
{
Temp_Byte_Count = Count_Input_Data- Counter_Input_Data;
if(Temp_Byte_Count &gt; 8)
Temp_Byte_Count = 8;

memcpy(Temp_Input_Frame, &amp;Test_Input_Data[48+Counter_Input_Data], Temp_Byte_Count);
//succeeding bytes to be 0
if(Temp_Byte_Count &lt; 8)
{
memset(&amp;Temp_Input_Frame[Temp_Byte_Count], '0', (8-Temp_Byte_Count));

}

Display_Data(""InPut Data Before Init"",Temp_Input_Frame, Temp_Byte_Count);

//============Initialize the data
Temp_Dst_Ptr = (unsigned char *)Temp_Input_Frame;
Temp_Src_Ptr = (unsigned char *)&amp;Init_Vector[0];
for(Counter_Init_Vector =0;Counter_Init_Vector &lt; 8; Counter_Init_Vector++)
*Temp_Dst_Ptr++ ^= *Temp_Src_Ptr++;
//============Initializing data ends

DES(DESE, (unsigned char *)&amp;Test_Key_Arr[0],
(unsigned char *)&amp;Temp_Input_Frame[0], (unsigned char *)&amp;Temp_Output_Frame[0]);
//DES(TDES3KE, (unsigned char *)&amp;Test_Key_Arr[0],
// (unsigned char *)&amp;Temp_Input_Frame[0], (unsigned char *)&amp;Temp_Output_Frame[0]);
Display_Data(""AFTER DES::::"", Temp_Output_Frame, Temp_Byte_Count);

memcpy(&amp;Test_Output_Data[48+Counter_Input_Data], Temp_Output_Frame, Temp_Byte_Count);
Counter_Input_Data += Temp_Byte_Count;

if(Counter_Input_Data &lt; Count_Input_Data)
{
memcpy(Init_Vector, Temp_Output_Frame, 8);

}
}

{
memset(Test_Input_Data, '\0', Len_Input_Data);
memcpy(&amp;Test_Input_Data[0], &amp;Test_Output_Data[48], Counter_Input_Data); //1 Separator + 2 CRCs
}
Display_Data(""Final Output Frame"", Test_Input_Data, Counter_Input_Data);
return Counter_Input_Data;
}
</code></pre>

<p>I am new in java <code>Cryptography</code>. Please tell me how to do it? Can anybody post the code which can work properly to decrypt my frame. Thanks in advance.</p>
"	NULL	NULL	NULL	48:04.0	NULL	NULL	NULL	NULL	NULL	364207	0	1	14	<java><encryption><padding>	javax.crypto.BadPaddingException:Given final block not properly padded	67218	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10440777	10441842	3	"<p>I'm trying to encrypt some data in a Python program and save it out, then decrypt that data in a Java program.  In Python, I'm encrypting it like this:</p>

<pre><code>from Crypto.Cipher import AES
KEY = '12345678901234567890123456789012'

def encrypt(data):
    cipher = AES.new(KEY, AES.MODE_CFB)
    return cipher.encrypt(data)
</code></pre>

<p>And in Java, I'm decrypting it like this:</p>

<pre><code>import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {
    private static byte[] KEY = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2' };

    public static byte[] decrypt(byte[] data) throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher c = Cipher.getInstance(""AES/CFB/NoPadding"");
        Key key = new SecretKeySpec(KEY, ""AES"");
        c.init(Cipher.DECRYPT_MODE, key);
        return c.doFinal(data);
    }
}
</code></pre>

<p>But I get <code>Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size or default parameters</code>.  Clearly, I'm doing something wrong.  But what?</p>
"	NULL	2	NULL	32:02.7	2	20:03.8	NULL	NULL	0	9161	0	1	7	<java><python><encryption><aes>	How do I encrypt in Python and decrypt in Java?	7893	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10585366	10603242	1	"<p>I am running this Java code for AES encryption:</p>

<pre><code>byte[] iv = new byte[16];

SecretKey aesKey = new SecretKeySpec(""hex key here"", ""AES"");

Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(iv));

return cipher.doFinal(""32 characters here ..."".getBytes());
</code></pre>

<p>I am always getting a 48 bytes output but I am having a legacy system that is expecting a 32 bytes input. How could the output length be controlled ?</p>

<p>Note: I must use AES CBC</p>
"	NULL	7	NULL	30:43.8	2	46:13.1	27:19.4	NULL	1278893	1278893	0	1	1	<java><encryption><aes>	AES encryption output length	6656	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10759392	10759422	6	"<p>I would like to encrypt and decrypt a password using 128 bit AES encryption with 16 byte key.  I am getting <code>javax.crypto.BadPaddingException</code> error while decrypting the value.  Am I missing anything while decrypting?</p>

<pre><code>public static void main(String args[]) {
    Test t = new Test();
    String encrypt = new String(t.encrypt(""mypassword""));
    System.out.println(""decrypted value:"" + t.decrypt(""ThisIsASecretKey"", encrypt));
}

public String encrypt(String value) {
    try {
        byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(value.getBytes());
        System.out.println(""encrypted string:"" + (new String(encrypted)));
        return new String(skeySpec.getEncoded());
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public String decrypt(String key, String encrypted) {
    try {
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(skeySpec.getEncoded(), ""AES""));
        //getting error here
        byte[] original = cipher.doFinal(encrypted.getBytes());
        return new String(original);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}  
</code></pre>

<p>Error message</p>

<pre><code>encrypted string:?Bj?.?Ntk?F?`?
encrypted key:ThisIsASecretKey
decrypted value:null
May 25, 2012 12:54:02 PM bean.Test decrypt
SEVERE: null
javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
at javax.crypto.Cipher.doFinal(DashoA13*..)
at bean.Test.decrypt(Test.java:55)
at bean.Test.main(Test.java:24)
</code></pre>

<p><strong>Finally I am using following Solution based on @QuantumMechanic answer</strong></p>

<pre><code>public class Test {

public String encryptionKey;

public static void main(String args[]) {
    Test t = new Test();
    String encrypt = t.encrypt(""mypassword"");
    System.out.println(""decrypted value:"" + t.decrypt(t.encryptionKey, encrypt));
}

public String encrypt(String value) {
    try {
        // Get the KeyGenerator
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(256);
        // Generate the secret key specs.
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        String key = new Base64().encodeAsString(raw);
        this.encryptionKey = key;
        System.out.println(""------------------Key------------------"");
        System.out.println(key);
        System.out.println(""--------------End of Key---------------"");
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        String encrypt = (new Base64()).encodeAsString(cipher.doFinal(value.getBytes()));
        System.out.println(""encrypted string:"" + encrypt);
        return encrypt;
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public String decrypt(String key, String encrypted) {
    try {
        Key k = new SecretKeySpec(Base64.getDecoder().decode(key), ""AES"");
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, k);
        byte[] decodedValue = Base64.getDecoder().decode(encrypted);
        byte[] decValue = c.doFinal(decodedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}
</code></pre>

<p>}</p>
"	NULL	0	NULL	11:01.8	19	09:44.2	09:44.2	NULL	2683843	854108	0	1	23	<java><aes><encryption>	Java AES encryption and decryption	118099	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10782187	10782267	2	"<p>I want to encrypt image from the sd card and store it again in SD card again using AES. The main idea is the application browse an image, then encrypt it when I push a button, then store it in sd card. so my image would be secure. </p>

<p>I already succeed do string encryption using AES from this tutorial <a href=""http://www.androidsnippets.com/encryptdecrypt-strings"" rel=""noreferrer"">http://www.androidsnippets.com/encryptdecrypt-strings</a>, but I don't have idea how to do this with an image, not string.</p>

<p>This is how I do it with a string:</p>

<pre><code>public static String encrypt(String seed, String cleartext) throws Exception  
{
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes()); 
    return toHex(result);
}

private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception 
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}
</code></pre>

<p>Can anyone help me give example code how to encrypt <strong>an image</strong> with AES?</p>

<p>maybe it must using I/O file stream but I don't have an idea how to implement with this code.</p>
"	NULL	5	NULL	20:59.4	55	28:55.3	15:07.0	NULL	1816580	1421273	0	1	40	<android><file><encryption><aes>	How to encrypt file from SD card using AES in Android?	50647	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10831801	10831960	NULL	"<p>When running below programme i am getting this  exception. Not able to figure out what the issue as AES allows the 128 -256 bit key?</p>

<pre><code> Exception in thread ""main"" java.security.InvalidKeyException: Invalid AES key length: 29 bytes
at com.sun.crypto.provider.AESCipher.engineGetKeySize(DashoA13*..)
at javax.crypto.Cipher.b(DashoA13*..)
</code></pre>

<p>Getting exception at line 20</p>

<p><strong>Here is the programme</strong></p>

<pre><code> import java.security.Key;

 import javax.crypto.Cipher;
 import javax.crypto.spec.SecretKeySpec;

 import sun.misc.BASE64Decoder;
 import sun.misc.BASE64Encoder;

 public class AESEncryptionDecryptionTest {

   private static final String ALGORITHM       = ""AES"";
   private static final String myEncryptionKey = ""ThisIsSecurityKey"";
   private static final String UNICODE_FORMAT  = ""UTF8"";

   public static String encrypt(String valueToEnc) throws Exception {
 Key key = generateKey();
 Cipher c = Cipher.getInstance(ALGORITHM);
 c.init(Cipher.ENCRYPT_MODE, key);  //////////LINE 20
 byte[] encValue = c.doFinal(valueToEnc.getBytes());
 String encryptedValue = new BASE64Encoder().encode(encValue);
 return encryptedValue;
   }

public static String decrypt(String encryptedValue) throws Exception {
Key key = generateKey();
Cipher c = Cipher.getInstance(ALGORITHM);
c.init(Cipher.DECRYPT_MODE, key);
byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
byte[] decValue = c.doFinal(decordedValue);
String decryptedValue = new String(decValue);
return decryptedValue;
}

private static Key generateKey() throws Exception {
byte[] keyAsBytes;
keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
Key key = new SecretKeySpec(keyAsBytes, ALGORITHM);
return key;
}

public static void main(String[] args) throws Exception {

String value = ""password1"";
String valueEnc = AESEncryptionDecryptionTest.encrypt(value);
String valueDec = AESEncryptionDecryptionTest.decrypt(valueEnc);

System.out.println(""Plain Text : "" + value);
System.out.println(""Encrypted : "" + valueEnc);
System.out.println(""Decrypted : "" + valueDec);
}

}
</code></pre>
"	NULL	NULL	NULL	28:10.0	NULL	NULL	NULL	NULL	NULL	802050	0	1	14	<java><encryption><aes>	Getting Exception java.security.InvalidKeyException: Invalid AES key length: 29 bytes?	65055	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10842350	10843168	1	"<p>PHP Encrypt Function</p>

<pre><code>$privateKey = ""1234567812345678"";
$iv = ""1234567812345678"";
$data = ""Test string"";

$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_CBC, $iv);

echo(base64_encode($encrypted));

Result: iz1qFlQJfs6Ycp+gcc2z4w==
</code></pre>

<p>When I try to decrypt this result in Java using the function below, all I get back is ì?@ÔBKxnfÈ~¯Ô'M  while I am expecting ""Test string"". Any ideas where I am wrong? Thanks</p>

<pre><code>public static String decrypt() throws Exception{
    try{
        String Base64EncodedText = ""iz1qFlQJfs6Ycp+gcc2z4w=="";
        String decodedText = com.sun.xml.internal.messaging.saaj.util.Base64.base64Decode(Base64EncodedText);
        String key = ""1234567812345678"";
        String iv = ""1234567812345678"";

        javax.crypto.spec.SecretKeySpec keyspec = new javax.crypto.spec.SecretKeySpec(key.getBytes(), ""AES"");
        javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv.getBytes());

        javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, keyspec, ivspec);
        byte[] decrypted = cipher.doFinal(decodedText.getBytes());

        String str = new String(decrypted);

        return str;

    }catch(Exception e){
        return null;
    }   
}
</code></pre>
"	NULL	1	NULL	53:31.5	6	56:34.1	34:06.0	NULL	812120	812120	0	1	8	<java><encryption><aes>	Java AES CBC Decryption	33074	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
10936208	0	0	"<p>I am at my wits end with this problem. I am trying to implement an encrypted channel using RSA(4096) to deliver an AES 256 bit key using java (JRE7). The first message I send is the generated 256 AES key encrypted with the RSA public key. Upon decryption, I am getting the following error message: javax.crypto.BadPaddingException: Blocktype mismatch: 0</p>

<p>My decryption code:</p>

<pre><code>private byte[] decryptMessage(Key key, byte[] data){
    Cipher cipher;
    System.out.println(""Decrypting message..."");
    System.out.println(""key: "" + key.toString());
    System.out.println(""data: "" + data);
    System.out.println(""data length: "" + data.length);
    if(key instanceof PublicKey){
        //RSA public key
        System.out.println(""Found PublicKey"");
        try {
            cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key);
            return cipher.doFinal(data);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            // TODO Auto-generated catch block
            System.out.println(""Failed to decrypt message"");
            e.printStackTrace();
        }

    }else if(key instanceof PrivateKey){
        //RSA private key
        System.out.println(""Found PrivateKey"");
        try {
            cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] results = cipher.doFinal(data);
            System.out.println(""Decrypted results: "" + results);
            return results;
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            // TODO Auto-generated catch block
            System.out.println(""Failed to decrypt message"");
            e.printStackTrace();
        }
    }else if(key instanceof SecretKey){
        //AES secret key
        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key);
            return cipher.doFinal(data);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


    }else{
        System.out.println(""Invalid key type"");
    }
    return null;
}
</code></pre>

<p>My encryption code:</p>

<pre><code>private byte[] encryptMessage(Key key, byte[] data){
    Cipher cipher;
    if(key instanceof PrivateKey || key instanceof PublicKey){
        //RSA key
        try {
            cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            return cipher.doFinal(data);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            // TODO Auto-generated catch block
            System.out.println(""Failed to encrypt message"");
            e.printStackTrace();
        }


    }else if(key instanceof SecretKey){
        //AES secret key
        try {
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            return cipher.doFinal(data);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }else{
        System.out.println(""Invalid key type"");
    }
    return null;
}
</code></pre>

<p>I googled and came to some similar stories(most on this website), but they were all problems with default Padding between to different devices, computer to android for example). I am getting the error when sending messages from the same computer and I have padding and ECB both set up. I went through the source code of com.sun.crypto.provider.RSACipher and sun.security.rsa.RSAPadding and found the error is being thrown in the sun.security.rsa.RSAPadding.unpadV15 method due to the second bit not being set properly. I am also using the new NIO2 classes in Java7 specifically the AsychronousSocketChannel and CompletionHandler objects so I don't know if they are causing threading errors though I highly doubt it. I found the source code at <a href=""http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/crypto/provider/RSACipher.java"" rel=""nofollow"">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/crypto/provider/RSACipher.java</a> and http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/security/rsa/RSAPadding.java#RSAPadding.padV15%28byte[]%29 but again they didn't help me much. I have tried dropping the key size and changing the encoding/padding options of the cipher objects, but it always errors out even with padding disabled. Though it may not matter, but since I am using JRE7, there is no stable support for bouncycastle so I am using the default security provider. </p>

<p>Thanks in advance</p>
"	NULL	1	NULL	46:40.7	1	46:40.7	NULL	NULL	0	1442710	0	1	3	<java><public-key-encryption>	JRE7 RSA Cipher javax.crypto.BadPaddingException: Blocktype mismatch: 0	2384	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
11065063	11065183	2	"<p>I am trying to encrypt and decrypt some simple text. But for some reason I am getting a strange error: <code>javax.crypto.BadPaddingException</code>. Why would JCE generates bytes that are not properly padded?</p>

<p>I have the following code:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.SecureRandom;

public class SimplestTest {
    public static void main(String[] args) throws Exception {
        SecureRandom rnd = new SecureRandom();

        String text = ""Hello, my dear! ... "" + System.getProperty(""user.home"");
        byte[] textData = text.getBytes();

        IvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(16));

        KeyGenerator generator = KeyGenerator.getInstance(""AES"");
        generator.init(128);
        SecretKey k = generator.generateKey();

        Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        c.init(Cipher.ENCRYPT_MODE, k, iv);
        c.update(textData);
        byte[] data = c.doFinal();

        System.out.println(""E: "" + data.length);

        c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        c.init(Cipher.DECRYPT_MODE, k, iv);
        c.update(data);

        System.out.println(""R: "" + c.doFinal().length);
    }

}
</code></pre>

<p>But for some reason it does not work. It fails with this exception:</p>

<pre><code>E: 16
Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded
        at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
        at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
        at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
        at javax.crypto.Cipher.doFinal(DashoA13*..)
        at SimplestTest.main(SimplestTest.java:31)
</code></pre>

<p>What's going wrong? The data size is 16 bytes in length but is still ""not properly padded"" ?</p>
"	NULL	0	NULL	11:07.7	5	37:18.3	37:18.3	NULL	104223	1460833	0	1	3	<java><cryptography><aes><jce>	AES/CBC/PKCS5Padding issue	14982	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
11279903	0	3	"<p>I'm using the following in an android app and a standalone java app:</p>

<pre><code>private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    ...
</code></pre>

<p>I get different encrypted strings on android vs my standalone java app (both using the same code and key). I get the same exception (javax.crypto.BadPaddingException: Blocktype mismatch: 0) as in this question:</p>

<p><a href=""https://stackoverflow.com/questions/6069369/rsa-encryption-difference-between-java-and-android"">RSA Encryption: Difference between Java and Android</a></p>

<p>And the suggested solution is to specify the padding strategy like:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
</code></pre>

<p>but I'm using ""AES"", not ""RSA"", and am not sure how to specify the padding in combination with AES. How would I construct the string passed to Cipher.getInstance() in that case? I gave this a try:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/PKCS1Padding"");
</code></pre>

<p>but get an exception about that being invalid.</p>

<p>Thanks</p>
"	NULL	3	NULL	56:01.3	4	34:16.5	00:16.0	NULL	-1	291701	0	1	10	<java><android><encryption>	Specify Cipher.getInstance() arguments?	48819	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
11838881	11838947	1	"<p>I have translate a C# based decrypt function  into Java. It works fine and could be used to decrypted the passwords which have been encrypted by C# program.
Here is the source code:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;

public class TestDecrpt {
    public static void main(String[] args) throws Exception {
        String data = ""encrypted data"";
        String sEncryptionKey = ""encryption key"";
        byte[] rawData = new Base64().decode(data);
        byte[] salt = new byte[8];
        System.arraycopy(rawData, 0, salt, 0, salt.length);

        Rfc2898DeriveBytes keyGen = new Rfc2898DeriveBytes(sEncryptionKey, salt);

        byte[] IV = keyGen.getBytes(128 / 8);
        byte[] keyByte = keyGen.getBytes(256 / 8);

        Key key = new SecretKeySpec(keyByte, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV));
        int pureDataLength = rawData.length - 8;
        byte[] pureData = new byte[pureDataLength];
        System.arraycopy(rawData, 8, pureData, 0, pureDataLength);
        String plaintext = new String(cipher.doFinal(pureData), ""UTF-8"").replaceAll(""\u0000"", """");
        System.out.println(plaintext);
    }
}
</code></pre>

<p>I follow its algorithm to write the encrypt function. And codes is:</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;
import java.security.SecureRandom;


public class testEncrypt {
    public static void main(String[] args) throws Exception {
        String data = ""Welcome2012~1@Welcome2012~1@Welcome2012~1@Welcome2012~1@Welcome2012~1@"";
        String sEncryptionKey = ""encryption key""; # the same key
        byte[] rawData = new Base64().decode(data);
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[8];
        random.nextBytes(salt);
        Rfc2898DeriveBytes keyGen = new Rfc2898DeriveBytes(sEncryptionKey, salt);

        byte[] IV = keyGen.getBytes(128 / 8);
        byte[] keyByte = keyGen.getBytes(256 / 8);

        Key key = new SecretKeySpec(keyByte, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV));
        byte[] out2 = cipher.doFinal(rawData);

        byte[] out = new byte[8 + out2.length];
        System.arraycopy(salt, 0, out, 0, 8);
        System.arraycopy(out2, 0, out, 8, out2.length);
        //String outStr=new String(out,""UTF-8"");
        String outStr = new Base64().encodeToString(out);
        System.out.println(outStr);
        System.out.print(outStr.length());

    }
}
</code></pre>

<p>However, the encrypted data could not be decrypted correctly, it always return garbage codes, such as </p>

<blockquote>
  <p>???????????????????????</p>
</blockquote>

<p>Is there something wrong with the encrypt function?</p>

<p>================================================================================
[Update]
After changing the code to</p>

<pre><code>byte[] rawData = data.getBytes(""UTF-8"");
</code></pre>

<p>The data could be encrypted and decrypted successfully. 
However, the data which is encrypted in Java could not be correctly descrypted in C#.
Here is the C# version decrypt function:</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;


namespace Test
{
    class Program
    {
        public static void Main(string[] args)
        {
                string data=""EncryptedData"";
                string sEncryptionKey=""EncryptionKey"";

                byte[] rawData = Convert.FromBase64String(data);
                byte[] salt = new byte[8];
                for (int i = 0; i &lt; salt.Length; i++)
                    salt[i] = rawData[i];

                Rfc2898DeriveBytes keyGenerator = new Rfc2898DeriveBytes(sEncryptionKey, salt);
                Rijndael aes = Rijndael.Create();
                aes.IV = keyGenerator.GetBytes(aes.BlockSize / 8);
                aes.Key = keyGenerator.GetBytes(aes.KeySize / 8);

                using (MemoryStream memoryStream = new MemoryStream())
                using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cryptoStream.Write(rawData, 8, rawData.Length - 8);
                    cryptoStream.Close();

                    byte[] decrypted = memoryStream.ToArray();
                    Console.Out.WriteLine(Encoding.Unicode.GetString(decrypted));
                    Console.In.ReadLine();
                }

        }
    }
}
</code></pre>

<p>I find that the original code are using ""Unicode"" as output format,</p>

<pre><code>Encoding.Unicode.GetString(decrypted)
</code></pre>

<p>so I change my Java code to ""Unicode"".</p>

<p>For Decrypt in Java:</p>

<pre><code>String plaintext = new String(cipher.doFinal(pureData), ""Unicode"");
System.out.println(plaintext);
</code></pre>

<p>For Encrypt in Java:</p>

<pre><code>byte[] rawData = data.getBytes(""Unicode"");
</code></pre>

<p>But using the C# code to decrypt the data which has been encrypted by the Java program still meet garbage codes.</p>

<p>How could I fix this issue? Is there any magical trick?</p>

<hr>

<p>[Last Update]
After using ""UTF-16LE"" instead of ""UTF-8"", the issue has gone. It seems that ""UTF-16LE"" is the Java equivalent to the ""Unicode"" of C#.</p>
"	NULL	1	NULL	33:50.0	3	38:26.1	38:26.1	NULL	258938	258938	0	1	1	<java><base64><apache-commons><encryption>	Why does decryption function return garbage codes?	2680	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
11953053	11955802	1	"<p>First thing first. Some time ago I needed a simple AES encryption in Android to encrypt a password and send it as a parameter for a .net web service where the password was decrypted.</p>

<p>The following is my Android encryption:</p>

<pre><code>    private static String Encrypt(String text, String key)
        throws Exception {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] keyBytes= new byte[16];
        byte[] b= key.getBytes(""UTF-8"");
        int len= b.length;
        if (len &gt; keyBytes.length) len = keyBytes.length;
        System.arraycopy(b, 0, keyBytes, 0, len);
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
        cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);

        byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
        String result = Base64.encodeBytes(results);
        return result;
        }
</code></pre>

<p>And then I decrypted it in C# with:</p>

<pre><code>        public static string Decrypt(string textToDecrypt, string key)
    {
        System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();

        RijndaelManaged rijndaelCipher = new RijndaelManaged();
        rijndaelCipher.Mode = CipherMode.CBC;
        rijndaelCipher.Padding = PaddingMode.PKCS7;

        rijndaelCipher.KeySize = 0x80;
        rijndaelCipher.BlockSize = 0x80;

        string decodedUrl = HttpUtility.UrlDecode(textToDecrypt);
        byte[] encryptedData = Convert.FromBase64String(decodedUrl);
        byte[] pwdBytes = Encoding.UTF8.GetBytes(key);
        byte[] keyBytes = new byte[0x10];
        int len = pwdBytes.Length;
        if (len &gt; keyBytes.Length)
        {
            len = keyBytes.Length;
        }
        Array.Copy(pwdBytes, keyBytes, len);
        rijndaelCipher.Key = keyBytes;
        rijndaelCipher.IV = keyBytes;
        byte[] plainText = rijndaelCipher.CreateDecryptor().TransformFinalBlock(encryptedData, 0, encryptedData.Length);
        return encoding.GetString(plainText);
    }
</code></pre>

<p>This worked like a charm, but the problems came when I tried to do the same in iOS. I am pretty new developing applications for the iphone/ipad, so ofcause I googled it, and almost every code sample provided was the following:</p>

<pre><code>- (NSData *)AESEncryptionWithKey:(NSString *)key {
char keyPtr[kCCKeySizeAES128]; // room for terminator (unused)
bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)

// fetch key data
[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];

NSUInteger dataLength = [self length];

size_t bufferSize = dataLength + kCCBlockSizeAES128;
void *buffer = malloc(bufferSize);

size_t numBytesEncrypted = 0;

CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                      keyPtr, kCCKeySizeAES128,
                                      NULL /* initialization vector (optional) */,
                                      [self bytes], [self length], /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);
if (cryptStatus == kCCSuccess) {
    //the returned NSData takes ownership of the buffer and will free it on deallocation
    return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
}

free(buffer); //free the buffer;
return nil;
</code></pre>

<p>}</p>

<p>Maybe I was a little bit too optimistic, when I was hoping for a smooth transition here, because when the Android is throwing me something like:</p>

<p><code>""EgQVKvCLS4VKLoR0xEGexA==""</code></p>

<p>then the iOS gives me:</p>

<pre><code>""yP42c9gajUra7n0zSEuVJQ==""
</code></pre>

<p>Hopefully it is just something I forgot, or some of the settings are wrong?</p>

<p>[UPDATE] The results are now showed after the base64 encoding.</p>
"	NULL	6	NULL	12:46.4	7	00:42.6	00:42.6	NULL	991085	1090434	0	1	13	<c#><android><ios><aes>	"AES encryption in iOS and Android, and decryption in C#.NET"	9972	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
12607937	13458949	2	"<p>I really really.... really need help...........</p>

<p><strong>-UPDATED-</strong></p>

<p>I need help because my java function gives me a different result compared with the iOS 3DES function. I posted the code from both ios and java; and results when specified plaintext is ""tutor.1"" and MD5 key is ""spO13+QLZCRAe93pIXMXLg=="" (MD5, clearly, is the same for both).</p>

<p><strong>JAVA 3DES</strong> (short and simple)</p>

<pre><code>public static String encrypt(String plaintext, String enctoken){

    if(enctoken == null)
        enctoken = ""sfdjf48mdfdf3054"";

    String encrypted = null; 

    byte[] plaintextByte = EncodingUtils.getBytes(plaintext,""UTF-8"");

    byte[] hash = Connessione.md5(enctoken);

    Log.i(""ENCRYPT"", ""MD5: ""+Base64.encodeToString(hash, 0));

    try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(hash,""DESede"");

        cipher.init(Cipher.ENCRYPT_MODE, myKey); 

        try {
            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0);

            Log.i(""ENCRYPT"", ""Pwd encrypted: ""+encrypted);

            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       

    return """";
}
</code></pre>

<p>result: <em>R4mXAaHcFxM=</em></p>

<p><strong>IOS 3DES - UPDATED AGAIN</strong></p>

<pre><code>// key value in parameters is MD5 value! It is the same for both version

+ (NSString *) encrypt:(NSString *) dataToEncrypt withKey:(NSString*) key{    


NSData *data = [dataToEncrypt dataUsingEncoding:NSUTF8StringEncoding];
NSData *mData = [key dataUsingEncoding:NSUTF8StringEncoding];

CCCryptorStatus ccStatus = kCCSuccess;


// Begin to calculate bytesNeeded....
size_t bytesNeeded = 0;

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   NULL,
                   0,
                   &amp;bytesNeeded);

if(kCCBufferTooSmall != ccStatus){

    NSLog(@""Here it must return BUFFER TOO SMALL !!"");
    return nil;
}

// .....End
// Now i do the real Crypting

char* cypherBytes = malloc(bytesNeeded);
size_t bufferLength = bytesNeeded;

if(NULL == cypherBytes)
    NSLog(@""cypherBytes NULL"");

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   cypherBytes,
                   bufferLength,
                   &amp;bytesNeeded);

if(kCCSuccess != ccStatus){
    NSLog(@""kCCSuccess NO!"");
    return nil;
}

return [Base64 encode:[NSData dataWithBytes:cypherBytes length:bufferLength]]; 
</code></pre>

<p>}</p>

<p>result: <em>YBAva5J2khY=</em></p>

<p>I need iOS version returns same result as the Java version.</p>

<p>I found the Base64 class here: <a href=""http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php"" rel=""nofollow"">http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php</a></p>

<p>What i'm doing wrong ?</p>

<p>Thx for your help and time</p>
"	NULL	14	NULL	15:54.7	2	36:30.6	49:18.6	NULL	736196	736196	0	1	0	<java><ios><algorithm><encryption><3des>	3DES result in Java produces different result from 3DES iOS version	2969	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13248851	13253598	2	"<p>I implement this via java , BouncyCastle Provider
use Block mode = ECB and Padding mode = PKCS7Padding</p>

<p>I noticte that if i encrypt data that has 32 byte length(such as 61626162616261626162616261626162 which is hex value of abababababababab) i get 64 bytes length cipher text(f21ee0564ebd5274e10bf4590594b1e16a19592b917b19ee106f71d41d165289) is this cipher text valid? from what i read it look like if you encrypt less than 32 byte length data the algorithm will padding it to 32 byte length and produce a 32 byte length cipher text but if you put in exactly 32 byte length data shouldn't you receive the 32 byte length cipher text ,also if i put in data with more length than 32 byte it will padded to 64 byte cipher text correctly</p>

<p>this is what my code look like :</p>

<pre><code>    public static byte[] encrypt(byte[] plainText, byte[] keyBytes)
        throws GeneralSecurityException {

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");
    cipher.init(Cipher.ENCRYPT_MODE, key);

    byte[] cipherText = cipher.doFinal(plainText);

    return cipherText;
}
</code></pre>

<p>thx for your reply</p>
"	NULL	0	NULL	15:47.0	2	25:14.7	NULL	NULL	0	1560335	0	1	0	<java><security><encryption><bouncycastle>	"I encrypt data with 32 byte length using AES algorithm the result(cipher text) is 64 byte length,Is this valid?"	5916	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13308957	0	6	"<p>I am trying to encrypt some text using the AES algorithm on both the Android and IPhone platforms. My problem is, even using the same encryption/decryption algorithm (AES-128) and same fixed variables (key, IV, mode), I get different result on both platforms. I am including code samples from both platforms, that I am using to test the encryption/decryption. I would appreciate some help in determining what I am doing wrong.</p>

<ul>
<li>Key: 123456789abcdefg</li>
<li>IV: 1111111111111111</li>
<li>Plain Text: HelloThere</li>
<li>Mode: AES/CBC/NoPadding</li>
</ul>

<p><strong>Android Code:</strong></p>

<pre><code>public class Crypto {
    private final static String HEX = ""0123456789ABCDEF"";

    public static String encrypt(String seed, String cleartext)
            throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted)
            throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""CBC"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted)
            throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
                    16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";

        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }

        return result.toString();
    }

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }
}
</code></pre>

<p><strong>IPhone (Objective-C) Code:</strong></p>

<pre><code>- (NSData *) transform:(CCOperation) encryptOrDecrypt data:(NSData *) inputData { 

    NSData* secretKey = [Cipher md5:cipherKey];

    CCCryptorRef cryptor = NULL;
    CCCryptorStatus status = kCCSuccess;

    uint8_t iv[kCCBlockSizeAES128];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    status = CCCryptorCreate(encryptOrDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                         [secretKey bytes], kCCKeySizeAES128, iv, &amp;cryptor);

    if (status != kCCSuccess) {
        return nil;
    }

    size_t bufsize = CCCryptorGetOutputLength(cryptor, (size_t)[inputData length], true);

    void * buf = malloc(bufsize * sizeof(uint8_t));
    memset(buf, 0x0, bufsize);

    size_t bufused = 0;
    size_t bytesTotal = 0;

    status = CCCryptorUpdate(cryptor, [inputData bytes], (size_t)[inputData length],
                         buf, bufsize, &amp;bufused);

    if (status != kCCSuccess) {
        free(buf);
        CCCryptorRelease(cryptor);
        return nil;
    }

    bytesTotal += bufused;

    status = CCCryptorFinal(cryptor, buf + bufused, bufsize - bufused, &amp;bufused);

    if (status != kCCSuccess) {
        free(buf);
        CCCryptorRelease(cryptor);
        return nil;
    }

    bytesTotal += bufused;

    CCCryptorRelease(cryptor);

    return [NSData dataWithBytesNoCopy:buf length:bytesTotal];
}

+ (NSData *) md5:(NSString *) stringToHash {

    const char *src = [stringToHash UTF8String];

    unsigned char result[CC_MD5_DIGEST_LENGTH];

    CC_MD5(src, strlen(src), result);

    return [NSData dataWithBytes:result length:CC_MD5_DIGEST_LENGTH];
}
</code></pre>

<p>Some of my references :</p>

<ul>
<li><a href=""http://code.google.com/p/aes-encryption-samples/wiki/HowToEncryptWithJava"" rel=""noreferrer"">http://code.google.com/p/aes-encryption-samples/wiki/HowToEncryptWithJava</a></li>
<li><a href=""http://automagical.rationalmind.net/2009/02/12/aes-interoperability-between-net-and-iphone/"" rel=""noreferrer"">http://automagical.rationalmind.net/2009/02/12/aes-interoperability-between-net-and-iphone/</a></li>
<li><a href=""https://stackoverflow.com/questions/538435/aes-interoperability-between-net-and-iphone/"">AES interoperability between .Net and iPhone?</a></li>
</ul>
"	NULL	4	NULL	26:12.6	9	28:28.4	33:15.4	NULL	-1	1812264	0	1	15	<java><android><iphone><encryption><aes>	Encryption using AES-128 in Android and IPhone (Different result)	34483	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13389870	13409628	2	"<p>It's my first time asking for help in here, my department (a Government), have published some app on the market (Google Play), and the encryption and description was working really well up to yesterday when I got the Jelly Bean 4.2 on my Nexus. 
The encrypt works fine, it's in fact encrypt the information to be stored. Though when decrypt it, I'm getting an exception exactly like this : <strong>pad block corrupted</strong>.
I've checked the string and it's consistent with it on others devices (using the same key for test purposes), meaning it's exactly the same.
The problem is that we need keep the back compatibility with previous versions, meaning that if I change something in the code, it's should be able to read the old encrypted information. The encrypted information it's stored on SQLite, due that I need encode it to Base64. The exception happen on this line <strong>byte[] decrypted = cipher.doFinal(encrypted);</strong></p>

<p>Here is my class:</p>

<pre><code>import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;

public class EncodeDecodeAES {

    private final static String HEX = ""0123456789ABCDEF"";

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        String fromHex = toHex(result);
        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));
        return base64;
    }


    public static String decrypt(String seed, String encrypted) throws Exception {
        String base64 = new String(Base64.decode(encrypted, 0));
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(base64);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }


    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext);
        return result;
    }


    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = decrypt(rawKey, encrypted);
        return result;
    }



    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        try {
            kgen.init(256, sr);
        } catch (Exception e) {
    //      Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");
            try {
                kgen.init(192, sr);
            } catch (Exception e1) {
    //          Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");
                kgen.init(128, sr);
            }
        }
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }


    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }


    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }


    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }


    public static byte[] toByte(String hexString) {
        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        return result;
    }


    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }


    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }

}
</code></pre>

<p>I would like to know (if somebody help me), what 'm I doing wrong with this code, or if it's a issue with Android 4.2 and if it's a issue with 4.2 if has any workaround?</p>

<p>Thank you</p>
"	NULL	6	NULL	39:21.4	12	04:18.1	01:25.0	NULL	1438733	1787243	0	1	14	<android><aes>	Android 4.2 broke my AES encrypt/decrypt code	13013	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13419702	13420533	1	"<p>I am trying to convert a BouncyCastle specific implementation to a generic one, but as I am still struggling with the basics, I have it hard to do.</p>

<p>This is the previous BC code that works:</p>

<pre><code>public int decrypt(SecurityToken token, byte[] dataToDecrypt, int inputOffset, 
      int inputLength, byte[] output, int outputOffset) {
  // Make new RijndaelEngine
  RijndaelEngine engine = new RijndaelEngine(128);

  // Make CBC blockcipher
  BufferedBlockCipher bbc = new BufferedBlockCipher(
      new CBCBlockCipher(engine));

  // find right decryption key and right initialization vector
  KeyParameter secret = new KeyParameter(
      token.getRemoteEncryptingKey());
  byte[] iv = token.getRemoteInitializationVector();

  // initialize cipher for decryption purposes
  bbc.init(false, new ParametersWithIV(secret, iv));
  decryptedBytes = bbc.processBytes(dataToDecrypt, inputOffset,
      inputLength, output, outputOffset);

  decryptedBytes += bbc.doFinal(output, outputOffset+decryptedBytes);
  return decryptedBytes;
}
</code></pre>

<p>and this is my humble try so far:</p>

<pre><code>SecretKeySpec spec = new SecretKeySpec(
    token.getRemoteEncryptingKey(),
    ""AES"");

cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, spec, new IvParameterSpec(token.getRemoteInitializationVector()));
decryptedBytes = cipher.update(dataToDecrypt, inputOffset,
    inputLength, output, outputOffset);
decryptedBytes += cipher.doFinal(output, outputOffset+decryptedBytes);
return decryptedBytes;
</code></pre>

<p>which gives</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
</code></pre>

<p>and here is input to the function:</p>

<pre><code>decrypt: dataToDecrypt.length=1088 inputOffset=0 inputLength=1088 output.length=16384 outputOffset=1180
decrypt: token.getRemoteEncryptingKey()=lBjgFjfR3IilCyT5AqRnXQ==
decrypt: token.getRemoteInitializationVector()=0JFEdkuW6pMo0cwfKdZa3w==
</code></pre>

<p>What am I missing?</p>

<p>E: input data</p>
"	NULL	0	NULL	36:53.4	3	27:43.0	20:10.3	NULL	474189	1282835	0	1	2	<java><security><aes>	Java AES block decryption using key and iv	1318	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13467343	13508295	1	"<p>I am using AES 256 CBC. I have 32 bytes of IV. But when i run this it shows an exception as:</p>

<pre><code>Exception in thread ""main"" java.lang.RuntimeException: java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long
    at com.abc.aes265cbc.AESUtil.decrypt(AESUtil.java:50)
    at com.abc.aes265cbc.Security.main(Security.java:48)
Caused by: java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:430)
    at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:217)
    at javax.crypto.Cipher.implInit(Cipher.java:790)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:848)
    at javax.crypto.Cipher.init(Cipher.java:1347)
    at javax.crypto.Cipher.init(Cipher.java:1281)
    at com.abc.aes265cbc.AESUtil.decrypt(AESUtil.java:47)
    ... 1 more
</code></pre>

<p>I don't know how to solve this. I searched but I am not getting how to solve this. I am trying security concepts for the first time.
My code for the AES 256 CBC is:</p>

<pre><code> public static void setENCRYPTION_IV(String ENCRYPTION_IV) {
        AESUtil.ENCRYPTION_IV  =   ENCRYPTION_IV;
    }

    public static void setENCRYPTION_KEY(String ENCRYPTION_KEY) {
        AESUtil.ENCRYPTION_KEY  =   ENCRYPTION_KEY;
    }



    public static String encrypt(String src) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, makeKey(), makeIv());
            return Base64.encodeBytes(cipher.doFinal(src.getBytes()));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static String decrypt(String src) {
        String decrypted = """";
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, makeKey(), makeIv());
            decrypted = new String(cipher.doFinal(Base64.decode(src)));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return decrypted;
    }

    static AlgorithmParameterSpec makeIv() {
        try {
            return new IvParameterSpec(ENCRYPTION_IV.getBytes(""UTF-8""));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return null;
    }

    static Key makeKey() {
        try {
            MessageDigest md = MessageDigest.getInstance(""SHA-256"");
            byte[] key = md.digest(ENCRYPTION_KEY.getBytes(""UTF-8""));
            return new SecretKeySpec(key, ""AES"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return null;
    }
</code></pre>

<p>Can you help me that by changing what in this code i will be able to use 32 bytes of IV.
Thanks in advance</p>

<p>Edit:
My main function to which calls this functions:</p>

<pre><code> AESUtil.setENCRYPTION_KEY(""96161d7958c29a943a6537901ff0e913efaad15bd5e7c566f047412179504ffb"");

    AESUtil.setENCRYPTION_IV(""d41361ed2399251f535e65f84a8f1c57"");
    String decrypted = AESUtil.decrypt(new String(sw0SrUIKe0DmS7sRd9+XMgtYg+BUiAfiOsdMw/Lo2RA=));   // AES Decrypt
</code></pre>
"	NULL	3	NULL	54:28.9	3	10:37.9	58:33.1	NULL	1690573	1690573	0	1	6	<java><security><aes>	Want to use AES 256 CBC with 32 bytes but it shows java.security.InvalidAlgorithmParameterException	16756	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
13782798	13784098	1	"<p>Can you please show me how can I use AES with CFB mode (so that the size of input (plain text) and out (encrypted text) remains same. I've tried replacing AES with AES/CFB/NoPadding but its not working. The Application crashes. 
I am using the following code. Please help me to make it work for AES with CFB. Thanks</p>

<p>public class SimpleCrypto {</p>

<pre><code>public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}


private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt) {
    return toHex(txt.getBytes());
}
public static String fromHex(String hex) {
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
    return result;
}

public static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2*buf.length);
    for (int i = 0; i &lt; buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
}
</code></pre>

<p>}</p>
"	NULL	2	NULL	57:40.8	4	30:52.4	NULL	NULL	0	1888567	0	1	7	<java><android><aes>	using AES with CFB mode	9523	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
14936809	14936912	1	"<p>I got this code from <a href=""http://www.ravenblast.com/index.php/blog/android-password-text-encryption/"" rel=""nofollow"">http://www.ravenblast.com/index.php/blog/android-password-text-encryption/</a> and, although it works, I have a growing suspicion it's not secure enough. There isn't any initialization vector which seems to be necessary according other sources.</p>

<pre><code>public static String encrypt(String toEncrypt, byte[ ] key) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[ ] encryptedBytes = cipher.doFinal(toEncrypt.getBytes());
    String encrypted = Base64.encodeBytes(encryptedBytes);
    return encrypted;
}

public static String decrypt(String encryptedText, byte[ ] key) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] toDecrypt = Base64.decode(encryptedText);
    byte[] encrypted = cipher.doFinal(toDecrypt);
    return new String(encrypted);
}
</code></pre>
"	NULL	2	NULL	52:09.5	4	44:26.5	44:26.5	NULL	445517	2083242	0	1	6	<java><security><encryption><aes><block-cipher>	Is this AES encryption secure enough?	464	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15153395	15153820	2	"<p>I am getting  java.security.InvalidKeyException: Illegal key size or default parameters , I have fallow all the required step ,Installed  Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.
Also I have Gone through these Threads</p>

<p><a href=""http://www.coderanch.com/t/521137/Security/java-security-InvalidKeyException-Illegal-key"" rel=""nofollow noreferrer"">Java.security.InvalidKeyException: Illegal key size or default parameters error</a></p>

<p><a href=""https://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters"">Java Security: Illegal key size or default parameters?</a></p>

<p>But I am still stuck and getting  java.security.InvalidKeyException: Illegal key size or default parameters ,</p>

<p>Below is My Code :
AESKeyGenerator.java</p>

<pre><code>public class AESKeyGenerator {

    private Cipher mCipher;

    public AESKeyGenerator()
    {
        // default constructor
    }


    public byte[] generate_k(String dhkey, String toEncrypt)
    {
        byte[] retVal;

        try { // Set up the Cipher class of Android to use AES to generate keys
            byte[] iv = new byte[16];
            for (int i = 0; i &lt; iv.length; i++)
                iv[i] = new Byte(""0"").byteValue();
            IvParameterSpec ivspec = new IvParameterSpec(iv);
            mCipher = Cipher.getInstance(""AES"");
            // Set up key to use in algorithm
            MessageDigest hasher = MessageDigest.getInstance(""SHA-256""); // Initialize object that will hash my key.
            byte[] key256 = hasher.digest(dhkey.getBytes()); // Hash the key to 256 bits using SHA
            SecretKeySpec K = new SecretKeySpec(key256, ""AES"");
            System.out.println(""SecretKeySpec : ""+K  + ""  key256 ""+key256);
            mCipher.init(Cipher.ENCRYPT_MODE, K, ivspec);
            // Encrypt the parameter toEncrypt
            retVal = mCipher.doFinal(toEncrypt.getBytes());
            return retVal;
        }
        catch (Exception e) {
                        e.printStackTrace();
            System.err.println(""Could not create and initialize object Cipher."");
        }

        return null;

    }

    public byte[] generate_r(byte[] sharedKey, String toEncrypt)
    {
        byte[] retVal;
        try {
            /*byte[] iv = new byte[16];
            for (int i = 0; i &lt; iv.length; i++)
                iv[i] = new Byte(""0"").byteValue();
            IvParameterSpec ivspec = new IvParameterSpec(iv);*/

            // Set up the Cipher class of Android to use AES to generate keys
            mCipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            // Set up key to use in algorithm
            MessageDigest hasher = MessageDigest.getInstance(""SHA-256""); // Initialize object that will hash my key.
            byte[] key256 = hasher.digest(sharedKey); // Hash the key to 256 bits using SHA 256
            SecretKeySpec K = new SecretKeySpec(key256, ""AES"");
            mCipher.init(Cipher.ENCRYPT_MODE, K);
            // Encrypt the parameter toEncrypt
            System.out.println(""toEncrypt AES: ""+ toEncrypt);
            retVal = mCipher.doFinal(toEncrypt.getBytes());
            return retVal;
        }
        catch (Exception e) {
                        e.printStackTrace();
            System.err.println(""exception: ""+ e.toString());
            System.err.println(""Could not create and initialize object Cipher."");
        }

        return null;

    }
}
</code></pre>

<p><strong>I am getting fallowing error:</strong></p>

<pre><code>java.security.InvalidKeyException: Illegal key size or default parameters
  at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1010)
  at javax.crypto.Cipher.implInit(Cipher.java:785)
  at javax.crypto.Cipher.chooseProvider(Cipher.java:848)
  at javax.crypto.Cipher.init(Cipher.java:1212)
  at javax.crypto.Cipher.init(Cipher.java:1152)
  at AESKeyGenerator.generate_r(AESKeyGenerator.java:74)
  at DetectionServer.storeGridInformation(DetectionServer.java:309)
  at DetectionServer.doPost(DetectionServer.java:103)
  at javax.servlet.http.HttpServlet.service(HttpServlet.java:641)
  at javax.servlet.http.HttpServlet.service(HttpServlet.java:722)
  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:304)
  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)
  at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:240)
  at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:164)
  at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:462)
  at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:164)
  at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100)
  at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:562)
  at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)
  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:395)
  at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:250)
  at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:188)
  at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:302)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
  at java.lang.Thread.run(Unknown Source)
exception: java.security.InvalidKeyException: Illegal key size or default parameters
Could not create and initialize object Cipher.
</code></pre>

<p>I check with the standard code which is also same as this. I think there is some issue with configuration or missing library.</p>
"	NULL	1	NULL	22:16.8	3	54:37.0	15:38.6	NULL	-1	2122565	0	1	7	<java><security><cryptography><aes><public-key-encryption>	Please Help-Stuck Invalid Key Exception	9162	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15158089	0	2	"<p>In Android/java app,</p>

<pre><code>byte[] data = "":Êº$jhk¨ëòºÃ""; // fetched from php server..
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.DECRYPT_MODE, mKeyspec);
return new String(cipher.doFinal(data));
</code></pre>

<p>The above code always throws <code>BadPaddingException: pad block corrupted</code> for following 16 byte encypted data   </p>

<blockquote>
  <p>data = "":Êº$jhk¨ëòºÃ"" (the data is 16 chars)</p>
</blockquote>

<p>The key is 16 bytes long.</p>

<p>Why does it throw this exception when the data is already the size of a block.? and no padding is needed.</p>

<p>Note: The encrypted data is fetched from a php server.  </p>

<h2>Edit:</h2>

<p>After changing to<br>
<code>Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");</code><br>
from<br>
<code>Cipher cipher = Cipher.getInstance(""AES"");</code></p>

<p>the decrypt method succeeds, but gives this output
<img src=""https://i.stack.imgur.com/cBUOU.png"" alt=""enter image description here""></p>
"	NULL	15	NULL	44:12.9	5	46:17.4	46:17.4	NULL	1033581	857361	0	1	5	<java><android><aes><badpaddingexception>	'BadPaddingException: pad block corrupted' while decrypting using AES/ECB	24213	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15390479	15391882	3	"<p>I'm trying to implement AES128 encryption on an Android.  I've got a solution working on an iPhone with Objective C but having trouble porting it to Android.  I've searched stackoverflow for a solution, but I seem to be doing something wrong.  I'm fairly new to Java so I think I'm missing something to do with data, string conversion.</p>

<p>Here is my iPhone encrypt:</p>

<pre><code>char keyPtr[kCCKeySizeAES128+1];
[keyString getCString:keyPtr
            maxLength:sizeof(keyPtr)
             encoding:NSASCIIStringEncoding];

// CString for the plain text
char plainBytes[[plainString length]+1];
[plainString getCString:plainBytes
              maxLength:sizeof(plainBytes)
               encoding:NSASCIIStringEncoding];

size_t bytesEncrypted = 0;

// Allocate the space for encrypted data
NSUInteger dataLength = [plainString length];
size_t bufferSize = dataLength + kCCBlockSizeAES128;
void* buffer = malloc(bufferSize);

// Encrypt
CCCryptorStatus ret = CCCrypt(kCCEncrypt,
                              kCCAlgorithmAES128,
                              kCCOptionPKCS7Padding | kCCOptionECBMode,
                              keyPtr,
                              kCCKeySizeAES128,
                              NULL,
                              plainBytes, sizeof(plainBytes),
                              buffer, bufferSize,
                              &amp;bytesEncrypted);
if (ret != kCCSuccess) {
    free(buffer);
}

encryptedData = [NSData dataWithBytes:buffer length:bytesEncrypted];
</code></pre>

<p>Here is my Java:</p>

<pre><code>    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""UTF-8""));
</code></pre>

<p>Using the same key and plaintext in iPhone and Java give different results.  My iPhone result works the way I need it so I'm trying to get java to give me the iPhone result.  I'm missing something in the Java for sure, just not sure what it is.</p>

<p><em><strong>edit</em></strong></p>

<p>based on suggestions below I modified my Java to this</p>

<pre><code>    byte[] keyBytes = plainTextKey.getBytes(""US-ASCII"");
    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""US-ASCII""));
</code></pre>

<p>but I'm still getting different results between android and iPhone</p>
"	NULL	4	NULL	06:30.3	5	31:36.7	27:26.1	NULL	2063149	2063149	0	1	6	<android><iphone><encryption><aes>	Android AES 128 encryption	2408	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15554296	22445878	10	"<p>What's wrong with the following example?</p>

<p>The problem is that the first part of the decrypted string is nonsense. However, the rest is fine, I get...</p>

<blockquote>
<pre><code>Result: `£eB6O?geS??i are you? Have a nice day.
</code></pre>
</blockquote>

<pre><code>@Test
public void testEncrypt() {
  try {
    String s = ""Hello there. How are you? Have a nice day."";

    // Generate key
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    kgen.init(128);
    SecretKey aesKey = kgen.generateKey();

    // Encrypt cipher
    Cipher encryptCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    encryptCipher.init(Cipher.ENCRYPT_MODE, aesKey);

    // Encrypt
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, encryptCipher);
    cipherOutputStream.write(s.getBytes());
    cipherOutputStream.flush();
    cipherOutputStream.close();
    byte[] encryptedBytes = outputStream.toByteArray();

    // Decrypt cipher
    Cipher decryptCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    IvParameterSpec ivParameterSpec = new IvParameterSpec(aesKey.getEncoded());
    decryptCipher.init(Cipher.DECRYPT_MODE, aesKey, ivParameterSpec);

    // Decrypt
    outputStream = new ByteArrayOutputStream();
    ByteArrayInputStream inStream = new ByteArrayInputStream(encryptedBytes);
    CipherInputStream cipherInputStream = new CipherInputStream(inStream, decryptCipher);
    byte[] buf = new byte[1024];
    int bytesRead;
    while ((bytesRead = cipherInputStream.read(buf)) &gt;= 0) {
        outputStream.write(buf, 0, bytesRead);
    }

    System.out.println(""Result: "" + new String(outputStream.toByteArray()));

  } 
  catch (Exception ex) {
    ex.printStackTrace();
  }
}
</code></pre>
"	NULL	10	NULL	31:51.3	113	47:01.2	45:32.8	NULL	589259	210713	0	1	118	<java><encryption><aes>	Initial bytes incorrect after Java AES/CBC decryption	483126	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15622924	15638246	2	"<p>I need help with this error: Given final block not properly padded. As you can see from the title, I am working with AES.</p>

<p>Here is the code of line where is error:</p>

<pre><code> byte[] decrypted = cipher.doFinal(bytes);
</code></pre>

<p>Here is the full code:</p>

<pre><code>public class AESCrypt {
private final Cipher cipher;
private final SecretKeySpec key;
private String encryptedText, decryptedText;

public AESCrypt(String password) throws Exception {
    // hash password with SHA-256 and crop the output to 128-bit for key
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[16];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
}

public String encrypt(String plainText) throws Exception {
    byte[] iv = new byte[cipher.getBlockSize()];
    new SecureRandom().nextBytes(iv);
    AlgorithmParameterSpec spec = new IvParameterSpec(iv);
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes());
    encryptedText = asHex(encrypted);
    return encryptedText;
}

public String decrypt(String cryptedText) throws Exception {
    byte[] iv = new byte[cipher.getBlockSize()];
    AlgorithmParameterSpec spec = new IvParameterSpec(iv);
    cipher.init(Cipher.DECRYPT_MODE, key, spec);
    // decrypt the message
    byte[] bytes = cryptedText.getBytes(""UTF-8"");
    byte[] decrypted = cipher.doFinal(bytes);
    decryptedText = asHex(decrypted);
    System.out.println(""Desifrovani tekst: "" + decryptedText + ""\n"");

    return decryptedText;
}

public static String asHex(byte buf[]) {
    StringBuilder strbuf = new StringBuilder(buf.length * 2);
    int i;
    for (i = 0; i &lt; buf.length; i++) {
        if (((int) buf[i] &amp; 0xff) &lt; 0x10) {
            strbuf.append(""0"");
        }
        strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
    }
    return strbuf.toString();
}

public static void main(String[] args) throws Exception {

    System.out.print(""....AES....\n"");

    String message = ""MESSAGE"";
    String password = ""PASSWORD"";

    System.out.println(""MSG:"" + message);

    AESCrypt aes = new AESCrypt(password);
    String encryptedText = aes.encrypt(message).toString();
    System.out.println(""SIFROVANA PORUKA: "" + encryptedText);
    String decryptedText = aes.decrypt(encryptedText).toString();       
    System.out.print(""DESIFROVANA PORUKA: "" + decryptedText);
}
</code></pre>

<p>}</p>
"	NULL	8	NULL	16:58.3	4	55:44.2	NULL	NULL	0	955836	0	1	1	<java><cryptography><aes>	AES Error: Given final block not properly padded	23648	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15880901	15882476	2	"<p>I'm using a very standard way of Java AES encryption / decryption.</p>

<pre><code>byte[] key = hexStringToByteArray(""C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF"");

byte[] message = hexStringToByteArray(""01A0A1A2A3A4A5A6A703020100060001"");

SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

// Instantiate the cipher
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

byte[] encrypted = cipher.doFinal(message);

cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
byte[] original = cipher.doFinal(encrypted);
</code></pre>

<p>As you can see I'm using 128 bit key, and 128 bit message. I always pretty much get the result I expected, however, the encrypted result is always 256 bit long. The second 128 bits being always the same. Other than truncating the result, how can I ensure that the cipher returns only the first 128 bits, without changing the first 128 bits? I feel like I've got kind of mixed up with the definition of block size here.</p>
"	NULL	0	NULL	51:24.1	5	46:04.2	29:42.0	NULL	8753	1960804	0	1	3	<java><cryptography><aes><block><encryption>	Java AES cipher text size	12585	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
15948662	15952803	8	"<p>Hullo,</p>

<p>I am encrypting and decrypting in Java with Blowfish.</p>

<p>The encryption works fine, but the decryption fails.</p>

<p>Here is my Java code for decrypting :</p>

<pre><code>String encryptedString =  ;
String decryptedString = null;
SecretKeySpec key = new SecretKeySpec(myKey.getBytes(), ""Blowfish"");
Cipher cipher;
try {
    cipher = Cipher.getInstance(""Blowfish"");
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] decrypted = cipher.doFinal(encryptedString.getBytes());
    decryptedString = new String(decrypted, Charset.forName(""UTF-8""));
} [ catch Exceptions  ]
</code></pre>

<p>I get an exception :</p>

<p><code>Exception. javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher</code></p>

<p>Can you tell me how to make this simply work ? Thank you.</p>

<p>The input I give comes from my encryption Java code, + encoding in Base64, and I decode it from Base64 just before giving it to this decrypting operation.</p>
"	NULL	2	NULL	21:58.9	5	30:56.5	53:17.3	NULL	1824094	1824094	0	1	2	<java><cryptography><encryption><blowfish>	Decrypting in Java with Blowfish	23441	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16166391	16192059	1	"<p>I have some encoded value received by my webservice. Now I have to decode this encoded string and get the bytes of it.</p>

<p>Now I am using this byte array as my IV value for decrypting a values using AES algorithm. But it is not giving me the proper output rather throws some junk values. </p>

<p>Here is my code,</p>

<pre><code>    byte[] decoded =  Base64.decodeBase64(((String) ""MTIzNDU2Nzg5MTIzNDU2Nw=="").getBytes());
    System.out.println(new String(decoded, ""UTF-8"") + ""\n"");
</code></pre>

<p><strong>MTIzNDU2Nzg5MTIzNDU2Nw==</strong> is the encoded string received from the request xml.</p>

<p>Now decoded will be IV for the next number to be decrypted,</p>

<pre><code>    String c = decrypt1(""JHIlf4iXM53tgsKHQEv1dlsUTeLr5GP3LfSNGlWENkg="", decoded);
    System.out.println(c); 
</code></pre>

<p><strong>JHIlf4iXM53tgsKHQEv1dlsUTeLr5GP3LfSNGlWENkg=</strong> is the digit to be decrypted. </p>

<pre><code>      public static String decrypt1(Object data, byte[] ivBytes) throws InvalidKeyException,
        InvalidAlgorithmParameterException, IllegalBlockSizeException,
        BadPaddingException, UnsupportedEncodingException {
            byte[] keyBytes = ""keyPhrase"".getBytes();
            Cipher cipher = null;
            if (ivBytes.length&lt;16) {
                System.out.println(""error"" + ivBytes.length); 
                //ivBytes = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 98, 99,  100, 101, 102, 103};
            }
        byte[] byteArr = null;
       try {
          SecretKey secretKey = new SecretKeySpec(keyBytes, ""AES"");
          cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
          cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(
                ivBytes));
           if (data instanceof String) {
            byteArr = Base64.decodeBase64(((String) data).getBytes(""UTF-8""));
        } 
        byteArr = (cipher.doFinal(byteArr));
    } catch (Exception e) {
        e.printStackTrace();
    }
    //return byteArr;
     return new String(byteArr);
}
</code></pre>

<p><strong>Note:</strong> </p>

<p>Instead if I use this IV, </p>

<pre><code> byte[] ivBytes = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0};  it works as expected.
</code></pre>
"	NULL	3	NULL	58:10.7	2	48:25.8	48:25.8	NULL	824546	824546	0	1	0	<java><aes><encryption>	Decryption fails on chaging the IV in AES algorithm	376	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16192140	16194932	2	"<p>I have observed the following when I worked with <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#doFinal%28byte%5b%5d%29"" rel=""noreferrer"">Cipher</a>. </p>

<p>Encryption code:</p>

<pre><code>Cipher aes = Cipher.getInstance(""AES"");
aes.init(Cipher.ENCRYPT_MODE, generateKey());
byte[] ciphertext = aes.doFinal(rawPassword.getBytes());
</code></pre>

<p>Decryption code :</p>

<pre><code>Cipher aes = Cipher.getInstance(""AES"");
aes.init(Cipher.DECRYPT_MODE, generateKey());
byte[] ciphertext = aes.doFinal(rawPassword.getBytes());
</code></pre>

<p>I get IllegalBlockSizeException ( Input length must be multiple of 16 when ...) on running the Decrypt code.</p>

<p>But If I change the decrypt code to </p>

<pre><code>Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding""); //I am passing the padding too
aes.init(Cipher.DECRYPT_MODE, generateKey());
byte[] ciphertext = aes.doFinal(rawPassword.getBytes());
</code></pre>

<p>It works fine. 
I understand that it is in the pattern <code>algorithm/mode/padding</code>. So I thought it is because I didn't mention the padding. So I tried giving mode and padding during encryption, </p>

<p>Encryption code:</p>

<pre><code>Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");//Gave padding during encryption too
aes.init(Cipher.ENCRYPT_MODE, generateKey());
byte[] ciphertext = aes.doFinal(rawPassword.getBytes());
</code></pre>

<p>Decryption code :</p>

<pre><code>Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
aes.init(Cipher.DECRYPT_MODE, generateKey());
byte[] ciphertext = aes.doFinal(rawPassword.getBytes());
</code></pre>

<p>But it fails with IllegalBlockSizeException.</p>

<p>What is the reason, why the exception and what is exactly happening underneath. 
If anyone can help? Thanks in advance</p>

<p><strong>UPDATE</strong></p>

<p>Looks like the issue is with the string I am encrypting and decrypting. Because, even the code that I said works, doesn't always work. I am basically encrypting UUIDs (eg : 8e7307a2-ef01-4d7d-b854-e81ce152bbf6). It works with certain strings and doesn't with certain others.</p>

<p>The length of encrypted String is 64 which is divisible by 16. Yes, I am running it on the same machine.</p>

<p>Method for secret key generation:</p>

<pre><code>    private Key generateKey() throws NoSuchAlgorithmException {
    MessageDigest digest = MessageDigest.getInstance(""SHA"");
            String passphrase = ""blahbl blahbla blah"";
    digest.update(passphrase.getBytes());
    return new SecretKeySpec(digest.digest(), 0, 16, ""AES"");
}
</code></pre>
"	NULL	3	NULL	32:06.4	5	01:54.6	15:28.3	NULL	1172611	1172611	0	1	21	<java><aes><encryption>	Cipher: What is the reason for IllegalBlockSizeException?	21335	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16218026	0	1	"<p>I'm trying to decrypt C# encrypted data in Java without success. I'm using 128 bit key&amp;block size with PKCS7 padding. Here's C# code:</p>

<pre><code>    public byte[] Encrypt(byte[] data, byte[] key)
    {
        using (var ms = new MemoryStream())
        {
            using (var aes = RijndaelManaged.Create())
            {
                aes.Key = key;
                aes.IV = key;
                var stream = new CryptoStream(ms, aes.CreateEncryptor(aes.Key, aes.IV), CryptoStreamMode.Write);
                stream.Write(data, 0, data.Length);
                stream.FlushFinalBlock();
                return ms.ToArray();
            }
        }
    }
</code></pre>

<p>and this is java code:</p>

<pre><code>private static Key generateKey() throws Exception {

    Key key = new SecretKeySpec(Files.readAllBytes(Paths.get(""D:/Temp/cr.key"")), ""AES"");

    return key;
}

public static byte[] decrypt(byte[] encryptedData) throws Exception {
    Key key = generateKey();

    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");

    IvParameterSpec ivSpec = new IvParameterSpec(key.getEncoded());
    c.init(Cipher.DECRYPT_MODE, key, ivSpec);

    System.out.println(c.getBlockSize());


    c.update(encryptedData);
    byte[] decValue = c.doFinal();
    return decValue;
}

public static void main(String[] args) throws Exception {
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

    byte[] bb = decrypt(Files.readAllBytes(Paths.get(""d:\\Temp\\cr~\\OEBPS\\Chapter001.html"")));
           //decompressFile(bb, new File(""D:\\Temp\\enc.html""));
}
</code></pre>

<p>Any idea what could be wrong?</p>

<p>THanks</p>

<p>UPDATE</p>

<hr>

<p>Sorry, how dumb of me, I forgot to write actual error message. Here it is:</p>

<blockquote>
  <p>Exception in thread ""main"" javax.crypto.BadPaddingException: pad block
  corrupted     at
  org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(Unknown
  Source)   at javax.crypto.Cipher.doFinal(Cipher.java:1970)</p>
</blockquote>

<p>Thanks</p>
"	NULL	3	NULL	51:01.1	4	22:16.1	16:29.7	NULL	379079	379079	0	1	3	<c#><java><encryption><aes><rijndael>	AES encrypt C# decrypt Java?	1086	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16336017	0	2	"<p>On the server side, the encyption/decryption of the password field is done in C#.</p>

<p>Now, i need to implement same functionality in my android application. So, i followed this tutorial: <a href=""http://ttux.net/post/3des-java-encrypter-des-java-encryption/"" rel=""nofollow"">http://ttux.net/post/3des-java-encrypter-des-java-encryption/</a> as below:</p>

<pre><code>    import java.security.MessageDigest; 
import java.security.spec.KeySpec; 
import java.util.Arrays; 

import javax.crypto.Cipher; 
import javax.crypto.SecretKey; 
import javax.crypto.SecretKeyFactory; 
import javax.crypto.spec.DESedeKeySpec; 
import javax.crypto.spec.IvParameterSpec; 

import org.apache.commons.codec.binary.Base64; 

public class Encrypter { 
  private KeySpec keySpec; 
  private SecretKey key; 
  private IvParameterSpec iv; 

  public Encrypter(String keyString, String ivString) { 
    try { 
      final MessageDigest md = MessageDigest.getInstance(""md5""); 
      final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(""utf-8""))); 
      final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
      for (int j = 0, k = 16; j &lt; 8;) { 
    keyBytes[k++] = keyBytes[j++]; 
      } 

      keySpec = new DESedeKeySpec(keyBytes); 

      key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec); 

      iv = new IvParameterSpec(ivString.getBytes()); 
    } catch(Exception e) { 
      e.printStackTrace(); 
    } 
  } 

  public String encrypt(String value) { 
    try { 
      Cipher ecipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      ecipher.init(Cipher.ENCRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Encode the string into bytes using utf-8 
      byte[] utf8 = value.getBytes(""UTF8""); 

      // Encrypt 
      byte[] enc = ecipher.doFinal(utf8); 

      // Encode bytes to base64 to get a string 
      return new String(Base64.encodeBase64(enc),""UTF-8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 

  public String decrypt(String value) { 
    try { 
      Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      dcipher.init(Cipher.DECRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Decode base64 to get bytes 
      byte[] dec = Base64.decodeBase64(value.getBytes()); 

      // Decrypt 
      byte[] utf8 = dcipher.doFinal(dec); 

      // Decode using utf-8 
      return new String(utf8, ""UTF8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 
} 
</code></pre>

<p>but i dont know what values i need to provide for KeyValue and ivValue for the above code. Please help me...</p>
"	NULL	2	NULL	43:10.7	7	55:25.8	08:49.9	NULL	608639	2326860	0	1	4	<java><android><3des>	How to use 3DES algorithm on Android?	14876	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16472877	16791392	2	"<p>I'm attempting to store some encrypted data in the Android filesystem. I'm getting errors I don't understand and empty files. Please help. </p>

<p>Code:</p>

<pre><code>private Cipher cipher;
private ArrayList&lt;ConnectionProfile&gt; connectionProfiles;

public void createCipher() throws Exception{
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
}

public void saveProfiles() {
    try {
        if (cipher == null) {createCipher();}
        FileOutputStream fos = openFileOutput(""connProfiles.bin"", Context.MODE_PRIVATE);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        CipherOutputStream cos = new CipherOutputStream(bos, cipher);
        ObjectOutputStream oos = new ObjectOutputStream(cos);
        oos.writeObject(connectionProfiles);
        oos.flush();
        oos.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public void readProfiles() {
    try {
        if (cipher == null) {createCipher();}
        FileInputStream fis = openFileInput(""connProfiles.bin"");
        BufferedInputStream bis = new BufferedInputStream(fis);
        CipherInputStream cis = new CipherInputStream(bis, cipher);
        ObjectInputStream ois = new ObjectInputStream(cis);
        connectionProfiles = (ArrayList&lt;ConnectionProfile&gt;) ois.readObject();
        ois.close();
    } catch (Exception e) {
        e.printStackTrace();
        ;
    }
}
</code></pre>

<p>Traceback:</p>

<pre><code>05-09 23:24:39.628: W/System.err(837): java.lang.IllegalStateException
05-09 23:24:39.639: W/System.err(837):  at javax.crypto.Cipher.update(Cipher.java:884)
05-09 23:24:39.639: W/System.err(837):  at javax.crypto.CipherOutputStream.write(CipherOutputStream.java:95)
05-09 23:24:39.639: W/System.err(837):  at java.io.DataOutputStream.writeShort(DataOutputStream.java:192)
05-09 23:24:39.648: W/System.err(837):  at java.io.ObjectOutputStream.writeStreamHeader(ObjectOutputStream.java:1815)
05-09 23:24:39.648: W/System.err(837):  at java.io.ObjectOutputStream.&lt;init&gt;(ObjectOutputStream.java:279)
05-09 23:24:39.648: W/System.err(837):  at com.sajnasoft.down2home.MainActivity.saveProfiles(MainActivity.java:39)
05-09 23:24:39.648: W/System.err(837):  at com.sajnasoft.down2home.MainActivity$2.onClick(MainActivity.java:92)
05-09 23:24:39.658: W/System.err(837):  at android.view.View.performClick(View.java:4204)
05-09 23:24:39.658: W/System.err(837):  at android.view.View$PerformClick.run(View.java:17355)
05-09 23:24:39.658: W/System.err(837):  at android.os.Handler.handleCallback(Handler.java:725)
05-09 23:24:39.658: W/System.err(837):  at android.os.Handler.dispatchMessage(Handler.java:92)
05-09 23:24:39.658: W/System.err(837):  at android.os.Looper.loop(Looper.java:137)
05-09 23:24:39.668: W/System.err(837):  at android.app.ActivityThread.main(ActivityThread.java:5041)
05-09 23:24:39.668: W/System.err(837):  at java.lang.reflect.Method.invokeNative(Native Method)
05-09 23:24:39.668: W/System.err(837):  at java.lang.reflect.Method.invoke(Method.java:511)
05-09 23:24:39.678: W/System.err(837):  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)
05-09 23:24:39.678: W/System.err(837):  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:560)
05-09 23:24:39.678: W/System.err(837):  at dalvik.system.NativeStart.main(Native Method)
05-09 23:26:33.878: W/IInputConnectionWrapper(837): showStatusIcon on inactive InputConnection
</code></pre>

<p>Update:</p>

<p>So now I have</p>

<pre><code>private Spinner spinner;
private SpinAdapter adapter;
private Cipher cipher;
private ArrayList&lt;ConnectionProfile&gt; connectionProfiles;
private KeyGenerator keygen;
private SecretKey key;

public void createCipher() throws Exception{
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    keygen = KeyGenerator.getInstance(""AES"");
    key = keygen.generateKey();
}

public void saveProfiles() {
    try {
        if (cipher == null) {createCipher();}
        cipher.init(Cipher.ENCRYPT_MODE, key);
        FileOutputStream fos = openFileOutput(""connProfiles.bin"", Context.MODE_PRIVATE);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        CipherOutputStream cos = new CipherOutputStream(bos, cipher);
        ObjectOutputStream oos = new ObjectOutputStream(cos);
        oos.writeObject(connectionProfiles);
        oos.flush();
        oos.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public void readProfiles() {
    try {
        if (cipher == null) {createCipher();}
        cipher.init(Cipher.ENCRYPT_MODE, key);
        FileInputStream fis = openFileInput(""connProfiles.bin"");
        BufferedInputStream bis = new BufferedInputStream(fis);
        CipherInputStream cis = new CipherInputStream(bis, cipher);
        ObjectInputStream ois = new ObjectInputStream(cis);
        connectionProfiles = (ArrayList&lt;ConnectionProfile&gt;) ois.readObject();
        ois.close();
    } catch (Exception e) {
        e.printStackTrace();
        ;
    }
}
</code></pre>

<p>and:</p>

<pre><code>05-11 22:20:40.658: W/System.err(1019): java.io.StreamCorruptedException
05-11 22:20:40.658: W/System.err(1019):     at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:2109)
05-11 22:20:40.658: W/System.err(1019):     at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:372)
05-11 22:20:40.658: W/System.err(1019):     at com.sajnasoft.down2home.MainActivity.readProfiles(MainActivity.java:59)
05-11 22:20:40.658: W/System.err(1019):     at com.sajnasoft.down2home.MainActivity.onCreate(MainActivity.java:83)
05-11 22:20:40.658: W/System.err(1019):     at android.app.Activity.performCreate(Activity.java:5104)
05-11 22:20:40.658: W/System.err(1019):     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1080)
05-11 22:20:40.668: W/System.err(1019):     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2144)
05-11 22:20:40.668: W/System.err(1019):     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2230)
05-11 22:20:40.668: W/System.err(1019):     at android.app.ActivityThread.access$600(ActivityThread.java:141)
05-11 22:20:40.668: W/System.err(1019):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1234)
05-11 22:20:40.668: W/System.err(1019):     at android.os.Handler.dispatchMessage(Handler.java:99)
05-11 22:20:40.668: W/System.err(1019):     at android.os.Looper.loop(Looper.java:137)
05-11 22:20:40.668: W/System.err(1019):     at android.app.ActivityThread.main(ActivityThread.java:5041)
05-11 22:20:40.678: W/System.err(1019):     at java.lang.reflect.Method.invokeNative(Native Method)
05-11 22:20:40.678: W/System.err(1019):     at java.lang.reflect.Method.invoke(Method.java:511)
05-11 22:20:40.678: W/System.err(1019):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)
05-11 22:20:40.678: W/System.err(1019):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:560)
05-11 22:20:40.678: W/System.err(1019):     at dalvik.system.NativeStart.main(Native Method)
</code></pre>

<p>Alright so now I'm initializing the cipher and salt in the onCreate, and my methods have gotten significantly more complicated as follows. The end result is a corrupted stream when attempting to read.</p>

<pre><code>private Spinner spinner;
private SpinAdapter adapter;
private Cipher cipher;
private ArrayList&lt;ConnectionProfile&gt; connectionProfiles;
private KeyGenerator keygen;
private SecretKey key;
private String salt;
private SecretKey saltedKey;
private static final String RANDOM_ALGORITHM = ""SHA1PRNG"";
private IvParameterSpec ivSpec;

public void createKey() throws Exception {
    keygen = KeyGenerator.getInstance(""AES"");
    key = keygen.generateKey();
    byte[] saltedKeyBytes = new byte[key.getEncoded().length+salt.getBytes().length];
    System.arraycopy(key.getEncoded(), 0, saltedKeyBytes, 0, key.getEncoded().length);
    System.arraycopy(salt.getBytes(), 0, saltedKeyBytes, key.getEncoded().length, salt.getBytes().length);
    saltedKey = new SecretKeySpec(saltedKeyBytes, 0, saltedKeyBytes.length, ""AES"");
}

 private byte[] generateIv() throws NoSuchAlgorithmException {
      SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);
      byte[] iv = new byte[16];
      random.nextBytes(iv);
      return iv;
}

public void saveProfiles() {
    try {
        if (key == null) {createKey();}
        cipher.init(Cipher.ENCRYPT_MODE, saltedKey, ivSpec);
        FileOutputStream fos = openFileOutput(""connProfiles.bin"", Context.MODE_PRIVATE);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        CipherOutputStream cos = new CipherOutputStream(bos, cipher);
        ObjectOutputStream oos = new ObjectOutputStream(cos);
        oos.writeObject(connectionProfiles);
        oos.flush();
        oos.close();
        FileOutputStream keyOutputStream = openFileOutput(""key.bin"", Context.MODE_PRIVATE);
        keyOutputStream.write(key.getEncoded());
        keyOutputStream.flush();
        keyOutputStream.close();
        byte[] iv = generateIv();
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        FileOutputStream ivOutputStream = openFileOutput(""iv.bin"", Context.MODE_PRIVATE);
        ivOutputStream.write(iv);
        ivOutputStream.flush();
        ivOutputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public void readProfiles() {
    try {
        File file = new File(this.getFilesDir(), ""key.bin"");
        byte[] keyBytes = new byte[(int) file.length()];
        FileInputStream keyInputStream = new FileInputStream(file);
        keyInputStream.read(keyBytes);
        keyInputStream.close();
        File file2 = new File(this.getFilesDir(), ""iv.bin"");
        byte[] iv = new byte[(int) file2.length()];
        FileInputStream ivInputStream = new FileInputStream(file2);
        ivInputStream.read(iv);
        ivInputStream.close();
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        byte[] saltedKeyBytes = new byte[keyBytes.length+salt.getBytes().length];
        System.arraycopy(keyBytes, 0, saltedKeyBytes, 0, keyBytes.length);
        System.arraycopy(salt.getBytes(), 0, saltedKeyBytes, keyBytes.length, salt.getBytes().length);
        saltedKey = new SecretKeySpec(saltedKeyBytes, 0, saltedKeyBytes.length, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, saltedKey, ivSpec);
        FileInputStream fis = openFileInput(""connProfiles.bin"");
        BufferedInputStream bis = new BufferedInputStream(fis);
        CipherInputStream cis = new CipherInputStream(bis, cipher);
        ObjectInputStream ois = new ObjectInputStream(cis);
        connectionProfiles = (ArrayList&lt;ConnectionProfile&gt;) ois.readObject();
        ois.close();
    } catch (Exception e) {
        e.printStackTrace();
        ;
    }
}
</code></pre>

<p>Traceback:</p>

<pre><code>05-19 01:08:17.325: W/System.err(843): java.io.StreamCorruptedException
05-19 01:08:17.325: W/System.err(843):  at java.io.ObjectInputStream.readStreamHeader(ObjectInputStream.java:2109)
05-19 01:08:17.325: W/System.err(843):  at java.io.ObjectInputStream.&lt;init&gt;(ObjectInputStream.java:372)
05-19 01:08:17.335: W/System.err(843):  at com.sajnasoft.down2home.MainActivity.readProfiles(MainActivity.java:102)
05-19 01:08:17.335: W/System.err(843):  at com.sajnasoft.down2home.MainActivity.onCreate(MainActivity.java:132)
05-19 01:08:17.335: W/System.err(843):  at android.app.Activity.performCreate(Activity.java:5104)
05-19 01:08:17.335: W/System.err(843):  at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1080)
05-19 01:08:17.335: W/System.err(843):  at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2144)
05-19 01:08:17.335: W/System.err(843):  at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2230)
05-19 01:08:17.335: W/System.err(843):  at android.app.ActivityThread.access$600(ActivityThread.java:141)
05-19 01:08:17.335: W/System.err(843):  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1234)
05-19 01:08:17.345: W/System.err(843):  at android.os.Handler.dispatchMessage(Handler.java:99)
05-19 01:08:17.345: W/System.err(843):  at android.os.Looper.loop(Looper.java:137)
05-19 01:08:17.345: W/System.err(843):  at android.app.ActivityThread.main(ActivityThread.java:5041)
05-19 01:08:17.345: W/System.err(843):  at java.lang.reflect.Method.invokeNative(Native Method)
05-19 01:08:17.345: W/System.err(843):  at java.lang.reflect.Method.invoke(Method.java:511)
05-19 01:08:17.345: W/System.err(843):  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)
05-19 01:08:17.345: W/System.err(843):  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:560)
05-19 01:08:17.355: W/System.err(843):  at dalvik.system.NativeStart.main(Native Method)
</code></pre>
"	NULL	0	NULL	32:53.2	4	53:05.0	17:09.0	NULL	522757	522757	0	1	4	<android><io><inputstream><outputstream><encryption>	Cipher Output and Input Streams	3826	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
16721266	16721406	2	"<p>I need to encrypt / decrypt a username field and I was planning to use the code below: </p>

<pre><code>public class Decrypter {
    Cipher dcipher;

    byte[] salt = new String(""12345678"").getBytes();
    int iterationCount = 1024;
    int keyStrength = 256;
    SecretKey key;
    byte[] iv;

    Decrypter(String passPhrase) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), salt, iterationCount, keyStrength);
        SecretKey tmp = factory.generateSecret(spec);
        key = new SecretKeySpec(tmp.getEncoded(), ""AES"");
        dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    }

    public String encrypt(String data) throws Exception {
        dcipher.init(Cipher.ENCRYPT_MODE, key);
        AlgorithmParameters params = dcipher.getParameters();
        iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] utf8EncryptedData = dcipher.doFinal(data.getBytes());
        String base64EncryptedData = new sun.misc.BASE64Encoder().encodeBuffer(utf8EncryptedData);

        System.out.println(""IV "" + new sun.misc.BASE64Encoder().encodeBuffer(iv));
        System.out.println(""Encrypted Data "" + base64EncryptedData);
        return base64EncryptedData;
    }

    public String decrypt(String base64EncryptedData) throws Exception {
        dcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] decryptedData = new sun.misc.BASE64Decoder().decodeBuffer(base64EncryptedData);
        byte[] utf8 = dcipher.doFinal(decryptedData);
        return new String(utf8, ""UTF8"");
    }

    public static void main(String args[]) throws Exception {
        Decrypter decrypter = new Decrypter(""ABCDEFGHIJKL"");
        String encrypted = decrypter.encrypt(""StringToBeEncrypted"");
        String decrypted = decrypter.decrypt(encrypted);
        System.out.println(decrypted);
    }
} 
</code></pre>

<p>I've taken this code from another site. The above code works fine when run as standalone. But the issue that I'm facing is how to decrypt the value when username is already encrypted?</p>

<p>I'll be calling encrypt &amp; decrypt functions from different classes, so if the string is already encrypted &amp; stored in the DB, then when user logs into website, when I'll call decrypt method, how do I pass the IV as CBC mode decrypt requires an IV parameter, while I've not stored iv during the encryption???</p>

<p>Any help is much appreciated!!</p>

<p>NOTE: This has nothing to do with password protection. As mentioned, need to encrypt userid &amp; not password! For password protection, I'm using hash only.</p>
"	NULL	1	NULL	25:13.7	3	55:56.8	19:09.6	NULL	589259	2414835	0	1	0	<java><jakarta-ee><encryption><cryptography><aes>	How to get IV for decryption in Java?	11648	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17125709	17125810	1	"<p>using encryption library in java is not stable in speed the first round take a lot time than the others and after some time the time needed to perform encryption is stable why is this and  how to reach stability from the beginning, if some intail code is needed i can do it but i do know need the the call of encrypt method to take that amound of time please see the code and the final line that contain results.</p>

<p>This class contain static methods to encrypt/ decrypt</p>

<pre><code>package karp.generalutil.common;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


public class Encryptor {

/**
 * @param args
 */

static Cipher eCipher,dCipher;

public Encryptor()
{
    try {
        eCipher=Cipher.getInstance(""AES"");
        dCipher=Cipher.getInstance(""AES"");
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }


}

/// for test
public static void main (String args[])
{
try {
    KeyGenerator aes;


    aes = KeyGenerator.getInstance(""AES"");

    aes.init(128);

    SecretKey key = aes.generateKey();






} catch (Exception e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}

}


public static String encrypt(String clearText,String keyString) throws NoSuchAlgorithmException, 
                                                       NoSuchPaddingException, InvalidKeyException,
                                                        IllegalBlockSizeException, BadPaddingException
{


    SecretKey key=loadKey(keyString);
    String encryptedText;

    eCipher.init(Cipher.ENCRYPT_MODE,key );
    encryptedText=new String(eCipher.doFinal(clearText.getBytes()));





    return encryptedText;
}

public static String decrypt(String encryptedText,String keyString) throws NoSuchAlgorithmException, 
                                                           NoSuchPaddingException, InvalidKeyException,
                                                           IllegalBlockSizeException, BadPaddingException
{

    SecretKey key=loadKey(keyString);
    String clearText;
    Cipher dCipher=Cipher.getInstance(""AES"");
    dCipher.init(Cipher.DECRYPT_MODE,key);
    clearText=new String(dCipher.doFinal(encryptedText.getBytes()));





    return clearText;


}


public static byte[] encrypt(byte [] clearByteArray,String keyString)throws NoSuchAlgorithmException, 
                                                            NoSuchPaddingException, InvalidKeyException,
                                                            IllegalBlockSizeException, BadPaddingException
{

    SecretKey key=loadKey(keyString);
    byte[] encryptedByteArray;
    Cipher eCipher=Cipher.getInstance(""AES"");
    eCipher.init(Cipher.ENCRYPT_MODE,key );
    encryptedByteArray=eCipher.doFinal(clearByteArray);

    return encryptedByteArray;
}


public static byte[] decrypt(byte [] encryptedByteArray,String keyString)throws NoSuchAlgorithmException, 
                                                            NoSuchPaddingException, InvalidKeyException,
                                                            IllegalBlockSizeException, BadPaddingException
{
    SecretKey key=loadKey(keyString);
    byte[] clearByteArray;

    Cipher dCipher=Cipher.getInstance(""AES"");
    dCipher.init(Cipher.DECRYPT_MODE,key );
    clearByteArray=dCipher.doFinal(encryptedByteArray);
    return clearByteArray;
}

public static SecretKey loadKey(String  keyString)  {

        byte[] encoded = keyString.getBytes();

        SecretKey key = new SecretKeySpec(encoded, ""AES"");
        return key;
    }

}
</code></pre>

<p>This the test class</p>

<pre><code>import java.io.ByteArrayInputStream;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.UnknownHostException;
import java.sql.Timestamp;
import java.util.Date;





public class tesst {

    /**
     * @param args
     */
    public static void main(String[] args) {
        try {


            long y1,y2;
            y1=System.nanoTime();
            Encryptor e=new Encryptor();
            String keyString=""{¶¹û¼«I?q-×«Ð»"";
            e.encrypt(new byte[31], ""{¶¹û¼«I?q-×«Ð»"");
             y2=System.nanoTime()-y1;
                System.out.println(""ini:""+y2);

            for(int i=0;i&lt;100000;i++)
            {   byte [] x=new byte [31];
                y1=System.nanoTime();

        byte [] y=e.encrypt(x, ""{¶¹û¼«I?q-×«Ð»"");



        y2=System.nanoTime()-y1;
        System.out.println(y2);
            }



                    } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

}
</code></pre>

<p>The first loop take about 193650106 ns
the second loop take about 126150 ns
after 150 loop the time to encrypt is decreased to  11546 ns</p>
"	NULL	0	NULL	33:10.2	2	37:56.4	02:55.1	NULL	2352432	2175721	0	1	1	<java><aes>	increase performance of AES in java	2622	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17134249	17134343	2	"<p>I am calling a certain method when i call it alone using a  it take an average (for 10000 call) of 11523 nano second but when i call it from a context of another class  it take about 95721</p>

<p>The method body is</p>

<pre><code>public static byte [] validateRequest(KARPPacket karpPacket)
{

try {
    long before,time;
    before =System.nanoTime();


    byte [] encryptedTicket=karpPacket.getTicket();
    byte[] decryptedTicket=null;
    if(encryptedTicket==null)
        return null;
    if(encryptedTicket.length%16==0)
    {



        decryptedTicket = Encryptor.decrypt(encryptedTicket, ClientWindow.getSecretKey());
        time=System.nanoTime()-before;
        System.out.println(time);

         if(karpPacket.getSenderProtocolAddressAsString().equals(getSrcAddressFromTicket(decryptedTicket)))
         {
            ClientTicketManager.getArpCash().put(karpPacket.getSenderProtocolAddressAsString(), karpPacket.getSenderHardwareAddressFormatted());


            return decryptedTicket;
         }


       return decryptedTicket;


    }

    return null;

    } catch (Exception e) {

        e.printStackTrace();
        return null;
    } 
</code></pre>

<p>why is that and how to improve its performance.
 I hope this enough code </p>

<p>here is the encryptor.decrypt method</p>

<pre><code>public static byte[] decrypt(byte [] encryptedByteArray,String keyString)throws NoSuchAlgorithmException, 
                                                            NoSuchPaddingException, InvalidKeyException,
                                                            IllegalBlockSizeException, BadPaddingException
{
    SecretKey key=loadKey(keyString);

byte[] clearByteArray;

Cipher dCipher=Cipher.getInstance(""AES"");
dCipher.init(Cipher.DECRYPT_MODE,key );
clearByteArray=dCipher.doFinal(encryptedByteArray);
return clearByteArray;
</code></pre>

<p>}</p>

<p>and the load key</p>

<pre><code>public static SecretKey loadKey(String  keyString)  {


            byte[] encoded = keyString.getBytes();

            SecretKey key = new SecretKeySpec(encoded, ""AES"");
            return key;
        }
</code></pre>

<p>the other context at which a run the validate request method</p>

<pre><code>package karp.client;

import java.awt.Color;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.sql.Timestamp;
import java.util.Date;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.swing.JOptionPane;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import karp.client.presentation.ClientWindow;
import karp.client.util.Constants;
import karp.generalutil.common.Encryptor;
import karp.generalutil.destination.TicketDestination;
import karp.packet.KARPPacket;

public class KARPMessageHandlerP {

    String localIpAddress=null;
    ClientTicketManager clientTicketManager;
    KARPSender karpRequestSender=new KARPSender();  

byte [] srcMac;
NetworkInterface network;

    public KARPMessageHandlerP(KARPPacket karpPacket)
    {


        try
        {

            long before,time;


            localIpAddress=KARPReciever.localIpAddress;
            clientTicketManager=KARPReciever.clientTicketManager;

             srcMac = KARPReciever.srcMac;

//          



        if(karpPacket.getOperation()==KARPPacket.ARP_REPLY)
        {

            if(karpPacket.getSenderProtocolAddressAsString().equals(localIpAddress))//request sent by client
            {

                // if the reply was sent by the client no action must be taken.

            }
            else
            {

         if(karpPacket.getTargetProtocolAddressAsString().equals(localIpAddress))
         {
         byte [] ticket=karpPacket.getTicket();
         if(ticket==null)
         {   

         //delete the new entry from cash  and refresh the cash
          deleteEntry(karpPacket.getSenderProtocolAddressAsString());





         }
         else
         {


             if(validateReply(karpPacket) )
             {

                  }  
             else
             {


                 deleteEntry(karpPacket.getSenderProtocolAddressAsString());

                 //delete entry and refresh cash
             }

         }

            }
        }
        }

        else
            if(karpPacket.getOperation()==KARPPacket.ARP_REQUEST)
            {


                if(karpPacket.getSenderProtocolAddressAsString().equals(localIpAddress))//request sent by client
                    {
    //1             
                    if(karpPacket.getTicket()!=null)
                    {
                    //custom request no need to add;    


                    }
    //2         
                    else //new request need to add ticket 
                    {
                        String destinationId=(karpPacket.getTargetProtocolAddressAsString());
                        // if the map contain ticket to destination add the ticket directly
    //2-1               
                        KARPPacket customKarpPacket;
                        byte [] ticketDestinationByte=null;
                        if(ClientTicketManager.getDestinationTicketMap().containsKey(destinationId))
                        {
                             ticketDestinationByte=ClientTicketManager.getDestinationTicketMap().get(destinationId);
                                                    }
    //2-2                send ticket request
                        else
                        {   
                            ticketDestinationByte=clientTicketManager.getDestinationTicket(destinationId);



                        }
                        if(ticketDestinationByte!=null)
                        {

                        customKarpPacket= karpRequestSender.createKARPPacket(karpPacket.getDstAddress(), karpPacket.getSrcAddress(), 
                                                                            InetAddress.getLocalHost().getAddress(), karpPacket.getTargetProtoAddr(),
                                                                            karpPacket.getTargetHardAddr(),
                                                                            ticketDestinationByte, KARPPacket.ARP_REQUEST);


                        karpRequestSender.sendKARPPacket(customKarpPacket);
                        }

                    }
                    }
                else
                {
                    if(karpPacket.getTargetProtocolAddressAsString().equals(localIpAddress))//check to see if the request is for the client
                    {

                    byte [] ticketRequest=validateRequest(karpPacket);
                    if(ticketRequest!=null)
                    {

                        //reply to the request;

                        String sessionKey=getSessionKeyFromTicket(ticketRequest);

                        TicketDestination ticketDestination=new TicketDestination();

                        ticketDestination.setDestinationId(karpPacket.getSenderProtocolAddressAsString());
                        ticketDestination.setSourceId(karpPacket.getTargetProtocolAddressAsString());
                        ticketDestination.setSourceDestinationKey(sessionKey);
                        byte [] ticketDestinationByte=ticketDestination.getAsByte();
                        byte [] encryptedTicketDestination=Encryptor.encrypt(ticketDestinationByte, sessionKey);


                        ///need to review target hardware address

                        KARPPacket karpPacketReply=karpRequestSender.createKARPPacket(karpPacket.getSrcAddress(), srcMac, InetAddress.getLocalHost().getAddress(), karpPacket.getSenderProtoAddr(),karpPacket.getSrcAddress(), encryptedTicketDestination, KARPPacket.ARP_REPLY);

                        karpRequestSender.sendKARPPacket(karpPacketReply);

                    }   
                    else //delete ticket invalid request
                    {
                         deleteEntry(karpPacket.getSenderProtocolAddressAsString());

                    }


                }
                }
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
        }

        //System.out.println(timeConsumed);
    }


    public static byte [] validateRequest(KARPPacket karpPacket)
    {
        try {
            long before,time;
            before =System.nanoTime();


            byte [] encryptedTicket=karpPacket.getTicket();
            byte[] decryptedTicket=null;
            if(encryptedTicket==null)
                return null;
            if(encryptedTicket.length%16==0)
            {



                decryptedTicket = Encryptor.decrypt(encryptedTicket, ClientWindow.getSecretKey());
                time=System.nanoTime()-before;
                System.out.println(time);

                 if(karpPacket.getSenderProtocolAddressAsString().equals(getSrcAddressFromTicket(decryptedTicket)))
                 {
                    ClientTicketManager.getArpCash().put(karpPacket.getSenderProtocolAddressAsString(), karpPacket.getSenderHardwareAddressFormatted());


                    return decryptedTicket;
                 }


               return decryptedTicket;


            }

            return null;

            } catch (Exception e) {

                e.printStackTrace();
                return null;
            } 


    }


    public boolean validateReply(KARPPacket karpPacket) throws InvalidKeyException, NoSuchAlgorithmException,
    NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException
    {


//      KARPReciever.stop=true;
//      for(int i=0;i&lt;10000;i++)
//          {

        String sessionKey;
         byte[] encryptedTicket=karpPacket.getTicket();

            if(ClientTicketManager.getDestinationKeyMap().containsKey(karpPacket.getSenderProtocolAddressAsString()))
            {
        sessionKey=ClientTicketManager.getDestinationKeyMap().get(karpPacket.getSenderProtocolAddressAsString());
         byte[] decryptedTicket=Encryptor.decrypt(encryptedTicket, sessionKey);

         if(karpPacket.getSenderProtocolAddressAsString().equals(getSrcAddressFromTicket(decryptedTicket)))
         {
            ClientTicketManager.getArpCash().put(karpPacket.getSenderProtocolAddressAsString(), karpPacket.getSenderHardwareAddressFormatted());

//          after=System.nanoTime();
//           timeConsumed=(after-before);
//          System.out.print(""kl""+timeConsumed);
            return true;
         }
            }
            //}


        return false;
    }

    public void deleteEntry(String entryIpAddress)
    {
        try
        {



        if(!ClientTicketManager.getAuthenticatedUser().contains(entryIpAddress))
        {
        if(ClientTicketManager.getArpCash().containsKey(entryIpAddress))
        {
        String updateCommand=""arp -s ""+entryIpAddress+"" ""+clientTicketManager.getArpCash().get(entryIpAddress);

        //printCash();
        Runtime.getRuntime().exec(updateCommand);   
        }
        else
        {   
         String deleteCommand =""arp -d ""+entryIpAddress;
         Runtime.getRuntime().exec(deleteCommand); 
        }
        }
        }
        catch(Exception e)
        {

        }



    }

    public static String getSrcAddressFromTicket(byte [] ticket)
    {

        byte [] srcByte=new byte[4];
        System.arraycopy(ticket, 16, srcByte, 0, 4);


        String srcString=TicketDestination.getIpAddressAsString(srcByte);
        return srcString;
    }

    public String getSessionKeyFromTicket(byte [] ticket)
    {
        byte [] sessionKeyByte=new byte[16];
        System.arraycopy(ticket, 0, sessionKeyByte,0, 16);
        return new String(sessionKeyByte);
    }

    public void printCash()
    {
        for(Object entry:ClientTicketManager.getArpCash().entrySet().toArray())
        {
            System.out.println(entry+"" ""+clientTicketManager.getArpCash().get(entry)+"" entry in cash "");
        }
    }

}
</code></pre>
"	16:16.8	8	NULL	21:07.9	2	23:17.6	48:44.7	NULL	2175721	2175721	0	1	0	<java>	Performance of method	167	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17180353	17208021	3	"<p>I am trying to decrypt a message that has been encrypted using AES-128 Symmetric encryption and then RSA-1024 Asymmetric encryption on the generated symmetric key. I receive the encrypted AES key and the encrypted message, extract the private key from the pfx file and then proceed with the decryption of the symmetric key. After that, I try to decrypt the encrypted message using the decrypted AES key. </p>

<p>Following is my code:</p>

<pre><code>  // Get the private key
  PrivateKey privateKey = (PrivateKey) keyStore.getKey(selectedAlias, ""password"".toCharArray());
  System.out.println(""Key information "" + privateKey.getAlgorithm() + "" "" + privateKey.getFormat());

  // Load aesSessionKey and encryptedMessage
  byte[] aesSessionKey = ...
  byte[] encryptedMessage = ...

  // RSA Decryption of Encrypted Symmetric AES key - 128 bits
  Cipher rsaCipher = Cipher.getInstance(""RSA"", ""BC"");
  rsaCipher.init(Cipher.UNWRAP_MODE, privateKey);
  Key decryptedKey = rsaCipher.unwrap(aesSessionKey, ""AES"", Cipher.SECRET_KEY);
  System.out.println(""Decrypted Key Length: "" + decryptedKey.getEncoded().length);

  SecretKeySpec decrypskeySpec = new SecretKeySpec(decryptedKey.getEncoded(), ""AES"");
  Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"", ""BC"");
  cipher.init(Cipher.DECRYPT_MODE, decryptedKey, new IvParameterSpec(new byte[16]));
  byte[] message = cipher.doFinal(encryptedMessage);
  System.out.println(new String(message, ""UTF-8""));
</code></pre>

<p>The problem is that the size of the decrypted AES key is 128 bytes and not 16 bytes as I was expecting. I get the following exception:</p>

<pre><code>Key information RSA PKCS#8
Decrypted Key Length: 128
java.security.InvalidKeyException: Key length not 128/192/256 bits.
at org.bouncycastle.jce.provider.JCEBlockCipher.engineInit(Unknown Source)
at javax.crypto.Cipher.init(DashoA13*..)
at javax.crypto.Cipher.init(DashoA13*..)
at com.simarks.services.PKCS12.run(PKCS12.java:74)
at com.simarks.services.PKCS12.main(PKCS12.java:34)
</code></pre>

<p>I am new to Java Cryptography. I have checked numerous other questions and tried several different approaches (like using DECRYPT_MODE instead of UNWRAP_MODE) but I get the same error. Any help will be much appreciated.</p>

<hr>

<p><strong>EDIT:</strong>
The client code encrypting the message is this:</p>

<pre><code>PBYTE          pInputData = NULL;
DWORD          dwInputSize = 0;
PBYTE          pCertData = NULL;
DWORD          dwCertSize = 0;
PCCERT_CONTEXT pCertContext = NULL;
HCRYPTPROV     hCryptProv = NULL;
HCRYPTKEY      hPublicKey = NULL;
HCRYPTKEY      hSessionKey = NULL;
BYTE           InitializationVector[ 32 ] = { 0 };
DWORD          PKCS5Padding = PKCS5_PADDING;
DWORD          CBCMode = CRYPT_MODE_CBC;
PSIMPLEBLOB    pKeyBlob = NULL;
DWORD          dwBlobSize = 0;
DWORD          dwKeySize = 0;
PBYTE          pEncryptedData = NULL;
DWORD          dwEncryptedDataSize = 0;
HRESULT        hr = S_FALSE;

 if( FAILED( hr = ReadBinaryFile( InputFile, &amp;pInputData, &amp;dwInputSize ) ) ) goto EncryptExit;
 if( FAILED( hr = ReadBinaryFile( CertFile, &amp;pCertData, &amp;dwCertSize ) ) ) goto EncryptExit;
 if( ( pCertContext = CertCreateCertificateContext( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, pCertData, dwCertSize ) ) == NULL ) goto EncryptExit;
 if( !CryptAcquireContext( &amp;hCryptProv, NULL, GetMsAesProviderName(), PROV_RSA_AES, 0 ) ) goto EncryptExit;
 if( !CryptImportPublicKeyInfo( hCryptProv, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, &amp;pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;hPublicKey ) ) goto EncryptExit;

 if( !CryptGenKey( hCryptProv, AlgId, CRYPT_EXPORTABLE, &amp;hSessionKey ) ) goto EncryptExit;
 if( !CryptSetKeyParam( hSessionKey, KP_IV, InitializationVector, 0 ) ) goto EncryptExit;
 if( !CryptSetKeyParam( hSessionKey, KP_PADDING, (PBYTE)&amp;PKCS5Padding, 0 ) ) goto EncryptExit;
 if( !CryptSetKeyParam( hSessionKey, KP_MODE, (PBYTE)&amp;CBCMode, 0 ) ) goto EncryptExit;

 if( !CryptExportKey( hSessionKey, hPublicKey, SIMPLEBLOB, 0, NULL, &amp;dwBlobSize ) ) goto EncryptExit;
 if( ( pKeyBlob = (PSIMPLEBLOB)malloc( dwBlobSize ) ) == NULL ) { hr = E_OUTOFMEMORY; goto EncryptExit; }
 if( !CryptExportKey( hSessionKey, hPublicKey, SIMPLEBLOB, 0, (PBYTE)pKeyBlob, &amp;dwBlobSize ) ) goto EncryptExit;
 dwKeySize = dwBlobSize - sizeof( BLOBHEADER ) - sizeof( ALG_ID );

 dwEncryptedDataSize = dwInputSize;
 if( !CryptEncrypt( hSessionKey, NULL, TRUE, 0, NULL, &amp;dwEncryptedDataSize, 0 ) ) goto EncryptExit;
 if( ( pEncryptedData = (PBYTE)malloc( dwEncryptedDataSize ) ) == NULL ) { hr = E_OUTOFMEMORY; goto EncryptExit; }
 CopyMemory( pEncryptedData, pInputData, dwInputSize );
 if( !CryptEncrypt( hSessionKey, NULL, TRUE, 0, pEncryptedData, &amp;dwInputSize, dwEncryptedDataSize ) ) goto EncryptExit;

 if( FAILED( hr = WriteBinaryFile( OutputFile, pEncryptedData, dwInputSize ) ) ) goto EncryptExit;

 hr = WriteBinaryFile( KeyFile, pKeyBlob-&gt;Key, dwKeySize );

EncryptExit:
</code></pre>
"	NULL	2	NULL	55:04.8	3	46:56.5	05:04.8	NULL	1436874	1436874	0	1	0	<java><cryptography><aes><encryption><private-key>	Invalid AES key size after RSA decryption	3327	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17234359	0	NULL	"<p>I'm getting a decrypting error in java class:</p>

<pre><code>javax.crypto.IllegalBlockSizeException : 
    Input length must be multiple of 16 when decrypting with padded cipher.
</code></pre>

<p>What can I do to solve this problem?</p>

<p>UPDATE:</p>

<p>I forgot to mention it is working once and when the second time im trying to execute it again its throwing the above mentioned error.</p>

<pre><code>package com.tb.module.service;
import java.security.Key;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.*;

/**
 * This class is used for encrypt and decrypt the  password field.
 *
 */
public class PswdEnc {

    private static final String ALGO = ""AES"";
    private static final byte[] keyValue = new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't','S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };

    public static String encrypt(String Data) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encVal = c.doFinal(Data.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encVal);
        return encryptedValue;
    }

    public static String decrypt(String encryptedData) throws Exception {
        Key key = generateKey(); 
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }


    private static Key generateKey() throws Exception {
        Key key = new SecretKeySpec(keyValue, ALGO);
        return key;
    }

}
</code></pre>
"	NULL	NULL	NULL	40:56.5	NULL	NULL	NULL	NULL	NULL	1256417	0	1	33	<java><encryption>	javax.crypto.IllegalBlockSizeException : Input length must be multiple of 16 when decrypting with padded cipher	169631	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17280104	17281431	1	"<p>I am trying to get TripleDES encryption working in Java. From the <a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""noreferrer"">Wikipedia article</a> under <code>Keying Options</code>, I want to use option 1, where <code>All three keys are independent</code>.</p>

<p>From the <a href=""http://docs.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html"" rel=""noreferrer"">Cipher docs</a> it says to go to the <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA"" rel=""noreferrer"">reference guide here</a>, but it still isn't clear to me. </p>

<p>I am working on getting examples running, and use both of these lines in different projects:</p>

<pre><code>Cipher c = Cipher.getInstance(""DESede"");

Cipher cipher = Cipher.getInstance(""TripleDES/ECB/PKCS5Padding"");
</code></pre>

<p>Both compile fine, so what's the difference? Should I be using one over the other? Do both of these work for using three separate keys?</p>
"	NULL	0	NULL	12:38.0	7	04:11.7	NULL	NULL	0	1435712	0	1	23	<java><cryptography><encryption><tripledes>	Difference between DESede and TripleDES for cipher.getInstance()	36444	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17322002	17323025	3	"<p>I'm trying to encrypt and decrypt a string using AES but getting an error I don't know how to resolve. This is the code:</p>

<pre><code>public class EncryptionTest{

public static void main(String[] args) {        
    String encrypt = new String(encrypt(""1234567890123456""));
    System.out.println(""decrypted value:"" + (decrypt(""ThisIsASecretKey"",encrypt)));
}

public static String encrypt(String value) {
    try {
        byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(value.getBytes());
        System.out.println(""encrypted string:"" + (new String(encrypted)));
        return new String(skeySpec.getEncoded());
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}

public static String decrypt(String key, String encrypted) {
    try {
        SecretKeySpec skeySpec = new SecretKeySpec(Base64.decodeBase64(key), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(skeySpec.getEncoded(),""AES""));
            (*)
        byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));
        original.toString();
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}  
}
</code></pre>

<p>When I run it the ""decription"" values is null. It fails before the (***) !!</p>

<p>It gives me an exception:</p>

<pre>
java.security.InvalidKeyException: Parameters missing
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:388)
    at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:186)
    at javax.crypto.Cipher.implInit(Cipher.java:787)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:849)
    at javax.crypto.Cipher.init(Cipher.java:1213)
    at javax.crypto.Cipher.init(Cipher.java:1153)
    at firma.XmlEncryptionTest.decrypt(EncryptionTest.java:63)
    at firma.XmlEncryptionTest.main(EncryptionTest.java:41)
</pre>

<p>where the line 63 is the one before (***). I don't know what am I doing wrong and how to solve. I looked around on the internet but without finding out what coul be that missing parameter</p>
"	11:26.1	5	NULL	51:37.3	15	47:40.9	43:51.9	NULL	474189	2413069	0	1	29	<java><aes><encryption>	"What causes the error ""java.security.InvalidKeyException: Parameters missing""?"	79204	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17472684	17474079	1	"<p>First of all I wanna say thank you...</p>

<p>I wrote a program which one is doing encryption and decryption with Enum.
Enum has AES,BlowFish,DESede. My program will support these 3 encryption algorithm.</p>

<p>Then I wanted to Generate a SecretKey with SecretKeyFactory.But I think,I made a mistake to generate a key. (Obviously I loose myself in code.I have no idea about what can I do...)</p>

<p>My Code is below. <strong>This program's purpose is</strong>;</p>

<ul>
<li>Users will write encryption and decryption method parameters. (Text,Encryption Algorithm)</li>
<li>Algorithm type will choose in Enum type. (Enum has 3 algorithm format)</li>
<li>According to the entered Encryption Type,program will encrypt entered text.</li>
</ul>

<p><strong>I know my code is really terrible</strong>. It has lots of unnecessary declaration and logical mistakes.</p>

<p>Code is working fine sometimes,sometimes will crash.</p>

<p><strong>EDIT =</strong> Question is my code doesnt work always. Sometimes gives error. <strong>Error is =</strong> <em>javax.crypto.BadPaddingException: Given final block not properly padded</em></p>

<p><em>Thank you for answering</em>.</p>

<pre><code>import java.security.SecureRandom;
import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class SymetricAlgorithms {

    private static enum algorithms { //Enum declaration 3 encryption types here

        AES, BlowFish, DESede;

    }

    private static String data = ""HOWCANISOLVETHIS""; //this will be encrypt and decrypt

    public static void main(String[] args) throws Throwable {

        SecretKey kgen = GenerateKey(); // Create a key.
        String encrypText = encrypt(kgen, data, algorithms.AES); //encrypt method calling here.
        String decrypText = dencypt(kgen, encrypText, algorithms.AES);//decrypt method calling here.
        System.out.println(""plaintext = "" + data + "" key = "" + kgen
                + ""\nEncryptedText = "" + encrypText
                + ""\nDecryptedText = "" + decrypText);

    }

    public static String dencypt(SecretKey inKey, String text, algorithms eValue)throws Throwable {//decryption
        try {
            byte[] text2 = text.getBytes(); //convert from parameters TEXT to Bytes
            Cipher cipher = Cipher.getInstance(""AES""); //Cipher initialize and choose encryption method (AES)
            cipher.init(Cipher.DECRYPT_MODE, inKey); //cipher process
            byte plainTextByte[] = new byte[20]; //Creating byte array
            plainTextByte =cipher.doFinal(text2);//using byte array to assign ciphers result
            System.out.println(plainTextByte);
            return new String(plainTextByte);
        } catch (Exception e) {
            System.err.println(""Data Cant Decrypted !"");
            e.printStackTrace();
        }
        return null;


    }

    public static String encrypt(SecretKey inKey, String text, algorithms eValue)
            throws Throwable {
        try {
            Cipher cipher = null; //cipher declaration
            switch (eValue) {//Enum. 3 types here and control structure for Users choosing encryption type is acceptable
            case AES:cipher = Cipher.getInstance(""AES"");
                break;
            case BlowFish:Cipher cipher2 = Cipher.getInstance(""BlowFish"");
            cipher = cipher2;
                break;
            case DESede:Cipher cipher3 = Cipher.getInstance(""DESede"");
            cipher=cipher3;
                break;
            default:
                System.out.println(""Unexpectable value input."");
                break;

            }
            System.out.println(inKey);
            //Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, inKey);
            byte[] ciphertext = cipher.doFinal(text.getBytes(""UTF-8""));//cipher result is assign to byte array
            System.out.println(ciphertext);
            return new String(ciphertext);
        } catch (Exception e) {
            System.err.println(""Unexpectable algorithm type !"");
            e.printStackTrace();
        }
        return null;

    }

    public static SecretKey GenerateKey() throws Throwable {//Generate a key for using crypt
            //could sb explain these? =D I loose myself. I combined codes from finding internet...Failed...    
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            SecureRandom prng = SecureRandom.getInstance(""SHA1PRNG"");
            byte bytes[] = new byte[20];
            prng.nextBytes(bytes);
            String passwordTemp = prng.toString();
            String saltTemp = passwordTemp;
            char[] password = passwordTemp.toCharArray();
            byte[] salt = saltTemp.getBytes();
            KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
            return secret;
        } catch (Exception e) {
            System.err.println(""Key cant be generated !"");
            e.printStackTrace();
        }
        return null;

    }

}
</code></pre>
"	NULL	3	NULL	21:24.9	1	57:17.0	58:08.0	NULL	1744705	1744705	0	1	1	<java><encryption><enums><secret-key>	Encryption - Decryption with AES/BlowFish/DESede and Enum	4997	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17535918	0	5	"<p>I'm a complete newbie to this kind of encryption things but I have a Java app and an iOS, and I want them to both be able to ecrypt a text to a same result. I use AES.
I found these codes, with a little modification of course, but they return different result</p>

<p>iOS Code:</p>

<pre><code>- (NSData *)AESEncryptionWithKey:(NSString *)key {    
    unsigned char keyPtr[kCCKeySizeAES128] = { 'T', 'h', 'e', 'B', 'e', 's', 't', 'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };
    size_t bufferSize = 16;
    void *buffer = malloc(bufferSize);
    size_t numBytesEncrypted = 0;
    const char iv2[16] = {  65, 1, 2, 23, 4, 5, 6, 7, 32, 21, 10, 11, 12, 13, 84, 45 };
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                          kCCAlgorithmAES128,
                                          kCCOptionECBMode | kCCOptionPKCS7Padding,,
                                          keyPtr,
                                          kCCKeySizeAES128,
                                          iv2,
                                          @""kayvan"",
                                          6,
                                          dataInLength,
                                          buffer,
                                          bufferSize,
                                          &amp;numBytesEncrypted);


    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    }

    free(buffer);
    return nil;
}
</code></pre>

<p>and the Java code is:</p>

<pre><code>public static void main(String[] args) throws Exception {
    String password = ""kayvan"";
    String key = ""TheBestSecretKey"";
    String newPasswordEnc = AESencrp.newEncrypt(password, key);
    System.out.println(""Encrypted Text : "" + newPasswordEnc);
}
</code></pre>

<p>and in another java class (<code>AESencrp.class</code>) I have: </p>

<pre><code>public static final byte[] IV = { 65, 1, 2, 23, 4, 5, 6, 7, 32, 21, 10, 11, 12, 13, 84, 45 };
public static String newEncrypt(String text, String key) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] keyBytes= new byte[16];
    byte[] b= key.getBytes(""UTF-8"");
    int len = 16; 
    System.arraycopy(b, 0, keyBytes, 0, len);
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(IV);
    System.out.println(ivSpec);
    cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);
    byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
    String result = DatatypeConverter.printBase64Binary(results);
    return result;
}
</code></pre>

<p>The string I wanted to encrypt is <code>kayvan</code> with the key <code>TheBestSecretKey</code>. and the results after Base64 encoding are:</p>

<p>for iOS: <code>9wXUiV+ChoLHmF6KraVtDQ==</code></p>

<p>for Java: <code>/s5YyKb3tDlUXt7pqA5OFA==</code></p>

<p>What should I do now?</p>
"	NULL	5	NULL	01:32.2	8	02:35.4	55:25.7	NULL	2399979	2399979	0	1	4	<java><android><ios><aes>	AES gets different results in iOS (Obj-C) and Android (Java)	14401	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
17967836	17971012	1	"<p>Am a new to J2ME. Currently am told to do a project which require AES encryption. I got a code snippet after some search on Google. The code does encrypt but when when trying to decrypt am getting error ""Invalidkeyexception""</p>

<p>The code is</p>

<pre><code>package com.cellapp.voda.vault.others;

import java.security.*;
import java.security.spec.InvalidKeySpecException;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;


public class Codec {

    private Cipher cipher = null;
    private boolean operative = true;

    public Codec() {

        try {
            cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            // This should not happen since we know the target platform
            // but we set the operative flag to false just in case
            operative = false;
        } catch (NoSuchPaddingException e) {
            // This should not happen since we know the target platform
            // but we set the operative flag to false just in case
            operative = false;
        }
    }


    public void encrypt(byte[] keyBits, byte[] plaintext)
            throws InvalidKeySpecException, InvalidKeyException,
            IllegalStateException, ShortBufferException,
            IllegalBlockSizeException, BadPaddingException,
            InvalidAlgorithmParameterException {
            byte[] cipherText = null;
        if (operative) {
           try{
                // Initialize the key from  the password
            Key key = new SecretKeySpec(keyBits, 0, keyBits.length, ""AES"");
            // add 2 bytes to encode the length of the plaintext
            // as a short value
            byte[] plaintextAndLength = new byte[plaintext.length + 2];
            plaintextAndLength[0] = (byte) (0xff &amp; (plaintext.length &gt;&gt; 8));
            plaintextAndLength[1] = (byte) (0xff &amp; plaintext.length);
            // build the new plaintext
            System.arraycopy(plaintext,
                    0,
                    plaintextAndLength,
                    2,
                    plaintext.length);

            // calculate the size of the ciperthext considering
            // the padding
            int blocksize = 16;
            int ciphertextLength = 0;
            int remainder = plaintextAndLength.length % blocksize;
            if (remainder == 0) {
                ciphertextLength = plaintextAndLength.length;
            } else {
                ciphertextLength = plaintextAndLength.length - remainder
                        + blocksize;
            }
            cipherText = new byte[ciphertextLength];

            // reinitialize the cipher in encryption mode with the given key
            cipher.init(Cipher.ENCRYPT_MODE, key);
            // do the encryption
            cipher.doFinal(plaintextAndLength,
                    0,
                    plaintextAndLength.length,
                    cipherText,
                    0);
           }
           catch(Exception e)
           {
               System.out.println(""TT "" + cipherText);
           }


        } else {
            throw new IllegalStateException(""Codec not initialized"");
        }
    }

    public void decrypt(byte[] keyBits, byte[] cipherText)
            throws InvalidKeySpecException, InvalidKeyException,
            IllegalStateException, ShortBufferException,
            IllegalBlockSizeException, BadPaddingException,
            InvalidAlgorithmParameterException {
        if (operative) {
            // create a key from the keyBits
            Key key = new SecretKeySpec(keyBits, 0, keyBits.length, ""AES"");

            // Initialize the cipher in decrypt mode
            cipher.init(Cipher.DECRYPT_MODE, key);

            byte[] decrypted = new byte[cipherText.length];
            // Decrypt the cipher text
            cipher.doFinal(cipherText, 0, cipherText.length, decrypted, 0);
            // Calculate the length of the plaintext
            int plainTextLength = (decrypted[0] &lt;&lt; 8)
                    | (decrypted[1] &amp; 0xff);
            byte[] finalText = new byte[plainTextLength];
            // Decode the final text
            System.arraycopy(decrypted, 2, finalText, 0, plainTextLength);

            System.out.println(""fina;  text "" + finalText);
        } else {
            throw new IllegalStateException(""Codec not initialized"");
        }
    }

    // Displays ecrypted data in hex
    public String byteToHex(byte[] data) {
        StringBuffer hexString = new StringBuffer();
        String hexCodes = ""0123456789ABCDEF"";

        for (int i = 0; i &lt; data.length; i++) {
            hexString.append(hexCodes.charAt((data[i] &gt;&gt; 4) &amp; 0x0f));
            hexString.append(hexCodes.charAt(data[i] &amp; 0x0f));
            if (i &lt; data.length - 1) {
                hexString.append("":"");
            }
            if (((i + 1) % 8) == 0) {
                hexString.append(""\n"");
            }
        }
        return hexString.toString();
    }
}
</code></pre>
"	NULL	4	NULL	24:40.6	3	42:09.1	42:09.1	NULL	1033581	1510391	0	1	1	<encryption><java-me><aes>	Invalidkeyexception in AES algorithm	413	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
18234234	18234400	1	"<p>I am trying to add my 16-bit IV used to encrypt my data as the final block in the byte array used to hold the encrypted data.  I want to do this obviously for the decryption part so that I can use a completely random IV for each encryption/decryption call.  I have the following for testing purposes:</p>

<pre><code>public static String encrypt(String plainText) throws Exception {
   encryptionKey = new SecretKeySpec(eKey.getBytes(""UTF-8""), ""AES"");

   cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
   cipher.init(Cipher.ENCRYPT_MODE, encryptionKey, initialisationVector);

   byte[] eDataAndIv = appendIvToEncryptedData(cipher.doFinal(plainText.getBytes(""UTF-8"")), initialisationVector.getIV());
   return bytesToHexString(eDataAndIv);
}

public static String decrypt(String hexEncoded) throws Exception {
   byte[] decodedBytes = hexStringToBytes(hexEncoded);

   ArrayList&lt;byte[]&gt; al = retreiveIvFromByteArray(decodedBytes);
   byte[] eData = al.get(0);
   byte[] iv = al.get(1);

   cipher.init(Cipher.DECRYPT_MODE, encryptionKey, new IvParameterSpec(iv));
   return reconstructedPlainText(cipher.doFinal(eData));
}

private static byte[] appendIvToEncryptedData(byte[] eData, byte[] iv) throws Exception {
   ByteArrayOutputStream os = new ByteArrayOutputStream();
   os.write(eData);
   os.write(iv);
   return os.toByteArray();
}

private static ArrayList&lt;byte[]&gt; retreiveIvFromByteArray(byte[] dataPlusIv) {
   ByteArrayOutputStream iv = new ByteArrayOutputStream(16);
   ByteArrayOutputStream eData = new ByteArrayOutputStream();

   iv.write(dataPlusIv, dataPlusIv.length - 16, 16);
   eData.write(dataPlusIv, 0, dataPlusIv.length - 16);

   ArrayList&lt;byte[]&gt; al = new ArrayList&lt;byte[]&gt;();
   al.add(eData.toByteArray());
   al.add(iv.toByteArray());

   return al;
}
</code></pre>

<p>The list of steps for encryption are:</p>

<ol>
<li>Create IV</li>
<li>Encrypt data</li>
<li>Append IV to end of encrypted data byte array</li>
<li>Encode byte array using hex</li>
</ol>

<p>The list of steps for decryption are:</p>

<ol>
<li>Decode hex</li>
<li>Break encrypted data and IV from byte array</li>
<li>Decrypt data using IV</li>
</ol>

<p>What I have works, but I guess what I want to know is, is there a ""better"" way of doing this?  By that I mean, is there a set, or simpler, way to do this using the <code>Cipher*</code> types?  I can't find them.</p>

<p>Thanks.</p>
"	NULL	1	NULL	16:59.3	5	23:35.6	NULL	NULL	0	575596	0	1	3	<java><security><encryption><initialization-vector>	Adding the IV to the encrypted byte array as final block	2861	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
18291987	18292690	1	"<p>Ello mates! I am attempting to make a chat program that uses AES encryption but I have ran into a problem. When I try to run the program, it gives the error that you can see in the title. I will give you the code for both classes because it seems that, that is the only way to fully diagnose the problem. There are many duplicates of this but none seem to answer my specific problem. Thanks for all your help!
Client:</p>

<pre><code>package Chat.Application;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import java.security.spec.AlgorithmParameterSpec;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.BASE64Encoder;

/**
 * A simple Swing-based client for the chat server. Graphically it is a frame
 * with a text field for entering messages and a textarea to see the whole
 * dialog.
 *
 * The client follows the Chat Protocol which is as follows. When the server
 * sends ""SUBMITNAME"" the client replies with the desired screen name. The
 * server will keep sending ""SUBMITNAME"" requests as long as the client submits
 * screen names that are already in use. When the server sends a line beginning
 * with ""NAMEACCEPTED"" the client is now allowed to start sending the server
 * arbitrary strings to be broadcast to all chatters connected to the server.
 * When the server sends a line beginning with ""MESSAGE "" then all characters
 * following this string should be displayed in its message area.
 */
public class ChatClient {

    BufferedReader in;
    PrintWriter out;
    JFrame frame = new JFrame(""ELECTRON Chatroom"");
    JTextField textField = new JTextField(40);
    JTextArea messageArea = new JTextArea(8, 40);
        Cipher cipher;
        // password for encryption
        final String strPassword = ""1234567890123456"";
        // put this as key in AES
        final SecretKeySpec key = new SecretKeySpec(strPassword.getBytes(), ""AES"");
    /**
     * Constructs the client by laying out the GUI and registering a listener
     * with the textfield so that pressing Return in the listener sends the
     * textfield contents to the server. Note however that the textfield is
     * initially NOT editable, and only becomes editable AFTER the client
     * receives the NAMEACCEPTED message from the server.
     */
    public ChatClient() {

        // Layout GUI
        textField.setEditable(false);
        messageArea.setEditable(false);
        messageArea.setWrapStyleWord(true);
        messageArea.setLineWrap(true);
        frame.getContentPane().add(textField, ""North"");
        frame.getContentPane().add(new JScrollPane(messageArea), ""Center"");
        frame.pack();


        // Add Listeners
        textField.addActionListener(new ActionListener() {
            /**
             * Responds to pressing the enter key in the textfield by sending
             * the contents of the text field to the server. Then clear the text
             * area in preparation for the next message.
             */
            @Override
            public void actionPerformed(ActionEvent e) {
                try {
                    String input = (textField.getText());
                    //ENCRYPTION
                    // Parameter specific algorithm
                    AlgorithmParameterSpec paramSpec = new IvParameterSpec(strPassword.getBytes());
                    //Whatever you want to encrypt/decrypt
                    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

                    // You can use ENCRYPT_MODE (ENCRYPTunderscoreMODE)  or DECRYPT_MODE (DECRYPT underscore MODE) 

                    cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

                    // encrypt data 
                    byte[] encrypted = cipher.doFinal(input.getBytes());

                    // encode data using standard encoder
                    //String output = new BASE64Encoder().encode(encrypted);

                    System.out.println(""Orginal tring: "" + input);
                    System.out.println(""Encrypted string: "" + encrypted);

                    textField.setText("""");
                } catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException | InvalidAlgorithmParameterException ex) {
                    Logger.getLogger(ChatClient.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    /**
     * Prompt for and return the address of the server.
     */
    private String getServerAddress() {
        return JOptionPane.showInputDialog(
                frame,
                ""Enter IP Address of the Server:"",
                ""ELECTRON Chatroom"",
                JOptionPane.QUESTION_MESSAGE);
    }

    /**
     * Prompt for and return the desired screen name.
     */
    private String getName() {
        return JOptionPane.showInputDialog(
                frame,
                ""Choose a screen name:"",
                ""Screen name selection"",
                JOptionPane.PLAIN_MESSAGE);
    }

    /**
     * Connects to the server then enters the processing loop.
     */
    private void run() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {

        // Make connection and initialize streams
        String serverAddress = getServerAddress();
        Socket socket = new Socket(serverAddress, 9001);
        in = new BufferedReader(new InputStreamReader(
                socket.getInputStream()));
        out = new PrintWriter(socket.getOutputStream(), true);
        // Process all messages from server, according to the protocol.
        while (true) {
            String line = in.readLine();
            if (line.startsWith(""SUBMITNAME"")) {
                out.println(getName());
            } else if (line.startsWith(""NAMEACCEPTED"")) {
                textField.setEditable(true);
            } else if (line.startsWith(""MESSAGE"")) {
                //DECRYPTION
                line = line.substring(8);
                System.out.println(line);
                // Parameter specific algorithm
                AlgorithmParameterSpec paramSpec = new IvParameterSpec(strPassword.getBytes());
                //Whatever you want to encrypt/decrypt
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

                // You can use ENCRYPT_MODE (ENCRYPTunderscoreMODE)  or DECRYPT_MODE (DECRYPT underscore MODE) 
                cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
                byte messageByte[] = cipher.doFinal(line.getBytes());
                String message = new String(messageByte, ""UTF-8"");
                messageArea.append(message.substring(8) + ""\n"");
                System.out.println(message);
            }
        }
    }

    /**
     * Runs the client as an application with a closeable frame.
     */
    public static void main(String[] args) throws Exception {
        ChatClient client = new ChatClient();
        client.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        client.frame.setVisible(true);
        client.run();
    }
}
</code></pre>

<p>Server: </p>

<pre><code>package Chat.Application;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashSet;

import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

/**
 * A multi-threaded chat room server.  When a client connects the
 * server requests a screen name by sending the client the
 * text ""SUBMITNAME"", and keeps requesting a name until
 * a unique one is received.  After a client submits a unique
 * name, the server acknowledges with ""NAMEACCEPTED"".  Then
 * all messages from that client will be broadcast to all other
 * clients that have submitted a unique screen name.  The
 * broadcast messages are prefixed with ""MESSAGE "".
 *
 * Because this is just a teaching example to illustrate a simple
 * chat server, there are a few features that have been left out.
 * Two are very useful and belong in production code:
 *
 *     1. The protocol should be enhanced so that the client can
 *        send clean disconnect messages to the server.
 *
 *     2. The server should do some logging.
 */
public class ChatServer {

    /**
     * The port that the server listens on.
     */
    private static final int PORT = 9001;

    /**
     * The set of all names of clients in the chat room.  Maintained
     * so that we can check that new clients are not registering name
     * already in use.
     */
    private static HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();

    /**
     * The set of all the print writers for all the clients.  This
     * set is kept so we can easily broadcast messages.
     */
    private static HashSet&lt;PrintWriter&gt; writers = new HashSet&lt;PrintWriter&gt;();

    /**
     * The application main method, which just listens on a port and
     * spawns handler threads.
     */
    public static void main(String[] args) throws Exception {
        System.out.println(""Chat Server Activated"");
        ServerSocket listener = new ServerSocket(PORT);
        try {
            while (true) {
                new Handler(listener.accept()).start();
            }
        } finally {
            listener.close();
        }
    }

    /**
     * A handler thread class.  Handlers are spawned from the listening
     * loop and are responsible for a dealing with a single client
     * and broadcasting its messages.
     */
    private static class Handler extends Thread {
        private String name;
        private Socket socket;
        private BufferedReader in;
        private PrintWriter out;
        private Integer length;

        /**
         * Constructs a handler thread, squirreling away the socket.
         * All the interesting work is done in the run method.
         */
        public Handler(Socket socket) {
            this.socket = socket;
        }

        /**
         * Services this thread's client by repeatedly requesting a
         * screen name until a unique one has been submitted, then
         * acknowledges the name and registers the output stream for
         * the client in a global set, then repeatedly gets inputs and
         * broadcasts them.
         */
        public void run() {
            try {

                // Create character streams for the socket.
                in = new BufferedReader(new InputStreamReader(
                    socket.getInputStream()));
                out = new PrintWriter(socket.getOutputStream(), true);
                // Request a name from this client.  Keep requesting until
                // a name is submitted that is not already used.  Note that
                // checking for the existence of a name and adding the name
                // must be done while locking the set of names.
                while (true) {
                    out.println(""SUBMITNAME"");

                /*Supposed to change anybody who tries to login as Admin into different name... ""Supposed"" to....
                    if (name.equals(""Admin"")) {
                        out.println(""SUBMITNAME"");
                        return;
                    }*/

                    name = in.readLine();
                    length = name.length();
                    if (length == 0) {
                        out.println(""SUBMITNAME"");
                        return;
                    }
                    if (name == ""null"") {
                        out.println(""SUBMITNAME"");
                        return;
                    }
                        synchronized (names) {
                        if (!names.contains(name)) {
                            names.add(name);
                            break;
                        }
                    }
                }
                // Now that a successful name has been chosen, add the
                // socket's print writer to the set of all writers so
                // this client can receive broadcast messages.
                out.println(""NAMEACCEPTED"");
                //Announces that user is Online
                out.println(""MESSAGE "" + name + "" is now Online"");

                for (PrintWriter writer : writers) {
                writer.println(""MESSAGE "" + name + "" is now Online"");
                }
                writers.add(out);
                // Accept messages from this client and broadcast them.
                // Ignore other clients that cannot be broadcasted to.
                while (true) {
                    String input = in.readLine();
                    System.out.println(input);
                    if (input == null) {
                        return;
                    }
                    for (PrintWriter writer : writers) {
                        writer.println(""MESSAGE "" + name + "": "" + input);
                    }
                }
            } catch (IOException e) {
                System.out.println(e);
            } finally {
                // This client is going down!  Remove its name and its print
                // writer from the sets, and close its socket.
                for (PrintWriter writer : writers) {
                writer.println(""MESSAGE "" + name + "" is now Offline"");
                }                if (name != null) {
                    names.remove(name);
                }
                if (out != null) {
                    writers.remove(out);
                }
                try {
                    socket.close();
                } catch (IOException e) {
                }
            }
        }
    }
}
</code></pre>

<p>Thanks so much for all your help in saving a complete noob at programming! </p>

<p>-Silver</p>
"	NULL	0	NULL	22:14.0	0	07:59.7	30:55.9	NULL	2586054	2586054	0	1	2	<java><aes>	Java Error: Input length must be multiple of 16 when decrypting with padded cipher	16200	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
18521252	18521562	1	"<p>Before you mark this as a duplicate, please read the full question.</p>

<p>I've looked through countless questions here about this problem, and every answer said to install JCE. However, if I want to send the program to someone else, another computer, virtually anything off the development computer, they have to install JCE too.</p>

<p>Is there a way I can use a smaller keysize without having to install anything?</p>

<p>My encryption method;</p>

<pre><code>public static String encrypt(String in) throws NoSuchAlgorithmException,
   NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException,
   IllegalBlockSizeException, BadPaddingException, IOException {

    String out = "" "";

    // generate a key
    KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
    keygen.init(128);
    byte[] key = keygen.generateKey().getEncoded();
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    // build the initialization vector
    SecureRandom random = new SecureRandom();
    byte iv[] = new byte[16]; //generate random 16 byte IV. AES is always 16bytes
    random.nextBytes(iv);
    IvParameterSpec ivspec = new IvParameterSpec(iv);

    saveKey(key, iv); //&lt;-- save to file

    // initialize the cipher for encrypt mode
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);

    byte[] encrypted = cipher.doFinal(in.getBytes());

    out = asHex(encrypted);

    return out;
}
</code></pre>

<p>And my decrypt method:</p>

<pre><code>public static String decrypt(String in) throws NoSuchAlgorithmException,
  NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException,
  IllegalBlockSizeException, BadPaddingException, IOException, KeyFileNotFoundException, UnknownKeyException {

    String out = "" "";

    byte[] key = readKey(""key"").clone(); //&lt;--from file
    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    byte[] iv = readKey(""iv""); //&lt;-- from file
    IvParameterSpec ivspec = new IvParameterSpec(iv);

    //initialize the cipher for decryption
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);

    // decrypt the message
    byte[] decrypted = cipher.doFinal(in.getBytes());

    out = asHex(decrypted);

    return out;
}
</code></pre>

<p>My saveKey() method:</p>

<pre><code>private static void saveKey(byte[] key, byte[] iv) throws FileNotFoundException, IOException {

    File keyFile = new File(Logging.getCurrentDir() + ""\\cikey.key"");

    keys.setProperty(""key"", asHex(key));
    keys.setProperty(""iv"", asHex(iv));

    keys.store(new FileOutputStream(keyFile.getAbsolutePath(), false), null);
}
</code></pre>

<p>My readKey() method:</p>

<pre><code> private static byte[] readKey(String request) throws KeyFileNotFoundException, UnknownKeyException, FileNotFoundException, IOException {

    File keyFile = new File(Logging.getCurrentDir() + ""\\cikey.key"");
    byte[] storage;

    keys.load(new FileInputStream(keyFile));

    if (!keyFile.exists())
        throw new KeyFileNotFoundException(""Key file not located."");

    if (keys.containsKey(request) == false)
        throw new UnknownKeyException(""Key not found."");
    else
        storage = keys.getProperty(request).getBytes();

    return storage;
}
</code></pre>

<p>asHex() method (transferring array to String):</p>

<pre><code>public static String asHex(byte buf[]) {

    StringBuilder strbuf = new StringBuilder(buf.length * 2);

    for (int i = 0; i &lt; buf.length; i++) {
        if (((int) buf[i] &amp; 0xff) &lt; 0x10)
            strbuf.append(""0"");

        strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
    }
    return strbuf.toString();
}
</code></pre>
"	NULL	2	NULL	27:22.1	4	30:50.8	15:24.1	NULL	1198189	1198189	0	1	4	<java><cryptography>	InvalidKeyException: Illegal key size	8568	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
19161819	0	2	"<p>I was using the below code in my app for encrypting and decrypting passwords. It was working fine until suddenly I noticed it fail. The only change I remember doing is to update my ADT and eclipse a few days ago to latest version. Not sure why is it failing now. It works if I create new encryptions. But if I use any encrypted password which was generated earlier and pass it to the code below for decrypting, then the error comes. It is failing in the line ""byte[] plainBytes = cipher.doFinal(cipherBytes);""</p>

<p>My decryption code below</p>

<pre><code>        String keyword  = ""keyword"";
        int iterationCount = 1000; 
        int keyLength = 256;
        String[] fields = encryptedPassword.split(""]"");
        byte[] salt = fromBase64(fields[0]);
        byte[] cipherBytes = fromBase64(fields[1]);
        KeySpec keySpec = new PBEKeySpec(keyword.toCharArray(), salt, iterationCount, keyLength);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWITHSHA256AND256BITAES-CBC-BC"");
        SecretKey key = keyFactory.generateSecret(keySpec);
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, iterationCount);
        cipher.init(Cipher.DECRYPT_MODE, key, pbeSpec);
        byte[] plainBytes = cipher.doFinal(cipherBytes);
        plainStr = new String(plainBytes, ""UTF-8"").trim();
        return plainStr;
</code></pre>

<p>and the error I am getting is below</p>

<pre><code>java.lang.RuntimeException: javax.crypto.BadPaddingException: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
</code></pre>

<p>Can anyone please help here</p>
"	NULL	0	NULL	26:04.1	5	03:53.1	46:36.5	NULL	1938357	1938357	0	1	3	<android><security>	not able to decrypt anymore	1340	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
19172479	19173278	1	"<p>I have written a simple Java AES encryption and decryption as below (for learning purpose):</p>

<pre><code>//Encryption 
Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");  
SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
 String encryptedString = Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes()));
return encryptedString;

//Decryption
Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");
cipher.init(Cipher.DECRYPT_MODE, secretKey);
String decryptedString = new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt)));
return decryptedString;
</code></pre>

<p>The cipher key is a variable-length string, I MD5 hash the string to get the 128 bit key. </p>

<p>I can successfully encrypt and decrpyt the data using the same key. But if I decrypt the data with wrong key, I got the exception below:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
</code></pre>

<p>Actually what I expect is, a wrong bytes produced from wrong-key-decryption, but not exception thrown like above, because if wrong bytes are produced, hacker might not know whether the decryption is correct or not. If exception thrown like above, the output of brute force will become easier to determine.</p>

<p>So, what happen to my code?</p>

<p><strong>Edit:</strong></p>

<p>I think I made a mistake here. The hacker might not use my program to decrypt. So for AES, if a person is decrypting fail, he will know the decryption was fail but not as I thought that getting wrong bytes from decryption? This is terrible...</p>
"	NULL	2	NULL	01:19.0	0	11:38.4	20:58.9	NULL	1542363	1542363	0	1	1	<java><encryption><aes><badpaddingexception>	Java AES decryption with wrong key	2451	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
19195657	0	1	"<p>Hi i'm new to android and Image encryption.
My scenario is like this,</p>

<ul>
<li>first I'm encrypting the image file.</li>
<li>Then I'm uploading it to the Server</li>
<li>From my app I'm downloading encrypted image and saving it in SD card.</li>
<li>then I'm decrypting it before set it to the imageView</li>
</ul>

<p>(See bottom for all need methods I have used..)</p>

<p><strong>But I'm getting javax.crypto.BadPaddingException: pad block corrupted when decrypting. I read some articles about this exception but all are about text encryption. Can you help me to avoid this. Thank you in advance</strong> </p>

<p>Image Encrption using ...</p>

<pre><code>private byte[] encrypt(byte[] raw, byte[] clear) throws Exception
{
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}
</code></pre>

<p>Here I'm saving several other images as well, all saved in sd card successfully...</p>

<pre><code>for (int i = 0; i &lt; imageUrls.size(); i++)
                {
                    File file = new File(imageUrls.get(i));

                    String metapath = CommonUtils.getDataFromPreferences(""metaPath"", """");
                    Log.d(""metapath"", metapath);
                    String extStorageDirectory = metapath + file.getName();

                    File wallpaperDirectory = new File(extStorageDirectory);
                    if (!wallpaperDirectory.exists() || wallpaperDirectory.length() == 0)
                    {
                        new DownloadImagesTask()
                            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, imageUrls.get(i));
                    }
                }
                Toast toast = Toast.makeText(ScratchDetailsActivity.this, ""Lottery was purchased and saved to sdcard/E-Lottery"",
                    Toast.LENGTH_LONG);
                toast.setGravity(Gravity.CENTER, 0, 0);
                toast.show();
</code></pre>

<p>Image decryption...</p>

<p>decrypt the file here first argument is key and second is encrypted file which we get from SD card.</p>

<pre><code>        decrpt = simpleCrypto.decrypt(KEY, getImageFileFromSdCard());
        bmpimg2 = BitmapFactory.decodeByteArray(decrpt, 0, decrpt.length);
        Drawable d = new BitmapDrawable(getResources(), bmpimg2);
        hiddenImage.setImageDrawable(d);
</code></pre>

<p>DownloadImageTask..</p>

<pre><code>public class DownloadImagesTask extends AsyncTask&lt;String, Void, InputStream&gt;{
private String fileName;

@Override
protected InputStream doInBackground(String... urls)
{
    //Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
    return download_Image(urls[0]);
}

@Override
protected void onPostExecute(InputStream result)
{
    storeImage(result);

}

private InputStream download_Image(String url)
{
    InputStream is = null;
    File file = new File(url);
    fileName = file.getName();
    try
    {
        URL aURL = new URL(url);
        URLConnection conn = aURL.openConnection();
        conn.connect();
        is = conn.getInputStream();
    }
    catch (OutOfMemoryError e)
    {
        Log.e(""Hub"", ""Error getting the image from server : "" + e.getMessage().toString());
    }
    catch (IOException e)
    {
        Log.e(""Hub"", ""Error getting the image from server : "" + e.getMessage().toString());
    }

    return is;
}

public void storeImage(InputStream is)
{

    String extStorageDirectory = CommonUtils.getDataFromPreferences(""metaPath"", """");

    Log.d(""extStorageDirectory"", extStorageDirectory);
    OutputStream outStream = null;

    File wallpaperDirectory = new File(extStorageDirectory);
    if (!wallpaperDirectory.exists())
    {
        wallpaperDirectory.mkdirs();
    }
    File outputFile = new File(wallpaperDirectory, fileName);
    if (!outputFile.exists() || outputFile.length() == 0)
    {
        try
        {
            outStream = new FileOutputStream(outputFile);
        }
        catch (FileNotFoundException e1)
        {
            e1.printStackTrace();
        }

        try
        {
            int bytesRead = -1;
            byte[] buffer = new byte[4096];
            while ((bytesRead = is.read(buffer)) != -1)
            {
                outStream.write(buffer, 0, bytesRead);
            }

            outStream.close();
            is.close();
            Log.d(""ScratchActivtiy"", ""Image Saved"");

        }
        catch (FileNotFoundException e)
        {
            e.printStackTrace();

        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}}
</code></pre>

<p>getImageFileFromSDCard method </p>

<pre><code>/**
     * This method fetch encrypted file which is save in sd card and convert it in byte array after that this file will
     * be decrept.
     * 
     * @return byte array of encrypted data for decription.
     * @throws FileNotFoundException
     */

public byte[] getImageFileFromSdCard() throws FileNotFoundException
{

    byte[] inarry = null;

    try
    {
        String metapath = CommonUtils.getDataFromPreferences(""metaPath"", """");

        File imageFolder = new File(metapath);
        File urlFile = new File(selectedLottery.getImage());

        for (File f : imageFolder.listFiles())
        {
            if (urlFile.getName().equals(f.getName()))
                metapath = metapath + f.getName();
        }
        File imageFile = new File(metapath);
        //Convert file into array of bytes.
        FileInputStream fileInputStream = null;
        byte[] bFile = new byte[(int) imageFile.length()];
        fileInputStream = new FileInputStream(imageFile);
        fileInputStream.read(bFile);
        fileInputStream.close();
        inarry = bFile;

    }
    catch (IOException e)
    {
        Log.d(""Exception"", e.getMessage());
    }

    return inarry;
}
</code></pre>
"	NULL	0	NULL	30:02.7	4	05:15.0	NULL	NULL	0	2291506	0	1	2	<java><android><encryption><cryptography>	"When Decrypting Image, gives javax.crypto.BadPaddingException: pad block corrupted Android"	3527	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
19698272	19732622	5	"<p>1.I have java function which encrypt xml file and return encrypted String.</p>

<pre><code>/// Java Class 
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Crypt {

    public static String key = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    public static byte[] key_Array = Base64.decodeBase64(key);

    public static String encrypt(String strToEncrypt)
    {       
        try
        {   
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            //Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");      

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");

            Cipher _Cipher = Cipher.getInstance(""AES"");     
            _Cipher.init(Cipher.ENCRYPT_MODE, SecretKey);       

            return Base64.encodeBase64String(_Cipher.doFinal(strToEncrypt.getBytes()));     
        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());
        }
        return null;
    }

    public static void main(String[] args) {        
        StringBuilder sb = new StringBuilder();
        sb.append(""xml file string ..."");

        String EncryptedString = encrypt(sb.toString());        
        System.out.println(""[EncryptedString]:""+EncryptedString);
    }
}
</code></pre>

<p>2.I have c# function which decrypt the message which is encrypted by java function.</li></p>

<pre><code>/// C# Function
private static string Decrypt(string encryptedText)
{
    RijndaelManaged aesEncryption = new RijndaelManaged();            
    aesEncryption.BlockSize = 256;
    //aesEncryption.KeySize = 256;
    //aesEncryption.Mode = CipherMode.CBC;
    //aesEncryption.Padding = PaddingMode.PKCS7;

    string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    //string ivStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";        

    byte[] keyArr = Convert.FromBase64String(keyStr);
    //byte[] ivArr = Convert.FromBase64String(ivStr);

    aesEncryption.Key = keyArr;
    //aesEncryption.IV = ivArr;

    ICryptoTransform decrypto = aesEncryption.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(encryptedText.ToCharArray(), 0, encryptedText.Length);  
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length); /// CryptographicException: Length of the data to decrypt is invalid.    
    return ASCIIEncoding.UTF8.GetString(decryptedData); 
}
</code></pre>

<p>Java encrypt function is work well. But the problem is C# function, <br>when I decrypt I get below error message</p>

<pre><code>CryptographicException: Length of the data to decrypt is invalid.
</code></pre>

<p>I searched solutions by using below ref</p>

<ol>
<li><a href=""https://stackoverflow.com/questions/5295110/aes-encryption-in-java-and-decryption-in-c-sharp"">AES Encryption in Java and Decryption in C#</a></li>
<li><a href=""https://stackoverflow.com/questions/9584167/c-sharp-java-aes256-encrypt-decrypt"">C# / Java | AES256 encrypt/decrypt</a></li>
<li><a href=""http://lamahashim.blogspot.sg/2009/08/encyptiondecryption-in-c-and-java.html"" rel=""noreferrer"">Encyption/Decryption in C# and Java</a></li>
</ol>

<p>but I still face the same error.Could anyone give me suggestion please.</p>

<h2>Updated</h2>

<p>I Just change my C# crypto function. Below is my change lists</p>

<ol>
<li>Block Size to 128</li>
<li>Key Size to 256</li>
<li>IV Size to 16</li>
<li>Key Size to 32</li>
</ol>

<pre><code>/// Updated decrypt function
private static string Decrypt(string encryptedText)
{
    RijndaelManaged aesEncryption = new RijndaelManaged();            
    aesEncryption.BlockSize = 128;
    aesEncryption.KeySize = 256;

    //aesEncryption.Mode = CipherMode.CBC;
    aesEncryption.Padding = PaddingMode.None;

    string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    string ivStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";           

    byte[] ivArr = Convert.FromBase64String(ivStr);
    byte[] IVkey16BytesValue = new byte[16];
    Array.Copy(ivArr, IVkey16BytesValue, 16);

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArr32BytesValue = new byte[32];
    Array.Copy(keyArr, KeyArr32BytesValue, 32);

    aesEncryption.IV = IVkey16BytesValue;
    aesEncryption.Key = KeyArr32BytesValue; 

    ICryptoTransform decrypto = aesEncryption.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(encryptedText.ToCharArray(), 0, encryptedText.Length);
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length); 
    return ASCIIEncoding.UTF8.GetString(decryptedData);
}
</code></pre>

<p>In this time, no error occur. But I get decrypted message which i cannot read.</p>

<pre><code>g:?\0?\td??Y\\?O????\rL??W?wHm?&gt;f?\au????%??0??\ ..........
</code></pre>

<p>Please let me get your suggestion again. </p>
"	NULL	11	NULL	08:38.3	9	09:18.5	47:35.4	NULL	-1	900284	0	1	15	<c#><java><encryption><aes>	Encrypt in java and Decrypt in C# For AES 256 bit	39062	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
19957052	20053311	4	"<p>In this code, this line is causing an exception:</p>

<p><code>clearText = c.doFinal(Base64.decode(encryptedText, Base64.DEFAULT));</code></p>

<p><code>javax.crypto.BadPaddingException: pad block corrupted</code></p>

<p>I got the code from:
<a href=""http://www.techrepublic.com/blog/software-engineer/attention-android-developers-keep-user-data-safe/"" rel=""noreferrer"">http://www.techrepublic.com/blog/software-engineer/attention-android-developers-keep-user-data-safe/</a></p>

<p>Any ideas?</p>

<pre><code>    private String decrypt (String encryptedText) {
        byte[] clearText = null;
        try {
            SecretKeySpec ks = new SecretKeySpec(getKey(), ""AES"");
            Cipher c = Cipher.getInstance(""AES"");
            c.init(Cipher.DECRYPT_MODE, ks);
            clearText = c.doFinal(Base64.decode(encryptedText, Base64.DEFAULT));
            return new String(clearText, ""UTF-8"");
        } catch (Exception e) {
            return null;
        }
    }
</code></pre>

<p>Details: I am encrypting it on the android as well</p>
"	NULL	0	NULL	00:40.8	7	00:09.9	16:27.1	NULL	238704	2589276	0	1	5	<java><android><exception><encryption><aes>	"Android encryption ""pad block corrupted"" exception"	20531	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20045235	20189160	1	"<p>I'm trying to send some information from 1 web application to an android app, however the information has to be stored encrypted in the web application.
To this end I'm trying to use a Symmetric key to encrypt the data in my web application and use the same key to decrypt it in the app. </p>

<p>The following is my code to generate the encrypted data on the server:</p>

<pre><code>String key = ""someData"";

    SecretKeySpec sks = null;
    try {
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(""exSeed"".getBytes());
        KeyGenerator kg = KeyGenerator.getInstance(""AES"");
        kg.init(128, sr);
        sks = new SecretKeySpec((kg.generateKey()).getEncoded(), ""AES"");
    } catch (Exception e) {
    }

    byte[] encodedBytes = null;
    try {
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.ENCRYPT_MODE, sks);
        encodedBytes = c.doFinal(key.getBytes());
    } catch (Exception e) {
    }
    jTextField5.setText(Base64.encode(encodedBytes));
</code></pre>

<p>And the following is my code to read the data in the app:</p>

<pre><code>    SecretKeySpec sks = null;
    try {
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(""exSeed"".getBytes());
        KeyGenerator kg = KeyGenerator.getInstance(""AES"");
        kg.init(128, sr);
        sks = new SecretKeySpec((kg.generateKey()).getEncoded(), ""AES"");
    } catch (Exception e) {
        Log.e(TAG, ""AES secret key spec error"");
    }

    byte[] decodedBytes = null;
    try {
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, sks);
        decodedBytes = c.doFinal(key);
    } catch (Exception e) {
        Log.e(TAG, ""AES decryption error"");
    }
    String decoded = new String(decodedBytes);
</code></pre>

<p>Now the problem I run into is that when decoding I get the following exception: javax.crypto.BadPaddingException: pad block corrupted</p>

<p>I suspect this is because the secureRandom does not generate the same number in a regular application and an android application (despite having the same seed). However I do not see a way to use another way to use secureRandom or a way to not use it.</p>

<p>Any help to get this working would be greatly appriciated, as would any comment about how secure this method of encryption is.</p>
"	NULL	6	NULL	15:39.0	3	59:11.4	NULL	NULL	0	2742428	0	1	0	<java><android><security><random>	decode encrypted information on android	299	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20063239	20134336	2	"<p>I am writing an android app that decrypts some text stored in a file. I used the following code - </p>

<pre><code>public class SimpleCrypto {
    public static String encrypt(String seed, String cleartext)
            throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted)
            throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted)
            throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);//this is the line that throws error
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
                    16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }

}
</code></pre>

<p>EDIT: This is the text that I am trying to decrypt -</p>

<pre><code>39D4CA73AAF2D42C32659FDC5D1848EA
</code></pre>

<p>with this key -</p>

<pre><code>thebestsecret153
</code></pre>

<p>if that helps. it should show <code>in153</code>.</p>

<p>EDIT: The line that throws the error in android. -</p>

<pre><code>byte[] decrypted = cipher.doFinal(encrypted);
</code></pre>

<p>I also created a project in swing to read from a file and got the following error -</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:313)
    at javax.crypto.Cipher.doFinal(Cipher.java:2087)
    at decrypt.Decrypt.decrypt(Decrypt.java:43)
    at decrypt.MainForm.jButton1MouseClicked(MainForm.java:91)
    at decrypt.MainForm.access$000(MainForm.java:20)
    at decrypt.MainForm$1.mouseClicked(MainForm.java:46)
    at java.awt.AWTEventMulticaster.mouseClicked(AWTEventMulticaster.java:270)
    at java.awt.Component.processMouseEvent(Component.java:6508)
    at javax.swing.JComponent.processMouseEvent(JComponent.java:3320)
    at java.awt.Component.processEvent(Component.java:6270)
    at java.awt.Container.processEvent(Container.java:2229)
    at java.awt.Component.dispatchEventImpl(Component.java:4861)
    at java.awt.Container.dispatchEventImpl(Container.java:2287)
    at java.awt.Component.dispatchEvent(Component.java:4687)
    at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4832)
    at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4501)
    at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4422)
    at java.awt.Container.dispatchEventImpl(Container.java:2273)
    at java.awt.Window.dispatchEventImpl(Window.java:2719)
    at java.awt.Component.dispatchEvent(Component.java:4687)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:735)
    at java.awt.EventQueue.access$200(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:694)
    at java.awt.EventQueue$3.run(EventQueue.java:692)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
    at java.awt.EventQueue$4.run(EventQueue.java:708)
    at java.awt.EventQueue$4.run(EventQueue.java:706)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
Exception in thread ""AWT-EventQueue-0"" java.lang.NullPointerException
    at java.lang.String.&lt;init&gt;(String.java:556)
    at decrypt.MainForm.jButton1MouseClicked(MainForm.java:91)
    at decrypt.MainForm.access$000(MainForm.java:20)
    at decrypt.MainForm$1.mouseClicked(MainForm.java:46)
    at java.awt.AWTEventMulticaster.mouseClicked(AWTEventMulticaster.java:270)
    at java.awt.Component.processMouseEvent(Component.java:6508)
    at javax.swing.JComponent.processMouseEvent(JComponent.java:3320)
    at java.awt.Component.processEvent(Component.java:6270)
    at java.awt.Container.processEvent(Container.java:2229)
    at java.awt.Component.dispatchEventImpl(Component.java:4861)
    at java.awt.Container.dispatchEventImpl(Container.java:2287)
    at java.awt.Component.dispatchEvent(Component.java:4687)
    at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4832)
    at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4501)
    at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4422)
    at java.awt.Container.dispatchEventImpl(Container.java:2273)
    at java.awt.Window.dispatchEventImpl(Window.java:2719)
    at java.awt.Component.dispatchEvent(Component.java:4687)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:735)
    at java.awt.EventQueue.access$200(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:694)
    at java.awt.EventQueue$3.run(EventQueue.java:692)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
    at java.awt.EventQueue$4.run(EventQueue.java:708)
    at java.awt.EventQueue$4.run(EventQueue.java:706)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
</code></pre>

<p>It works perfectly if encryption and decryption is done in same program. </p>

<p>Any help is appreciated. Thanks in advance.</p>
"	NULL	0	NULL	30:02.1	4	05:51.0	11:37.5	NULL	2443043	2443043	0	1	1	<java><android><encryption>	function decrypt throws javax.crypto.BadPaddingException: pad block corrupted in class SimpleCrypto in android	10324	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20196658	20212056	1	"<p>I'm figuring out how to do cross platform (Android &amp; Python) encryption&amp;decryption using <code>AES</code>, and I seem to succeed transferring data if I use a <code>String</code> based IV. But immediately if I switch to using bytes generated with <code>SecureRandom.generateSeed()</code>, it goes awry. 
The secret keys are preshared.</p>

<p>Working Android code (try/catch blocks removed to keep it short):</p>

<pre><code>String SecretKey = ""0123456789abcdef"";
String iv = ""fedcba9876543210"";

IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());
SecretKeySpec keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

//Initialize the cipher
cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec); 

String message = ""What's up?"";
byte[] encrypted = cipher.doFinal(message.getBytes());

//Send the data
outputStream.write(encrypted);
</code></pre>

<p>There is a small transfer header that let's the client know the size of the incoming message, but I thought it's not relevant and I left that out.
The Python code receiving this message looks like:</p>

<pre><code>#Predefined:
unpad = lambda s : s[0:-ord(s[-1])]

  encrypted = cs.recv(messagesize) # Receive the encrypted message
  iv = encrypted[:16]

  key = AES.new('0123456789abcdef', AES.MODE_CBC,IV=iv)
  padded_msg  = key.decrypt(encrypted[16:])
  decrypted = unpad(padded_msg) #Remove padding

  print ""read [%s]"" % decrypted
</code></pre>

<p>Result looks like:</p>

<pre><code>read [What's up]
</code></pre>

<p>And if I change two lines in Java code:</p>

<pre><code>SecureRandom rnd = new SecureRandom();
IvParameterSpec ivspec = new IvParameterSpec(rnd.generateSeed(16));
</code></pre>

<p>Python output becomes:</p>

<pre><code>read [?=H??m??l??1ls]
</code></pre>

<p>I wonder what changes with the SecureRandom? I read that by default the String.getBytes() return platform default encoding (for <code>Android 4.0</code>), so I wonder if I have to do some manipulation on Python end to the IV that was generated with SecureRandom..?</p>
"	NULL	3	NULL	19:45.0	4	48:43.4	NULL	NULL	0	1153471	0	1	2	<android><python><encryption><aes><cbc-mode>	"Decryption works with a IV that is String.getBytes(), but fails SecureRandom.generateSeed()"	1643	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20233775	20591539	2	"<p>My aim is to write a Java program to encrypt a text file (<code>cipher text</code>) using <code>AES algorithm</code>. And then, write another program to decrypt that encrypted file (<code>cipher text</code>) to get the plain text back. I want to use same key (same key, generate once, save it somewhere, and use it in both encryption and decryption program) for encryption and decryption process. If I generate key and do the encryption and decryption line by line in the same program then it works perfectly. Here is the working code snippet for that:</p>

<pre><code>        String strDataToEncrypt = new String();
        String strCipherText = new String();
        String strDecryptedText = new String();

        KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();

        Cipher aesCipher = Cipher.getInstance(""AES"");
        aesCipher.init(Cipher.ENCRYPT_MODE,secretKey);

        strDataToEncrypt = ""any text input"";
        byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();
        byte[] byteCipherText = aesCipher.doFinal(byteDataToEncrypt); 
        strCipherText = new BASE64Encoder().encode(byteCipherText);
        System.out.println(""cipher text: "" +strCipherText);
        aesCipher.init(Cipher.DECRYPT_MODE,secretKey,aesCipher.getParameters());
        byte[] byteDecryptedText = aesCipher.doFinal(new BASE64Decoder().decodeBuffer(strCipherText));
        strDecryptedText = new String(byteDecryptedText);
        System.out.println(""plain text again: "" +strDecryptedText);
</code></pre>

<p>But, I need to have two different programs (java files) for encryption and decryption. So, I have to somehow generate a key and save that somewhere. Then use the same key for both encryption and decryption program. How can I do that?</p>

<p><strong>EDIT_1</strong></p>

<pre><code>KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
keyGen.init(128);
SecretKey secretKey = keyGen.generateKey();
byte[] encoded = secretKey.getEncoded(); 
System.out.println(""key: ""+encoded);// key: [B@52b2a2d8
</code></pre>

<p>I can get the encoded key value using the above program. But my question is how to generate the SecretKey using this value in my decryption program?</p>
"	NULL	3	NULL	14:57.1	6	20:44.4	20:44.4	NULL	981183	981183	0	1	5	<java><cryptography><aes><secret-key>	How to generate secret key in Java once and use that key in 2 different programs	50084	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20332636	20334088	1	"<p>I'm doing a simple encryption file transfer system and now stopped by a run time exception: </p>

<pre><code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:313)
    at javax.crypto.Cipher.doFinal(Cipher.java:2087)
    at ftpclient.FTPClient.main(FTPClient.java:82)
</code></pre>

<p>I tried to debug my code using a string to encrypt and decrypt with the same key and it works. However, when I tried to transfer stream from the file, this exception always comes.</p>

<p>Here are the codes of both sides. At first they will exchange symmetric key (AES key) via RSA and then transfer large files via AES encryption. We can focus on the last part of each code where the files are encrypted and decrypted by AES key.</p>

<p>Server Side:</p>

<pre><code>package ftpserver;

import java.io.*;
import java.net.*;
import javax.crypto.*;
import java.security.*;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64; 
/**
 *
 * @author Han
 */
public class FTPServer {
    public static void main(String[] args) throws Exception {

        //generate symmetric key and initialize cipher for AES
        SecretKey skey = null;
        Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");

        KeyGenerator kg = KeyGenerator.getInstance(""AES"");
        kg.init(128);
        skey = kg.generateKey();

        //get public key of the receive side
        final String PUBLIC_KEY_PATH = ""key_b.public"";
        PublicKey publickey = null;
        try {
        FileInputStream fis;
        fis = new FileInputStream(PUBLIC_KEY_PATH);
        ObjectInputStream oin = new ObjectInputStream(fis);
        publickey = (PublicKey) oin.readObject();
        oin.close();
        } catch (FileNotFoundException e) {
        e.printStackTrace();
        } catch (IOException e) {
        e.printStackTrace();
        } catch (ClassNotFoundException e) {
        e.printStackTrace();
        };

        //encrypte symmetric key with own private key and send out
        Cipher rsa = Cipher.getInstance(""RSA"");
        rsa.init(Cipher.ENCRYPT_MODE, publickey);
        byte cipherSKey[] = rsa.doFinal(skey.getEncoded());
        //System.out.println(skey); //debug

    //create tcp server socket
        ServerSocket tcp = new ServerSocket(2000);
        Socket client = tcp.accept();

        //get input&amp;output stream from the TCP connection
        InputStream in = client.getInputStream();
    OutputStream out = client.getOutputStream();

        //generate a file input stream to get stream from file
    File sentFile = new File(""F:\\test.txt"");
        FileInputStream fin = new FileInputStream(sentFile);

        //send encrypted symmetric key first
        out.write(""Symmetric Key:\r\n"".getBytes());
        out.write(cipherSKey);

        DataInputStream din = new DataInputStream(in);
        while(true)
        {
            if(din.readLine().equals(""Received.""))
            {
                System.out.println(""Send key successfully."");
                break;
            }

        };

        //send files
    int count;
        byte[] bytearray = new byte[8192];
        byte[] cipherbuffer;
        while((count = fin.read(bytearray))&gt;0)
    {
        cipherbuffer = Base64.encodeBase64(aes.doFinal(bytearray));
        out.write(cipherbuffer,0,cipherbuffer.length);
        System.out.println(count+"" bytes have been sent."");
        };

        out.flush();
        out.close();

        client.close();


        }
}
</code></pre>

<p>Client Side:</p>

<pre><code>package ftpclient;

import java.io.*;
import java.net.*;
import java.security.PrivateKey;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
/**
 *
 * @author Han
 */
public class FTPClient {

public static void main(String[] args) throws Exception 
    {
            //get the private key of this side


        final String PUBLIC_KEY_PATH = ""key_b.privat"";
        PrivateKey privatkey = null;
        try {
        FileInputStream fis;
        fis = new FileInputStream(PUBLIC_KEY_PATH);
        ObjectInputStream oin = new ObjectInputStream(fis);
        privatkey = (PrivateKey) oin.readObject();
        oin.close();
        } catch (FileNotFoundException e) {
        e.printStackTrace();
        } catch (IOException e) {
        e.printStackTrace();
        } catch (ClassNotFoundException e) {
        e.printStackTrace();
        };

        Cipher rsa = Cipher.getInstance(""RSA"");
        rsa.init(Cipher.DECRYPT_MODE, privatkey);

        //create tcp client socket
        Socket tcp = new Socket(""192.168.1.185"",2000);        
    InputStream in = tcp.getInputStream();
        OutputStream out = tcp.getOutputStream();
        DataInputStream din = new DataInputStream(in);

        //receive symmetric key from server
        byte keybuffer[] = new byte[128];
        SecretKey skey = null;

        while(true)
        {
            if(din.readLine().equals(""Symmetric Key:""))
            {
                System.out.println(""Start to receiving key..."");
                in.read(keybuffer);
                byte[] skeycode = rsa.doFinal(keybuffer);
                skey = new SecretKeySpec(skeycode, 0, skeycode.length, ""AES"");
                out.write(""Received.\r\n"".getBytes());
                break;
            }
        };
        //create cipher for symmetric decryption
        Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        aes.init(Cipher.DECRYPT_MODE, skey);
        //System.out.println(skey); //debug

        //create file stream
        FileOutputStream fos = new FileOutputStream(""E:\\test_cp.txt"");

    int count;
        int i = 0;
        byte[] bytearray = new byte[8192];
        byte[] buffer;
        while((count = in.read(bytearray)) &gt; 0)
        {
            buffer = (aes.doFinal(Base64.decodeBase64(bytearray)));
                        fos.write(buffer,0,buffer.length);   
                        i +=count;
                        System.out.println(i+"" bytes have been received."");
        };


        fos.flush();
        fos.close();
        in.close();

        tcp.close();
        System.out.println(""File Transfer completed"");

    }

}
</code></pre>
"	NULL	2	NULL	09:23.7	1	18:28.6	NULL	NULL	0	1840385	0	1	3	<java><encryption><aes>	"In AES decryption, ""Given final block not properly padded"" occurred"	16742	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20770072	20770158	1	"<p>I am currently using <code>AES/CBC/PKCS5Padding</code> for encrypting files in Java with <strong>256 bytes</strong> key size, but while searching I found on stackexchange <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">PKCS#5-PKCS#7 Padding</a> and  it is mentioned,</p>

<blockquote>
  <p>PKCS#5 padding is a subset of PKCS#7 padding for 8 byte block sizes</p>
</blockquote>

<p>So I want to know  </p>

<ol>
<li>Will the performance of <code>AES/CBC/PKCS7Padding</code> will be better then <code>AES/CBC/PKCS5Padding</code> for the above configuration?</li>
<li>How can we configure the block size in Java as it is mentioned

<blockquote>
  <p>PKCS#7 padding would work for any block size from 1 to 255 bytes.</p>
</blockquote></li>
</ol>

<p>My sample code is,</p>

<pre><code>SecureRandom rnd = new SecureRandom();
IvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(16));

KeyGenerator generator = KeyGenerator.getInstance(""AES"");
generator.init(256);
SecretKey k = generator.generateKey();

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, k, iv);
</code></pre>
"	NULL	0	NULL	10:52.8	22	06:06.4	48:18.7	NULL	-1	2534148	0	1	32	<java><encryption><aes><pkcs#7><pkcs#5>	AES/CBC/PKCS5Padding vs AES/CBC/PKCS7Padding with 256 key size performance java	101499	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20824136	0	1	"<p>I have encrypted my file using DES algorithm and Stored tat DES Secretkey into database converting it into String.
Now i want to Convert that String to Secretkey.</p>

<p>Here is the code.</p>

<pre><code>        secret_key = KeyGenerator.getInstance(""DES"").generateKey();
        alogrithm_specs = new IvParameterSpec(initialization_vector);
        // set encryption mode ...
        encrypt = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        encrypt.init(Cipher.ENCRYPT_MODE, secret_key, alogrithm_specs);
        //out.print(""actual secret_key:""+secret_key);

        String keyString = encoder.encode(secret_key.getEncoded());
        //out.print(""keyString:""+keyString);

        byte[] encodedKey = decoder.decodeBuffer(keyString);
        //out.print(""byte[]:""+encodedKey);

        secret_key= new SecretKeySpec(encodedKey,0,encodedKey.length, ""DES"");
        //out.print(""after encode &amp; decode secret_key:""+secret_key);
</code></pre>

<p>Above code will convert String into key as below:</p>

<pre><code>actual secret_key: 'com.sun.crypto.provider.DESKey@1807c'

keyString:hvsCa0XcXhY=

byte[]:[B@7c91fe

after encode &amp; decode secret_key:'javax.crypto.spec.SecretKeySpec@1807c`
</code></pre>

<p>I want to Store that Secretkey into database by converting the key into String.
Then while decrypting i want convert that String back to Key.</p>
"	NULL	4	NULL	22:13.9	2	53:43.8	34:16.9	NULL	829571	3143302	0	1	2	<java><file><encryption><secret-key>	Convert String to Secret key in java	11451	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20835808	20836141	2	"<p>I am using 3DESC to decrypt data but i am getting following exception</p>

<pre><code>java.security.InvalidKeyException: Invalid key length: 16 bytes
</code></pre>

<p>My Code:</p>

<pre><code>public static byte[] decrypt3DESCBC(byte[] keyBytes, byte[] ivBytes,
        byte[] dataBytes) {
    try {
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""DESede"");
        Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec); // Causes Exception
        return cipher.doFinal(dataBytes);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>Printed all the byte array above used</p>

<pre><code>keyBytes : FC15780BB4B0**********0876482C1B // Masked 10 Characters
ivBytes : 0000000000000000
dataBytes : AF53C90F7FAD977E**********69DB5A2BF3080F9F07F4BFEA3EDB4DE96887BE7D40A5A590C0911A // Masked 10 Characters
</code></pre>
"	NULL	0	NULL	18:06.5	2	15:44.8	NULL	NULL	0	1169180	0	1	0	<java><encryption><cryptography><3des>	3DES Decryption Error Invalid Key Length	11978	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
20888851	20888967	2	"<p>I am writing a simple app to encrypt my message using AES / CBC (mode). As my understanding CBC mode requires IV parameter but I don't know why my code work without IV parameter used. Anyone can explain why? Thanks.</p>
<p><strong>The encrypted message printed: T9KdWxVZ5xStaisXn6llfg==    without exception.</strong></p>
<pre class=""lang-java prettyprint-override""><code>public class TestAES {

    public static void main(String[] args) {

        try {
            byte[] salt = new byte[8];
            new SecureRandom().nextBytes(salt);

            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            KeySpec keySpec = new PBEKeySpec(&quot;myPassword&quot;.toCharArray(), salt, 100, 128);

            SecretKey tmp = keyFactory.generateSecret(keySpec);
            SecretKeySpec key = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);

            Cipher enCipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            enCipher.init(Cipher.ENCRYPT_MODE, key);

            // enCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));

            byte[] cipherBytes = enCipher.doFinal(&quot;myMessage&quot;.getBytes());
            String cipherMsg = BaseEncoding.base64().encode(cipherBytes);

            System.out.println(&quot;Encrypted message: &quot; + cipherMsg);

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }
}
</code></pre>
"	NULL	2	NULL	58:56.6	4	59:28.1	59:28.1	NULL	8976	0	0	1	8	<java><aes><password-encryption><cbc-mode>	Does AES/CBC really require IV parameter?	26555	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
21518678	21520228	1	"<p>I have the below java code to encrypt a string which uses a 64 character key. My question is will this be a AES-256 encryption?</p>

<pre><code>String keyString = ""C0BAE23DF8B51807B3E17D21925FADF273A70181E1D81B8EDE6C76A5C1F1716E"";
byte[] keyValue = hexStringToByte(keyString);
Key key = new SecretKeySpec(keyValue, ""AES"");
Cipher c1 = Cipher.getInstance(""AES"");
c1.init(Cipher.ENCRYPT_MODE, key);

String data = ""Some data to encrypt"";
byte[] encVal = c1.doFinal(data.getBytes());
String encryptedValue = Base64.encodeBase64String(encVal);


/* Copied the below code from another post in stackexchange */
public static byte[] hexStringToByte(String hexstr) 
{
  byte[] retVal = new BigInteger(hexstr, 16).toByteArray();
  if (retVal[0] == 0) 
  {
    byte[] newArray = new byte[retVal.length - 1];
    System.arraycopy(retVal, 1, newArray, 0, newArray.length);
    return newArray;
  }
  return retVal;
}
</code></pre>

<p>The following is the code after incorporating suggestions from divanov and laz.</p>

<pre><code>String keyString = ""C0BAE23DF8B51807B3E17D21925FADF273A70181E1D81B8EDE6C76A5C1F1716E"";
byte[] keyValue = DatatypeConverter.parseHexBinary(keyString);
Key key = new SecretKeySpec(keyValue, ""AES"");
Cipher c1 = Cipher.getInstance(""AES"");
c1.init(Cipher.ENCRYPT_MODE, key);

String data = ""Some data to encrypt"";
byte[] encVal = c1.doFinal(data.getBytes());
String encryptedValue = Base64.encodeBase64String(encVal);
</code></pre>
"	NULL	3	NULL	55:51.2	3	01:23.6	01:23.6	NULL	3264267	3264267	0	1	2	<java><aes><encryption>	Java AES 256 encryption	15475	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
21988552	21989588	1	"<p>I'm trying to encrypt something, and decrypt it. I'm failing on the decryption - I get the exception above. I tried changing ctLength and ptLength, but to no avail. What am I doing wrong?
<br>I'm trying to encrypt: 0  0  0  0  0  0  0  0</p>

<pre><code>private Cipher encrypt(byte[] input)
{
    try
    {
        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

        // encryption pass
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
        int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
        ctLength += cipher.doFinal(cipherText, ctLength);
        FileOutputStream fs = new FileOutputStream(savedScoresFileName);
        fs.write(cipherText);

        return cipher;
    }
    catch (Exception e)
    {
        Log.e(""encrtypt"", ""Exception"", e);
    }

    return null;
}

private String decrypt()
{
    try
    {
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
        byte[] cipherText = new byte[32];

        FileInputStream fl = new FileInputStream(savedScoresFileName);
        fl.read(cipherText);

        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] plainText = new byte[cipher.getOutputSize(32)];
        int ptLength = cipher.update(cipherText, 0, 32, plainText, 0);
        ptLength += cipher.doFinal(plainText, ptLength);

        return new String(plainText).substring(0, ptLength);
    }
    catch (Exception e)
    {
        Log.e(""decrypt"", ""Exception"", e);
    }

    return null;
}
</code></pre>

<p>This code was copied from <a href=""http://www.java2s.com/Code/Java/Security/EncryptionanddecryptionwithAESECBPKCS7Padding.htm"" rel=""nofollow"">this</a>, which worked.</p>
"	NULL	0	NULL	59:53.3	3	45:19.3	NULL	NULL	0	715439	0	1	1	<java><android>	javax.crypto.BadPaddingException: pad block corrupted	18415	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22034269	0	2	"<p>Following are my encrypt/decrypt methods:</p>

<pre><code>private String decrypt_data(String encData) 
                throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
    {
        String key = ""bad8deadcafef00d"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");

        cipher.init(Cipher.DECRYPT_MODE, skeySpec);

        System.out.println(""Base64 decoded: ""+Base64.decode(encData.getBytes()).length);
        byte[] original = cipher.doFinal(Base64.decode(encData.getBytes()));
        return new String(original).trim();     
    }

    private String encrypt_data(String data) 
                throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException
    {
        String key = ""bad8deadcafef00d"";
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");

        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        System.out.println(""Base64 encoded: ""+ Base64.encode(data.getBytes()).length);

        byte[] original = cipher.doFinal(Base64.encode(data.getBytes()));
        return new String(original);
    }
</code></pre>

<p>So now when I am trying to encrypt, I am getting this exception: </p>

<pre><code>javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes
    at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:854)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:828)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:313)
    at javax.crypto.Cipher.doFinal(Cipher.java:2087)
</code></pre>

<p>I have tried with cipher instance <code>AES/ECB/PKCS5Padding</code> in both encrypt and decrpt. It works only for encryption and not for decryption. I suppose padding is needed as data size is not multiple of 16bytes. 'data' byte length was printed as <code>152</code> so tried appending <code>eight</code> <code>\0</code> characters to data and then encrypt, it didn't work either. </p>
"	NULL	3	NULL	10:31.4	3	53:09.4	NULL	NULL	0	1444079	0	1	1	<java><encryption><cryptography>	encryption/decryption using AES/ECB/NoPadding	32543	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22201511	22218410	1	"<p>I'm trying to encrypt a string in Android app and then decrypt it in ASP.Net server. I'm not getting any errors but decryption doesn't return true results. Here is Android side:</p>

<pre><code>public void clckBtn(View v) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(
                    ""MyDifficultPassw"".getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(""tryToEncrypt"".getBytes());
            System.out.println(toHex(encrypted));

        } catch (Exception e) {
            System.out.println(e.toString());
        }

    }


    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
    }
</code></pre>

<p>The output is: CE3E99F50E6D30201E38D4955F07BA7C</p>

<p>Asp.Net side :</p>

<pre><code> protected void Page_Load(object sender, EventArgs e)
        {
            using (Aes myAes = Aes.Create())
            {
                string asd = DecryptStringFromBytes_Aes(GetBytes(""CE3E99F50E6D30201E38D4955F07BA7C""), GetBytes(""MyDifficultPassw""), myAes.IV);
                int we = 0;
            }

        }

        static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key
, byte[] IV)
        {
            // Check arguments. 
            if (cipherText == null || cipherText.Length &lt;= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");

            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an Aes object 
            // with the specified key and IV. 
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                aesAlg.Padding = PaddingMode.None;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key
, aesAlg.IV);



                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {

                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt
, decryptor, CryptoStreamMode.Read))
                    {

                        using (StreamReader srDecrypt = new StreamReader(
csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting 

                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }

        static byte[] GetBytes(string str)
        {
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }
</code></pre>

<p>In Asp.Net Aes class requires a IV (initialization vector). In Android there is no such thing. I think the problem is something about that.</p>
"	NULL	2	NULL	06:14.1	4	57:43.4	NULL	NULL	0	1529034	0	1	3	<c#><android><asp.net><cryptography><aes>	AES decryption gives wrong results	1394	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22230302	0	0	"<p>Below mentioned is a code which is showing exception while running. Wanted to understand the public key / private key working.</p>

<pre><code>KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        KeyPair keyPair = generator.generateKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();

        Cipher aes = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        aes.init(Cipher.ENCRYPT_MODE,publicKey);
        byte[] cipherText = aes.doFinal(""my password"".getBytes());
        System.out.println(new String(cipherText));
</code></pre>

<p>Below mentioned is exception.</p>

<p><strong>Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size or default parameters</strong></p>
"	NULL	3	NULL	30:06.7	2	30:06.7	NULL	NULL	0	2775185	0	1	1	<java><security>	Asymmertic key encryption not working	38	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22285670	22285811	2	"<p>I'm implementing 3DES EDE3 with 3 different keys each of 56 bits, EK3 DK2 Ek1 plain text, 168 bits. But i don't know how to do it. i'm bigger to java.</p>

<pre><code>import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class DESedeEncryption {
public static void main(String[] args) {

SecretKey k1 = generateDESkey();
SecretKey k2 = generateDESkey();
SecretKey k3 = generateDESkey();

String firstEncryption = desEncryption(""plaintext"", k1);
String decryption = desDecryption(firstEncryption, k2);
String secondEncryption = desEncryption(decryption, k3);
System.out.println(""secondEncryption: ""+secondEncryption);
System.out.println(""firstEncryption: ""+firstEncryption);
System.out.println(""decryption: ""+decryption);

}

public static SecretKey generateDESkey() {
KeyGenerator keyGen = null;
try {
    keyGen = KeyGenerator.getInstance(""DESede"");
} catch (Exception ex) {
  ex.printStackTrace();
}
keyGen.init(168); // key length 112 for two keys, 168 for three keys
SecretKey secretKey = keyGen.generateKey();
return secretKey;
}

public static String desEncryption(String strToEncrypt, SecretKey desKey) {
try {
    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, desKey);
    String encryptedString = new      BASE64Encoder().encode(cipher.doFinal(strToEncrypt.getBytes()));
    return encryptedString;


} catch (Exception ex) {
  ex.printStackTrace();
}
return null;
}

public static String desDecryption(String strToDecrypt, SecretKey desKey) {
try {
    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, desKey);
    String decryptedString = new String(cipher.doFinal(new     BASE64Decoder().decodeBuffer(strToDecrypt)));
    return decryptedString;


} 
catch (Exception ex) {
  ex.printStackTrace();
}
return null;
}
}
</code></pre>

<p>I'm getting following error. tell me what wrong in this. plz help us. </p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
    at com.sun.crypto.provider.DESedeCipher.engineDoFinal(DESedeCipher.java
:294)
    at javax.crypto.Cipher.doFinal(Cipher.java:2087)
    at DESedeEncryption.desDecryption(DESedeEncryption.java:55)
    at DESedeEncryption.main(DESedeEncryption.java:17)
java.lang.NullPointerException
    at DESedeEncryption.desEncryption(DESedeEncryption.java:41)
    at DESedeEncryption.main(DESedeEncryption.java:18)
secondEncryption: null
firstEncryption: sP0ySxvxaUP+0a9l5qWSLQ==
decryption: null
</code></pre>

<p>Thanks in advance</p>
"	NULL	0	NULL	45:36.9	2	03:38.4	NULL	NULL	0	3201607	0	1	0	<java>	3DES with 3 different keys in java error	1218	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22347048	22364581	1	"<p>I want to do decryption by using AES algorithm
My Code is as Follows :</p>

<pre><code>public static String decrypt(String key, byte[] encrypted)
            throws GeneralSecurityException {

        byte[] raw = key.getBytes(Charset.forName(""US-ASCII""));
        if (raw.length != 16) {
            throw new IllegalArgumentException(""Invalid key size."");
        }
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec,new IvParameterSpec(new byte[16]));
        byte[] original = cipher.doFinal(encrypted);

        return new String(original, Charset.forName(""US-ASCII""));
    }
</code></pre>

<p>Why i am getting this Exception ??? </p>
"	NULL	3	NULL	27:34.5	3	47:08.2	NULL	NULL	0	3243855	0	1	1	<java><encryption>	While decrypt message using AES Algorithm Exception :Given final block not properly padded	267	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22357583	22358653	1	"<p>I am new to JAVA. I am going to build a security system for my project. However, I have encountered a problem. Eclipse always points out that ""java.security.InvalidKeyException: Wrong algorithm: AES or Rijndael required"". I am going to save the encryption key in database. I have checked that the key is correct. The only problem is that I cannot decrypt the ciphertext. Can anyone tell me what the problem is?
Actually, I have searched some solutions but the problem is still not yet solved.
Please help me. Thanks a lot!</p>

<pre><code>import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class AES {
    public static void main(String[] args) throws Exception {
    String test = ""HIHI"";
    String tmp = null;
    SecretKey tempKey1 = generateKey();
    saveKey(tempKey1);
    SecretKey tempKey2 = loadKey();
    tmp = encrypt(test, tempKey1);
    String printString = decrypt(tmp, tempKey2);
    System.out.println(printString);

}

public static SecretKey generateKey() throws NoSuchAlgorithmException {
    KeyGenerator keyGenerator = KeyGenerator.getInstance(""AES"");
    keyGenerator.init(128);
    SecretKey key = keyGenerator.generateKey();
    return key;
}

public static void saveKey(SecretKey key) throws IOException {
    String stringKey = Base64.encodeBase64String(key.getEncoded());
    System.out.println(""stringKey: "" + stringKey);
    try {
        final PreparedStatement pstmt;

        // Register the JDBC driver
        // for MySQL.
        Class.forName(""com.mysql.jdbc.Driver"");

        // Define URL of database
        // server for
        // database named JunkDB on
        // the localhost
        // with the default port
        // number 3306.
        String url = ""jdbc:mysql://127.0.0.1:3306/fyp"";

        // Get a connection to the
        // database for a
        // user named auser with the
        // password
        // drowssap, which is
        // password spelled
        // backwards.
        Connection con = DriverManager.getConnection(url, ""user"", ""user"");

        pstmt = con.prepareStatement(""insert into compfyp values (?)"");
        pstmt.setString(1, stringKey);

        pstmt.executeUpdate();

        pstmt.close();

        con.close();
    } catch (Exception e) {
        e.printStackTrace();
    }// end catch

}

public static SecretKey loadKey() throws IOException {
    String stringKey = null;
    try {
        Statement stmt;
        ResultSet rs;

        // Register the JDBC driver for MySQL
        Class.forName(""com.mysql.jdbc.Driver"");

        // Define URL of database server for database named comp2220
        String url = ""jdbc:mysql://127.0.0.1:3306/fyp"";

        // Get a connection to the database for a user named user with the
        // password userpassword, which is password spelled backwards
        Connection con = DriverManager.getConnection(url, ""user"", ""user"");

        // Get a Statement object
        stmt = con.createStatement();

        // Get another statement object initialized as shown
        stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                ResultSet.CONCUR_READ_ONLY);

        // Query the database, storing the result in an object of type
        // ResultSet
        rs = stmt.executeQuery(""SELECT * from compfyp"");

        // Use the methods of class ResultSet in a loop to display all of
        // the data in the database.
        while (rs.next()) {
            stringKey = rs.getString(""encryptionkey"");

        }// end while loop
        con.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    byte[] encodedKey = Base64.decodeBase64(stringKey);
    SecretKey trueKey = new SecretKeySpec(encodedKey, 0, encodedKey.length,
            ""AES/ECB/PKCS5Padding"");
    System.out.println(""after encode &amp; decode secret_key:""
            + Base64.encodeBase64String(trueKey.getEncoded()));

    return trueKey;
}

public static String encrypt(String plaintext, SecretKey encryptionKey)
        throws Exception {
    IvParameterSpec iv = new IvParameterSpec(""0102030405060708"".getBytes());
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, encryptionKey, iv);
    byte[] encryptData = cipher.doFinal(plaintext.getBytes());

    return encryptData.toString();

}

public static String decrypt(String ciphertext, SecretKey encryptionKey)
        throws Exception {
    IvParameterSpec iv = new IvParameterSpec(""0102030405060708"".getBytes());
    SecretKeySpec spec = new SecretKeySpec(encryptionKey.getEncoded(),
            ""AES/CBC/PKCS5Padding"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, spec, iv);
    byte[] encryptData = ciphertext.getBytes();
    ;

    byte[] original = cipher.doFinal(encryptData);
    return new String(original);

}
</code></pre>

<p>}</p>
"	NULL	1	NULL	16:46.5	3	59:00.3	NULL	NULL	0	3411582	0	1	12	<java><encryption><aes>	Wrong algorithm: AES or Rijndael required	20068	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22410602	22412532	2	"<p>I want to enter my own String variable to then turn it into a key for encryption/decryption for AES algorithm. I have tried many known ways such as UTF-8, base64, some methods doing conversion byte-string and vice versa and some other. Although it's true that all of them work even with some of them not working accurately, all of them turn the string in bytes, but what i want is to enter something like ""helloWorld"" and get back a 128-bit key for AES. Anything i use it goes for ""Invalid key length"" since the bytes are not accurate.
What do i need to do to get the correct bytes? Also i want to clarify that i want String and not an array of char since i want to make it as a function in my programm later so that the user can change the key at will should it be compromised.</p>

<p>UPDATE: i edited the example and this i what i have so far, still throws exception about parameters and key length though</p>

<pre><code>    public class SHAHashingExample
{
    private static byte[] keyValue;

    public static void main(String[] args)throws Exception
    {
        String password = ""123456"";

        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(password.getBytes());

        byte byteData[] = md.digest();
        keyValue = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; byteData.length/2; i++) {
         sb.append(Integer.toString((byteData[i] &amp; 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Hex format : "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();
        for (int i=0;i&lt;byteData.length/2;i++) {
            String hex=Integer.toHexString(0xff &amp; byteData[i]);
            if(hex.length()==1) hexString.append('0');
            hexString.append(hex);
        }
        System.out.println(""Hex format : "" + hexString.toString());

        String k = ""hello world"";
        String f = encrypt(k);
        System.out.println(f);
        String j = decrypt(f);
        System.out.println(j);
    }

    public static String encrypt(String Data) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encVal = c.doFinal(Data.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encVal);
        return encryptedValue;
    }

    public static String decrypt(String encryptedData) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(""AES"");
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }

    private static Key generateKey() throws Exception {
        Key key = new SecretKeySpec(keyValue, ""AES"");
        return key;
    }
}
</code></pre>
"	NULL	4	NULL	23:23.4	2	06:18.5	39:20.3	NULL	2371200	2371200	0	1	2	<java><encryption>	Turn String to 128-bit key for AES	15186	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22549251	22561689	1	"<p>I found a tutorial on encrypting and decrypting but I encounter a slight problem trying to implement the tutorial. Im wondering if its permanent or not but there is a line <code>String seedValue = ""This Is MySecure"";</code> when I try to change the text to other text im having problem problems in decrypting. Is this code unchangeable in this code I was thinking if I could use it to encrypt and decrypt password. here is the code.</p>

<p>(Using AESHelper class, full code found <a href=""http://iamvijayakumar.blogspot.com/2013/10/android-example-for-encrypt-and-decrypt.html"" rel=""nofollow"">here</a>.)</p>

<pre><code>public class MainActivity extends Activity {

    String seedValue = ""This Is MySecure"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        String normalText = ""VIJAY"";
        String normalTextEnc;

        try{
            normalTextEnc = AESHelper.encrypt(seedValue, normalText);
            String normalTextDec = AESHelper.decrypt(seedValue, normalTextEnc);
            TextView txe = new TextView(this);
            txe.setTextSize(14);
            txe.setText(""Normal Text ::"" + normalText + "" \n Encrypted Value :: "" + normalTextEnc + "" \n Decrypted value :: "" + normalTextDec);
            setContentView(txe);
        }catch(Exception e){
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</code></pre>

<p><br />
<strong>UPDATE:</strong></p>

<p>Was able to implement both encrypt and decrypt but I get another problem that I don't understand why it occurs and how to fix it. </p>

<p>The errors says <code>03-21 05:25:08.554: E/Exception(2109): pad block corrupted</code> i got the code from this site <a href=""http://kvandroidapp.blogspot.com/2012/11/example-for-encrypt-and-decrypt-using.html"" rel=""nofollow"">here</a></p>

<p><strong>UPDATE:</strong></p>

<p>Pad Block fixed another one came it says:</p>

<blockquote>
  <p>03-24 02:31:33.131: E/Exception(1308): error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
  </p>
</blockquote>

<p><strong>UPDATE:</strong>
this is my code and i follow as adviced but still when i try to decrypt the encrypted and vice versa enrcypt the decrypted i get exception.
</p>

<pre><code>package com.sample.camera;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;

public class EncodeDecodeAES {



    private final static String HEX = ""0123456789ABCDEF"";

    private final static int JELLY_BEAN_4_2 = 17;

    private final static byte[] key = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };




    // static {

    // Security.addProvider(new BouncyCastleProvider());

    // }



    public static String encrypt(String seed, String cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());

        byte[] result = encrypt(rawKey, cleartext.getBytes());

        String fromHex = toHex(result);

        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));

        return base64;


    }




    public static String decrypt(String seed, String encrypted) throws Exception {

        byte[] seedByte = seed.getBytes();

        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length &lt; 16) ? seedByte.length : 16));

        String base64 = new String(Base64.decode(encrypted, 0));

        byte[] rawKey = getRawKey(seedByte);

        byte[] enc = toByte(base64);

        byte[] result = decrypt(rawKey, enc);

        return new String(result);


    }




    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());

        byte[] result = encrypt(rawKey, cleartext);

        return result;


    }




    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());

        byte[] result = decrypt(rawKey, encrypted);

        return result;


    }




    private static byte[] getRawKey(byte[] seed) throws Exception {

        KeyGenerator kgen = KeyGenerator.getInstance(""AES""); // , ""SC"");

        SecureRandom sr = null;

        if (android.os.Build.VERSION.SDK_INT &gt;= JELLY_BEAN_4_2) {

            sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");


        } else {

            sr = SecureRandom.getInstance(""SHA1PRNG"");


        }

        sr.setSeed(seed);

        try {

            kgen.init(256, sr);

            // kgen.init(128, sr);


        } catch (Exception e) {

            // Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");

            try {

                kgen.init(192, sr);


            } catch (Exception e1) {

                // Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");

                kgen.init(128, sr);


            }

        }

        SecretKey skey = kgen.generateKey();

        byte[] raw = skey.getEncoded();

        return raw;


    }




    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

        //Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] encrypted = cipher.doFinal(clear);

        return encrypted;


    }




    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding""); // /ECB/PKCS7Padding"", ""SC"");

        cipher.init(Cipher.DECRYPT_MODE, skeySpec);

        byte[] decrypted = cipher.doFinal(encrypted);

        return decrypted;


    }




    public static String toHex(String txt) {

        return toHex(txt.getBytes());


    }




    public static String fromHex(String hex) {

        return new String(toByte(hex));


    }




    public static byte[] toByte(String hexString) {

        int len = hexString.length() / 2;

        byte[] result = new byte[len];

        for (int i = 0; i &lt; len; i++)

            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();

        return result;

    }



    public static String toHex(byte[] buf) {
        if (buf == null)

            return """";

        StringBuffer result = new StringBuffer(2 * buf.length);

        for (int i = 0; i &lt; buf.length; i++) {

            appendHex(result, buf[i]);

        }
        return result.toString();

    }




    private static void appendHex(StringBuffer sb, byte b) {

        sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));


    }




}
</code></pre>
"	NULL	7	NULL	51:04.6	4	59:54.8	59:54.8	NULL	2870532	2172594	0	1	2	<android><encryption><cryptography>	encrypt and decrypt using AES Algorithms	5720	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22648953	0	1	"<p>Program is running now. It runs but then crashes. In my files folder it creates an encrypted file but it is blank. It also does not produce a decrypted file at all. I also changed the bit size to 128. What else I am missing in order to properly implement AES?</p>

<p>This is the modified program</p>

<pre><code>import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.Cipher;

import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import java.security.InvalidAlgorithmParameterException;

import javax.crypto.NoSuchPaddingException;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;





import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.DESKeySpec;

public class MyCiphers {

    public static void main(String[] args) {
        try {



            BufferedReader br = new BufferedReader(new FileReader(""key.txt""));
            String key = br.readLine();
            br.close();
            FileInputStream fis = new FileInputStream(""original.txt"");
            FileOutputStream fos = new FileOutputStream(""encrypted.txt"");
            encrypt(key, fis, fos);

            FileInputStream fis2 = new FileInputStream(""encrypted.txt"");
            FileOutputStream fos2 = new FileOutputStream(""decrypted.txt"");
            decrypt(key, fis2, fos2);

        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    public static void encrypt(String key, InputStream is, OutputStream os) throws Throwable {
        encryptOrDecrypt(key, Cipher.ENCRYPT_MODE, is, os);
    }

    public static void decrypt(String key, InputStream is, OutputStream os) throws Throwable {
        encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os);
    }

    public static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable {


      SecretKeySpec dks = new SecretKeySpec(key.getBytes(),""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); 

        if (mode == Cipher.ENCRYPT_MODE) {
            cipher.init(Cipher.ENCRYPT_MODE, dks);
            CipherInputStream cis = new CipherInputStream(is, cipher);
            doCopy(cis, os);        
        } else if (mode == Cipher.DECRYPT_MODE) {
            cipher.init(Cipher.DECRYPT_MODE, dks);
            CipherOutputStream cos = new CipherOutputStream(os, cipher);
            doCopy(is, cos);
        }


    }

    public static void doCopy(InputStream is, OutputStream os) throws IOException {
        byte[] bytes = new byte[128];
        int numBytes;
        while ((numBytes = is.read(bytes)) != -1) {
            os.write(bytes, 0, numBytes);
        }
        os.flush();
        os.close();
        is.close();
    }

}
</code></pre>
"	NULL	0	NULL	10:56.7	2	54:01.1	54:01.1	NULL	3294617	3294617	0	1	-1	<java><encryption><aes><des>	AES Key From File Trouble	551	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
22951606	22952981	1	"<p>I know that this question is often asked but I have checked everything I found in Stack Overflow and did not find the solution to my problem.<br>
i am using DESede for encryption and decryption and taking external 24 byte key input. but getting exception.</p>

<p>here is my code:</p>

<pre><code>    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.spec.InvalidKeySpecException;

    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.DESedeKeySpec;
    import javax.xml.bind.DatatypeConverter;

    public class DESede {

     private static Cipher encryptCipher;
     private static Cipher decryptCipher;

     public static void main(String[] args) throws InvalidKeySpecException {
      try {


       String desKey = ""0123456789abcdef0123456789abcdef0123456789abcdef""; // value from user
       byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
       System.out.println((int)keyBytes.length);

       SecretKeyFactory factory = SecretKeyFactory.getInstance(""DESede"");
       SecretKey key = factory.generateSecret(new DESedeKeySpec(keyBytes));

       encryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
       encryptCipher.init(Cipher.ENCRYPT_MODE, key); //throwing Exception
       byte[] encryptedData = encryptData(""Confidential data"");

       decryptCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
       decryptCipher.init(Cipher.DECRYPT_MODE, key);
       decryptData(encryptedData);

      } catch (NoSuchAlgorithmException e) {
       e.printStackTrace();
      } catch (NoSuchPaddingException e) {
       e.printStackTrace();
      } catch (InvalidKeyException e) {
       e.printStackTrace();
      } catch (IllegalBlockSizeException e) {
       e.printStackTrace();
      } catch (BadPaddingException e) {
       e.printStackTrace();
      }

     }
</code></pre>

<p>//method for encryption</p>

<pre><code>     private static byte[] encryptData(String data)
       throws IllegalBlockSizeException, BadPaddingException {
      System.out.println(""Data Before Encryption :"" + data);
      byte[] dataToEncrypt = data.getBytes();
      byte[] encryptedData = encryptCipher.doFinal(dataToEncrypt);
      System.out.println(""Encryted Data: "" + encryptedData);

      return encryptedData;
     }
</code></pre>

<p>//method for decryption</p>

<pre><code>     private static void decryptData(byte[] data)
       throws IllegalBlockSizeException, BadPaddingException {
      byte[] textDecrypted = decryptCipher.doFinal(data);
      System.out.println(""Decryted Data: "" + new String(textDecrypted));
     }
    }
</code></pre>

<p>i am getting exception at the line: java.security.InvalidKeyException: Invalid key length: 24 bytes</p>

<pre><code>encryptCipher.init(Cipher.ENCRYPT_MODE, key);
</code></pre>

<p>any one have any idea why this is happening?</p>
"	NULL	1	NULL	15:58.7	5	00:20.9	NULL	NULL	0	3497255	0	1	2	<java><exception><encryption><key><des>	Exception java.security.InvalidKeyException: Invalid key length: 24 bytes using DESede	14897	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
23070838	23071271	1	"<p>I have a private key file encripted with DES/ECB/PKCS5Padding (56 bit DES key generated by a secret phrase) and I want to decrypt it.
I don't know why, but everytime I try to decript, the method doFinal of my cipher class is throwing this error:</p>

<blockquote>
  <p>javax.crypto.BadPaddingException: Given final block not properly
  padded    at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)  at
  com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)   at
  com.sun.crypto.provider.DESCipher.engineDoFinal(DashoA13*..)  at
  javax.crypto.Cipher.doFinal(DashoA13*..)  at...</p>
</blockquote>

<p>Here is my code:</p>

<pre><code>public static PrivateKey readPrivateKeyFromFile(File file, String chaveSecreta) {
    try {
        SecureRandom r = new SecureRandom(chaveSecreta.getBytes());
        KeyGenerator keyGen = KeyGenerator.getInstance(""DES"");
        keyGen.init(56, r);
        Key key = keyGen.generateKey();

        byte[] privateKeyBytes = decryptPKFile(file, key);

        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
        PrivateKey privateKey = null;
        try {
            privateKey = keyFactory.generatePrivate(privateKeySpec);
        } catch (InvalidKeySpecException e) {
            JOptionPane.showMessageDialog(null, ""Erro 01, tente mais tarde"");
        }
        return privateKey;
    } catch (NoSuchAlgorithmException e) {
        JOptionPane.showMessageDialog(null, ""Erro 02, tente mais tarde"");
    }
    return null;
}

public static byte[] decryptPKFile(File file, Key key){
    try{
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        byte[] cipherText = readBytes(file);
        cipher.init(Cipher.DECRYPT_MODE, key);
        System.out.println(cipher);
        System.out.println(cipherText);
        byte[] text = cipher.doFinal(cipherText);
        return text;
    }catch(Exception e){
        e.printStackTrace();
        return null;
    }
}

public static byte[] readBytes(File file) {
    try {
        FileInputStream fs = new FileInputStream(file);
        byte content[] = new byte[(int) file.length()];
        fs.read(content);
        return content;
    } catch (FileNotFoundException e) {
        System.out.println(""Arquivo não encontrado!"");
        e.printStackTrace();
    } catch (IOException ioe) {
        System.out.println(""Erro ao ler arquivo!"");
        ioe.printStackTrace();
    }
    return null;
}
</code></pre>

<p>Any syggestions?</p>
"	NULL	3	NULL	32:08.8	0	11:58.1	NULL	NULL	0	1117919	0	1	5	<java><encryption>	BadPaddingException: Given final block not properly padded	22997	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
23392085	23394610	2	"<p>I am getting <code>java.security.InvalidKeyException: Invalid AES key length: 128 bytes</code> on my line </p>

<pre><code>CIPHER.init(Cipher.ENCRYPT_MODE, keySpec);
</code></pre>

<p>with CIPHER being</p>

<pre><code>Cipher CIPHER = Cipher.getInstance(""AES"");
</code></pre>

<p>and keySpec</p>

<pre><code>SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
</code></pre>

<p>that key is a <code>byte[]</code> of length 128 I got through a Diffie-Hellman key exchange (though it shouldn't matter where I got it, right?), <code>key</code> is completely filled with nonzero bytes</p>

<p>Why is <code>Cipher.init(...)</code> complaining that the key is a wrong length? <a href=""http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher"">This webpage</a> clearly states that a key of length 128 is supported.</p>

<p>What am I overlooking?</p>
"	NULL	4	NULL	24:11.0	5	35:08.7	NULL	NULL	0	1009013	0	1	11	<java><encryption><aes>	Invalid AES key length: 128 bytes?	16082	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
23491143	23502494	3	"<p>I try to decrypt an encrypted data that I receive from a web service.</p>

<p>The encryption is done using <code>AES 128</code>.</p>

<p>I use the following code to decrypt the data:</p>

<pre><code>public static String decrypt(String strToDecrypt)
{       
    try
    {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding""); //AES/CBC/PKCS7Padding
        SecretKeySpec secretKey = new SecretKeySpec(AppConstants.AESEncryptionKey.getBytes(""UTF8""), ""AES"");
        int blockSize = cipher.getBlockSize();
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(new byte[blockSize])); //new IvParameterSpec(new byte[16])
        byte decBytes[] = cipher.doFinal(Base64.decode(strToDecrypt, 0));
        // byte decBytes[] = cipher.doFinal(Base64.decodeBase64(strToDecrypt));
        String decStr = new String(decBytes);
        System.out.println(""After decryption :"" + decStr);
        return decStr;
    }
    catch (Exception e)
    {
        System.out.println(""Exception in decryption : "" + e.getMessage());
    }
    return null;
}
</code></pre>

<p>At </p>

<blockquote>
  <p>cipher.doFinal()</p>
</blockquote>

<p>I got the following Exception:</p>

<blockquote>
  <p>javax.crypto.badpaddingexception pad block corrupted</p>
</blockquote>

<p>I went through my post but ended up with no solution. I am badly stuck over here.</p>
"	NULL	4	NULL	43:31.5	8	55:11.3	52:01.7	NULL	3432401	3340183	0	1	3	<java><android><exception><encryption><aes>	AES128 Decryption :javax.crypto.badpaddingexception pad block corrupted	14478	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
23885234	23888540	1	"<p>I am using the following simple encrypt and decrypt functions just to see that it works before using more complicated security features like padding and hashing. For some reason the returned clear text is not similar to the original message. Here is the code:</p>

<pre><code>public static byte[] encrypt(SecretKey secret, byte[] buffer) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException
{
    /* Encrypt the message. */
    cipher = Cipher.getInstance(""AES/CTR/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    byte[] ciphertext = cipher.doFinal(buffer);

    return ciphertext;
}

public static byte[] decrypt(SecretKey secret, byte[] buffer) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException
{
    /* Decrypt the message. - use cipher instance created at encrypt */
    cipher.init(Cipher.DECRYPT_MODE, secret);
    byte[] clear = cipher.doFinal(buffer);

    return clear;
}
</code></pre>

<p>and the calling code:</p>

<pre><code>    SecretKey secret1 = null;
    byte[] ciphertext = null;
    byte[] message = ""Hello, World!"".getBytes();
    byte[] clear = null;

    try {
// aSecret is a shared secret generated with ECDH
        secret1 = Crypto.createAESKey(aSecret);
        ciphertext = Crypto.encrypt(secret1, message);
        clear = Crypto.decrypt(secret1, ciphertext);

        String s = new  String(clear);//clear.toString();

        keyAText.setText(new String(message));
        keyBText.setText(s);

        return;
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidParameterSpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (BadPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
</code></pre>
"	NULL	9	NULL	04:59.6	4	43:38.0	02:47.5	NULL	1285338	1285338	0	1	0	<android><security><encryption><aes>	Simple AES encryption and decryption not returning original text	1746	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
24749303	24749728	2	"<p>I've following code to decrypt the files in Java which are encrypted via PHP <code>mcrypt</code> function.</p>

<pre><code>private String iv = ""MYKEYHERE"";//Dummy iv (CHANGE IT!)
private String SecretKey = ""MYKEYHERE"";//Dummy secretKey (CHANGE IT!)

private byte[] decrypt(String code)
{
    byte[] decrypted = null;
    try {
        Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());
        SecretKeySpec keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e) {
        e.printStackTrace();
    }
    return decrypted;
}

private static byte[] hexToBytes(String str) {
    if (str==null) {
        return null;
    } else if (str.length() &lt; 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i=0; i&lt;len; i++) {
            try {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            } catch (NumberFormatException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        return buffer;
    }
}
</code></pre>

<p><strong>and I'm reading and writing the files from SDCARD as</strong> </p>

<pre><code>String encyptedData = readFileFromSDCard(params[0]);

byte[] decryptedByteArray = decrypt(encyptedData);

File rootFile = new File(Constants.folioTempLocation+params[1]);
rootFile.mkdirs();

File outFile = new File(rootFile,  new File(params[0]).getName());
FileOutputStream out = new FileOutputStream(outFile);
//IOUtils.write(decryptedByteArray, out);
out.write(decryptedByteArray);
out.flush();
out.close();
</code></pre>

<p>There is no problem with decryption and writing files back to SD_CARD. But I'm <strong>getting unknown characters at the end of each file</strong> which is restricting the whole decrypted file to work properly.</p>

<p>I'm attaching screenshot of unknown characters concatenated to end of string. I'm also attaching an <a href=""https://drive.google.com/file/d/0B2JMyLa3sbeKb1ZkSDNJRk1Zbnc/edit?usp=sharing"" rel=""nofollow noreferrer"">encrypted_html_file</a> for anyone want to test the code using this file.</p>

<p>Screenshot
<img src=""https://i.stack.imgur.com/YWL4q.png"" alt=""sample image""></p>
"	NULL	5	NULL	16:33.5	5	36:05.9	48:39.2	NULL	1542796	1542796	0	1	0	<java><php><android><encryption><cryptography>	"Android AES with no padding decryption, unknown characters 'NUL' at the end of string"	1504	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
24781318	24781758	1	"<p>I have written this code in java in order to decrypt a ciphertext. I <em>have</em> the key. Everything seems correct to me but I have the problem that I'm gonna explain.<br>
Here is my code:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AES_CBC {

    public static void main(String[] args) throws Exception {

    byte[] keyBytes = new byte[] { 14, (byte) 0x0b, (byte) 0x41,
            (byte) 0xb2, (byte) 0x2a, (byte) 0x29, (byte) 0xbe,
            (byte) 0xb4, (byte) 0x06, (byte) 0x1b, (byte) 0xda,
            (byte) 0x66, (byte) 0xb6, (byte) 0x74, (byte) 0x7e, (byte) 0x14 };

    byte[] ivBytes = new byte[] { (byte) 0x4c, (byte) 0xa0, (byte) 0x0f,
            (byte) 0xf4, (byte) 0xc8, (byte) 0x98, (byte) 0xd6,
            (byte) 0x1e, (byte) 0x1e, (byte) 0xdb, (byte) 0xf1,
            (byte) 0x80, (byte) 0x06, (byte) 0x18, (byte) 0xfb, (byte) 0x28 };

    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    byte[] cipherText = new byte[] { (byte) 0x28, (byte) 0xa2, (byte) 0x26,
            (byte) 0xd1, (byte) 0x60, (byte) 0xda, (byte) 0xd0,
            (byte) 0x78, (byte) 0x83, (byte) 0xd0, (byte) 0x4e,
            (byte) 0x00, (byte) 0x8a, (byte) 0x78, (byte) 0x97,
            (byte) 0xee, (byte) 0x2e, (byte) 0x4b, (byte) 0x74,
            (byte) 0x65, (byte) 0xd5, (byte) 0x29, (byte) 0x0d,
            (byte) 0x0c, (byte) 0x0e, (byte) 0x6c, (byte) 0x68,
            (byte) 0x22, (byte) 0x23, (byte) 0x6e, (byte) 0x1d,
            (byte) 0xaa, (byte) 0xfb, (byte) 0x94, (byte) 0xff,
            (byte) 0xe0, (byte) 0xc5, (byte) 0xda, (byte) 0x05,
            (byte) 0xd9, (byte) 0x47, (byte) 0x6b, (byte) 0xe0,
            (byte) 0x28, (byte) 0xad, (byte) 0x7c, (byte) 0x1d, (byte) 0x81 };

    cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);
    byte[] original = cipher.doFinal(cipherText);
    String plaintext = new String(original);
    System.out.println(plaintext);
}
}
</code></pre>

<p>I get the error below:</p>

<pre><code>    Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:969)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:831)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
    at javax.crypto.Cipher.doFinal(Cipher.java:2097)
    at AES_CTR.main(AES_CBC.java:39)
</code></pre>

<p>What is going wrong?
I know the problem is somehow related to the padding but I don't the exact solution. I just have one ciphertext, IV, and the key.</p>
"	NULL	0	NULL	52:57.2	2	56:44.1	NULL	NULL	0	3845117	0	1	0	<java><cryptography><block-cipher>	AES-128 CBC decryption	1686	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
24907530	24907555	5	"<p>I got the following error and I got a little stuck:
Exception in thread ""main"" </p>

<pre><code>java.security.InvalidKeyException: Illegal key size or default parameters
at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1011)
                at javax.crypto.Cipher.implInit(Cipher.java:786)
                at javax.crypto.Cipher.chooseProvider(Cipher.java:849)
                at javax.crypto.Cipher.init(Cipher.java:1213)
                at javax.crypto.Cipher.init(Cipher.java:1153)
                at net.nakou.indie.wtext.engineClass.Session.cryptString(Session.java:52)
</code></pre>

<p>I'm stuck because all the answers I've found talk about the Java <strong>Cryptography Extension (JCE)</strong> which be normally included into the android SDK. So I think my problem is not this one.</p>

<p>I must have forgotten something, but I can't find what. Maybe my code is wrong (it's my first approach of cryptography in Java, I'm not an expert, and the following code is mostly some copy-pastes of tutorials).</p>

<p>I use this code to crypt and decrypt a String :</p>

<pre><code>public String cryptString(String s) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
    byte[] KeyData = this.cryptKey.getBytes();
    SecretKeySpec KS = new SecretKeySpec(KeyData, ""Blowfish"");
    Cipher cipher = Cipher.getInstance(""Blowfish"");
    cipher.init(Cipher.ENCRYPT_MODE, KS);
    String ret = new String(cipher.doFinal(s.getBytes(""UTF-8"")));
    return ret;
}

public String decryptString(byte[] s) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    byte[] KeyData = this.cryptKey.getBytes();
    SecretKeySpec KS = new SecretKeySpec(KeyData, ""Blowfish"");
    Cipher cipher = Cipher.getInstance(""Blowfish"");
    cipher.init(Cipher.DECRYPT_MODE, KS);
    String ret = new String(cipher.doFinal(s));
    return ret;
}
</code></pre>

<p>And the following key :</p>

<pre><code>private String cryptKey = ""qkjll5@2md3gs5Q@FDFqf"";
</code></pre>

<p>Thank you guys.</p>
"	NULL	1	NULL	04:48.9	13	15:49.3	02:01.2	NULL	6005797	2115678	0	1	20	<java><android>	java.security.InvalidKeyException: Illegal key size or default parameters in android	95340	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
25001552	25069053	2	"<p>I have encryption / decryption ciphers that I use in Android. It works great on Android 4.4</p>

<pre><code>static void setKey(byte[] keybytes, byte[] iv) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
    key = new SecretKeySpec(keybytes, ""AES"");
    ivspec = new IvParameterSpec(iv);
    encryptcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    encryptcipher.init(Cipher.ENCRYPT_MODE, key,ivspec);

    decryptcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    decryptcipher.init(Cipher.DECRYPT_MODE, key,ivspec);        
}
</code></pre>

<p>However, whenever I run this on Android 4.3 I get this error </p>

<pre><code>07-25 17:17:25.917: W/System.err(27544): java.lang.RuntimeException: java.security.NoSuchAlgorithmException: SecureRandom SHA1PRNG implementation not found
07-25 17:17:25.927: W/System.err(27544):    at java.security.SecureRandom.&lt;init&gt;(SecureRandom.java:100)
07-25 17:17:25.927: W/System.err(27544):    at javax.crypto.Cipher.init(Cipher.java:564)
07-25 17:17:25.927: W/System.err(27544):    at com.chatads.sdk.bm.a(SourceFile:56)
07-25 17:17:25.927: W/System.err(27544):    at com.chatads.sdk.x.a(SourceFile:241)
07-25 17:17:25.927: W/System.err(27544):    at com.chatads.sdk.ax.run(SourceFile:66)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:390)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.FutureTask.run(FutureTask.java:234)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:153)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:267)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1080)
07-25 17:17:25.927: W/System.err(27544):    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:573)
07-25 17:17:25.927: W/System.err(27544):    at java.lang.Thread.run(Thread.java:841)
07-25 17:17:25.927: W/System.err(27544): Caused by: java.security.NoSuchAlgorithmException: SecureRandom SHA1PRNG implementation not found
07-25 17:17:25.927: W/System.err(27544):    at java.security.Provider$Service.newInstance(Provider.java:1000)
07-25 17:17:25.927: W/System.err(27544):    at java.security.SecureRandom.&lt;init&gt;(SecureRandom.java:97)
07-25 17:17:25.927: W/System.err(27544):    ... 11 more
07-25 17:17:25.927: W/System.err(27544): Caused by: java.lang.IllegalAccessException: access to class not allowed
07-25 17:17:25.927: W/System.err(27544):    at java.lang.Class.newInstanceImpl(Native Method)
07-25 17:17:25.927: W/System.err(27544):    at java.lang.Class.newInstance(Class.java:1130)
07-25 17:17:25.927: W/System.err(27544):    at java.security.Provider$Service.newInstance(Provider.java:998)
07-25 17:17:25.927: W/System.err(27544):    ... 12 more
</code></pre>

<p>I ran this code </p>

<pre><code>Provider[] providers = Security.getProviders();
for (Provider provider : providers) {
    Log.i(""CRYPTO"",""provider: ""+provider.getName());
    Set&lt;Provider.Service&gt; services = provider.getServices();
    for (Provider.Service service : services) {
        Log.i(""CRYPTO"",""  algorithm: ""+service.getAlgorithm());
    }
}
</code></pre>

<p>found here <a href=""https://stackoverflow.com/questions/7560974/what-crypto-algroithms-does-android-support"">What crypto algorithms does Android support?</a></p>

<p>All AES, AES/CBC/PKCS5Padding, and SHA1PRNG all appeared in the output. Is this an Android bug? or am I doing something wrong?</p>
"	NULL	4	NULL	11:30.5	5	36:37.8	46:01.3	NULL	-1	2499420	0	1	2	<android><encryption>	android - supported algorithms bug?	675	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
25425486	0	1	"<p>i am getting this error while decryption i have go through the similar posts but i did not get any help from there. I want to store an object directly in a file with encryption for that i have posted my question <a href=""https://stackoverflow.com/questions/25399785/encrypt-complete-object-with-triple-des/25400892#25400892"">here</a>. But while using stream i am getting the same error as i am getting with string.  </p>

<pre><code>package security;

import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/**
 * This class defines methods for encrypting and decrypting using the Triple DES
 * algorithm and for generating, reading and writing Triple DES keys. It also
 * defines a main() method that allows these methods to be used from the command
 * line.
 */
public class TripleDesEncryptionDecryption {
  /**
   * The program. The first argument must be -e, -d, or -g to encrypt,
   * decrypt, or generate a key. The second argument is the name of a file
   * from which the key is read or to which it is written for -g. The -e and
   * -d arguments cause the program to read from standard input and encrypt or
   * decrypt to standard output.
   */
    private static final String UNICODE_FORMAT = ""UTF-8"";
    public static final String DESEDE_ENCRYPTION_SCHEME = ""DESede"";
    private KeySpec myKeySpec;
    private SecretKeyFactory mySecretKeyFactory;
    private Cipher cipher;
    byte[] keyAsBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;
    static String stringToEncrypt="""";

    public void setKey(String myKey) throws Exception
    {
        myEncryptionKey = myKey ;
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        myKeySpec = new DESedeKeySpec(keyAsBytes);
        mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
        key = mySecretKeyFactory.generateSecret(myKeySpec);
    }

    /**
     * Method To Encrypt The String
     */
    public String encrypt(byte[] plainText) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            //byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            //byte[] encryptedText = cipher.doFinal(plainText);
            BASE64Encoder base64encoder = new BASE64Encoder();
            encryptedString = base64encoder.encode(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }
    /**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();
            System.out.println(myEncryptionKey);
            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
    /**
     * Returns String From An Array Of Bytes
     */
    private static String bytes2String(byte[] bytes) {
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            stringBuffer.append((char) bytes[i]);
        }
        return stringBuffer.toString();
    }

    /**
     * Testing The DESede Encryption And Decryption Technique
    */
    public static void main(String args []) throws Exception
    {
        TripleDesEncryptionDecryption myEncryptor= new TripleDesEncryptionDecryption();


        myEncryptor.setKey(""tarunvermacdac@gmail.com"") ;

        System.out.println(""tarun1234"".getBytes());
        String encrypted=myEncryptor.encrypt(""tarun"".getBytes());
        String decrypted=myEncryptor.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+stringToEncrypt);
        System.out.println(""Encrypted Value :"" + encrypted);
        System.out.println(""Decrypted Value :""+decrypted);
    }
}
</code></pre>
"	NULL	0	NULL	43:19.8	3	47:06.1	45:46.4	NULL	-1	1343910	0	1	1	<java><des><tripledes>	javax.crypto.IllegalBlockSizeException: Input length not multiple of 8 bytes	20010	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
25891361	25910824	1	"<p>I have an Android application that communicates with another java application. For the data encryption i use the <code>javax.crypto</code> library to encrypt and decrypt the data with a pre-shared key. </p>

<p>According to <a href=""https://stackoverflow.com/questions/3593420/is-there-a-way-to-get-the-source-code-from-an-apk-file"">this</a> question it's possible to get the source code from an APK file. So if somebody is able to read the source code of my application, he's also able to read/manipulate the encrypted data. </p>

<p>It's probably true, so is there a way to prevent this (additional measures, other security method)? Don't know if it have extra value but here is my encryption code:</p>

<pre><code>private static String   IV              = ""AAAAAAAAAAAAAAAA"";
private static String   ENCRYPTION_KEY  = ""0123456789abcdef"";

Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
SecretKeySpec key = new SecretKeySpec(ENCRYPTION_KEY.getBytes(""UTF-8""), ""AES"");
cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(""UTF-8"")));
return cipher.doFinal(input.getBytes(""UTF-8""));
</code></pre>

<p><strong>EDIT:</strong>
Communication is send and recieving by NFC. My main issue is, if someone has the key he's able to read and write (abused) information to the other side (the NFC reader)</p>
"	NULL	9	NULL	03:46.9	3	15:40.9	26:24.5	NULL	-1	1852589	0	1	2	<java><android><encryption><nfc>	Is a pre-shared key safe between Android and another java application?	1490	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
25942165	25942381	1	"<p>I have a couple of library, C#, PHP and Android where they all encrypt/decrypt a string in the same way so they are all compatible with each other, i.e. C# writes and encrypts data to a database and PHP can successfully decrypt it and return the original string. </p>

<p>I now need to do the same thing with a standard Java application, so I've taken the code from my Android library and need libraries but I am getting an exception. As far as I know the code wasn't Android specific so it shouldn't be a problem. </p>

<p>Below is my encryption function </p>

<pre><code>public static String encrypt(String plainPasword)
    {
            String password = """";
            try
            {
                SecretKeySpec key = new SecretKeySpec(""hcxilkqbbhczfeultgbskdmaunivmfuo"".getBytes(""US-ASCII""), ""AES"");
                IvParameterSpec iv = new IvParameterSpec(""ryojvlzmdalyglrj"".getBytes(""US-ASCII""));

                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");

                cipher.init(Cipher.ENCRYPT_MODE, key, iv);

                byte[] encoded = cipher.doFinal(plainPasword.getBytes());
                password = new String(Base64.encodeBase64(encoded));

            }
            catch (Exception ex)
            {
                System.err.println(""Encryption Exception: "" + ex.toString());
            }
            return password;
    }
</code></pre>

<p>When I call <code>Encryption.encrypt(""myString"")</code> I get the following exception:</p>

<pre><code>Encryption Exception: java.security.NoSuchAlgorithmException: Cannot find any provider supporting AES/CBC/PKCS7Padding
</code></pre>

<p>As I said this code is working fine on Android and it shouldn't make any difference where it is running from. </p>

<h2>Update</h2>

<p>I found that I needed PKCS5Padding instead of 7 thanks to a link on a comment. I am now though getting the following exception:</p>

<pre><code>Encryption Exception: java.security.InvalidKeyException: Illegal key size
</code></pre>
"	NULL	5	NULL	47:55.3	4	55:11.2	55:11.2	NULL	472495	499448	0	1	6	<java><encryption><aes><jce><pkcs#7>	AES-256 and PKCS7Padding fails in Java	23184	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26068460	26070138	1	"<p>An <code>Android</code> client (4.2.1) application sends a public key via a <code>HttpPost</code> request to a <code>PHP</code> (5.6) API. This API encrypts the data with <code>AES</code> compliant <code>RIJNDAEL_128</code>, then encrypts the key for the AES encryption with the client public key with OpenSSL public encryption and <code>RSA_PKCS1_OAEP_PADDING</code>. It sends this data <code>base64</code> encoded via <code>XML</code> back to the client android application which shall encrypt the data. I've setup a basic PHP test script which tests the whole process, this works as expected.</p>

<p>Currently I'm working on implementing the decryption in the client Android application but already decrypting the AES-key fails. I have other questions besides this current problem (see at the end).</p>

<p>Here is a text graphical synopsis of what is happening:</p>

<pre><code>client -&gt; public key -&gt; API -&gt; data -&gt; AESencrypt(data), RSAencrypt(AES-key) -&gt; base64encode[AES(data)], base64encode[RSA(AES-key)] -&gt; &lt;xml&gt;base64[AES(data)], base64[RSA(AES-key)]&lt;/xml&gt; -&gt; client -&gt; base64[AES(data)], base64[RSA(AES-key)] -&gt; base64decode[AES(data)], base64decode[RSA(AES-key)] -&gt; AESdecrypt(data), RSAdecrypt(AES-key) -&gt; data
</code></pre>

<p>I'm encrypting the data with <code>MCRYPT_RIJNDAEL_128</code> which I read is AES compatible (see <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"" title=""PHP doc for mcryptquot;"">PHP doc for mycrypt</a>).
Here is the code:</p>

<pre class=""lang-php prettyprint-override""><code>&lt;?php
$randomBytes = openssl_random_pseudo_bytes(32, $safe);
$randomKey = bin2hex($randomBytes);
$randomKeyPacked = pack('H*', $randomKey);
// test with fixed key:
// $randomKeyPacked = ""12345678901234567890123456789012"";
$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
$dataCrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $randomKeyPacked, $data, MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>The AES-key coming out of this is encoded with <a href=""http://php.net/manual/en/function.openssl-public-encrypt.php"" rel=""nofollow noreferrer"">openssl_public_encrypt</a> and the padding setting <code>OPENSSL_PKCS1_OAEP_PADDING</code>. Reading the source code (<a href=""https://github.com/php/php-src/blob/d0cb715373c3fbe9dc095378ec5ed8c71f799f67/ext/openssl/openssl.c#L1176"" rel=""nofollow noreferrer"">source of PHP OpenSSL implementation</a>) this is equivalent to <code>RSA_PKCS1_OAEP_PADDING</code> described as </p>

<blockquote>
  <p>EME-OAEP as defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding parameter.</p>
</blockquote>

<p>in the OpenSSL documentation found <a href=""https://www.openssl.org/docs/crypto/RSA_public_encrypt.html"" rel=""nofollow noreferrer"">here</a>. Afterwards I <a href=""http://php.net/manual/en/function.base64-encode.php"" rel=""nofollow noreferrer"">base64_encode</a> the data to be able to transfer it via an XML string to the client. The code looks like this:</p>

<pre class=""lang-php prettyprint-override""><code>openssl_public_encrypt($randomKeyPacked, $cryptionKeyCrypted, $clientPublicKey, OPENSSL_PKCS1_OAEP_PADDING);
$content = array(
    'cryptionKeyCryptedBase64' =&gt; base64_encode($cryptionKeyCrypted),
    'cryptionIVBase64' =&gt; base64_encode($iv),
    'dataCryptedBase64' =&gt; base64_encode($dataCrypted)
);
// $content gets parsed to a valid xml element here
</code></pre>

<p>The client Android application gets the return data via <code>HttpPost</code> request via a <code>BasicResponseHandler</code>. This returned XML string is valid and parsed via <a href=""http://simple.sourceforge.net/"" rel=""nofollow noreferrer"">Simple</a> to respective java objects. In the the class holding the actual content of the transferred data I currently try to decrypt the data. I decrypt the AES-key with the transformation <code>RSA/ECB/OAEPWithSHA-1AndMGF1Padding</code> which due to <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#impl"" rel=""nofollow noreferrer"">this site</a> (only I could find) is a valid string and seems to be the equivalent of the padding I used in PHP. I included the way I generated the private key as it is the same way I generate the public key that was send to the PHP API. Here is that class:</p>

<pre class=""lang-java prettyprint-override""><code>public class Content {

    @Element
    private String cryptionKeyCryptedBase64;

    @Element
    private String cryptionIVBase64;

    @Element
    private String dataCryptedBase64;

    @SuppressLint(""TrulyRandom"")
    public String getData() {
        String dataDecrypted = null;
        try {
            PRNGFixes.apply(); // fix TrulyRandom
            KeyPairGenerator keygen = KeyPairGenerator.getInstance(""RSA"");
            keygen.initialize(2048);
            KeyPair keypair = keygen.generateKeyPair();
            PrivateKey privateKey = keypair.getPrivate();

            byte[] cryptionKeyCrypted = Base64.decode(cryptionKeyCryptedBase64, Base64.DEFAULT);
            //byte[] cryptionIV = Base64.decode(cryptionIVBase64, Base64.DEFAULT);

            Cipher cipherRSA = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"");
            cipherRSA.init(Cipher.DECRYPT_MODE, privateKey);
            byte[] key = cipherRSA.doFinal(cryptionKeyCrypted);

            byte[] dataCrytped = Base64.decode(dataCryptedBase64, Base64.DEFAULT);
            SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
            Cipher cipherAES = Cipher.getInstance(""AES"");
            cipherAES.init(Cipher.DECRYPT_MODE, skeySpec);
            byte[] decryptedAESBytes = cipherAES.doFinal(dataCrytped);
            dataDecrypted = new String(decryptedAESBytes, ""UTF-8"");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return dataDecrypted;
    }
}
</code></pre>

<p>Doing this I currently fail at line</p>

<pre><code>byte[] key = cipherRSA.doFinal(cryptionKeyCrypted);
</code></pre>

<p>with <code>Bad padding exceptions</code> for nearly all PHP <code>openssl_public_encrypt</code> padding parameter - Android Cipher transformation string combinations I tried. Using the standard PHP padding parameter by omitting the padding parameter in the openssl_public_encrypt which defaults to <code>OPENSSL_PKCS1_PADDING</code> and a Cipher transformation string of just <code>Cipher.getInstance(""RSA"")</code> I do not get a bad padding exception. But the encrypted key seems not to be valid as AES decryption fails with</p>

<pre><code>java.security.InvalidKeyException: Key length not 128/192/256 bits.
</code></pre>

<p>I tried validating this with a fixed key (see code comment in PHP code above) and I don't get the same key back after decrypting it and transforming it to a string. It seems it is just garbled data although it is 256 bits long if I read the Eclipse ADT debugger correctly.</p>

<p>What might be the correct Cipher transformation string to use as an equivalent for PHP's <code>OPENSSL_PKCS1_OAEP_PADDING</code>. Reading <a href=""http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#Cipher"" rel=""nofollow noreferrer"">this documentation</a> I need the transformation string in the form <code>""algorithm/mode/padding""</code>, I guessed that algorithm = RSA but I couldn't find out how to translate what the OpenSSL (above) documentation states about the padding into a valid cipher transformation string. I.e. what is <code>mode</code> for example?
Unfortunately this <a href=""https://stackoverflow.com/questions/17819183/android-rsa-decryption-fails-server-side-encryption-openssl-public-encrypt/17820910#17820910"">Android RSA decryption (fails) / server-side encryption (openssl_public_encrypt)</a> accepted answer did not solve my problem.</p>

<p>Anyway might this solve my problem or does my problem originate elsewhere?</p>

<p>How would I further debug this? What is the correct way to transform the base64 decoded, decrypted key into a human readable form so I can compare it with the key used to encrypt?
I tried with:</p>

<pre><code>String keyString =  new String(keyBytes, ""UTF-8"");
</code></pre>

<p>But this doesn't give any human readable text back so I assume either the key is wrong or my method of transforming it.</p>

<p>Also decrypting the AES encrypted data in PHP the IV is needed in the decryption function <a href=""http://php.net/manual/en/function.mcrypt-decrypt.php"" rel=""nofollow noreferrer"">mcrypt_decrypt</a>. As you can see in the code I send it but it seems in Android this is not needed? Why so?</p>

<p>PS: I hope I provided all needed information, I can add further in the comments.</p>

<p>PPS: For completeness here is the Android client code making the HttpPost request:</p>



<pre><code>@SuppressLint(""TrulyRandom"")
protected String doInBackground(URI... urls) {
    try {
        System.setProperty(""jsse.enableSNIExtension"", ""false"");
        HttpClient httpClient = createHttpClient();
        HttpPost httpPost = new HttpPost(urls[0]);

        PRNGFixes.apply(); // fix TrulyRandom
        KeyPairGenerator keygen = KeyPairGenerator.getInstance(""RSA"");
        keygen.initialize(2048);
        KeyPair keypair = keygen.generateKeyPair();
        PublicKey publickey = keypair.getPublic();
        byte[] publicKeyBytes = publickey.getEncoded();
        String pubkeystr = ""-----BEGIN PUBLIC KEY-----\n""+Base64.encodeToString(publicKeyBytes,
                Base64.DEFAULT)+""-----END PUBLIC KEY-----"";

        List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(2);
        nameValuePairs.add(new BasicNameValuePair(""publickey"", pubkeystr));
        httpPost.setEntity(new UrlEncodedFormEntity(nameValuePairs));

        // Execute HTTP Post Request
        HttpResponse response = httpClient.execute(httpPost);
        return new BasicResponseHandler().handleResponse(response);
    } catch (Exception e) {
        Toast toast = Toast.makeText(asyncResult.getContext(),
                ""unknown exception occured: "" + e.getMessage(),
                Toast.LENGTH_SHORT);
        toast.show();
        return ""error"";
    }
}
</code></pre>
"	NULL	1	NULL	16:54.6	6	23:51.6	13:20.5	NULL	-1	928666	0	1	4	<java><php><android><security><encryption>	decrypting php encrypted data on android	3099	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26369350	26388095	1	"<p>Following on <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">this question</a> and its answer, I am creating an application that given a password string, will convert a plaintext and store its ciphertext, the salt generated and the initialization vector in a text file.</p>

<p>In the following code : </p>

<pre><code>public String decrypt(CryptGroup cp) throws Exception {
    String plaintext = null;
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password, cp.getSalt(), ITERATIONS, KEY_SIZE);
    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(cp.getIv()));
    plaintext = new String(cipher.doFinal(cp.getCipher()), ""UTF-8"");

    return plaintext;
}

public CryptGroup encrypt(String plainText) throws Exception {
    byte[] salt = generateSalt();
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password, salt, ITERATIONS, KEY_SIZE);
    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    byte[] ciphertext = cipher.doFinal(plainText.getBytes(""UTF-8""));

    return new CryptGroup(ciphertext, salt, iv);
}
</code></pre>

<p>The CryptGroup object contains those 3 parameters (ciphertext, salt, iv : byte arrays for that matter).</p>

<p>Is it safe to store the initialization vector? </p>

<p>The answer in that question clearly states that the salt doesn't need to be secret, obviously the ciphertext can be also available, but what about the iv parameter?</p>

<p><strong>Edit</strong>
If it is not safe to share, is it possible to retrieve the original iv from the salt alone?</p>
"	NULL	0	NULL	03:56.1	3	15:38.2	34:09.1	NULL	-1	3202885	0	1	4	<java><encryption><aes>	AES 256 decryption - Is IV safe to share?	1332	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26517944	0	1	"<p>I have two classes, one is main class and another is the implementation of AES.</p>

<p>However, in my AES class i have a method to decrypt a string, but whenever i run it, it gives an exception</p>

<p>My encryption method works just fine but my decryption method doesn't work as expected.</p>

<p>The code</p>

<pre><code>private Cipher aesCipherForDecryption;
String strDecryptedText = new String();

public String decryptAES(final String ciphertext) {

    try {

        aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iV));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);
        strDecryptedText = new String(byteDecryptedText);

    } catch (IllegalBlockSizeException e) {
        System.out.print(""IllegalBlockSizeException "" +e);
    } catch (BadPaddingException e) {
        System.out.print(""BadPaddingException ""+e);
    } catch (NoSuchAlgorithmException e) {
        System.out.print(""NoSuchAlgorithmException ""+ e);
    } catch (NoSuchPaddingException e) {
        System.out.print(""NoSuchPaddingException ""+e);
    } catch (InvalidKeyException e) {
        System.out.print(""InvalidKeyException ""+e);
    } catch (InvalidAlgorithmParameterException e) {
        System.out.print(""InvalidAlgorithmParameterException ""+e);
    }

    System.out.println(""\nDecrypted Text message is "" + strDecryptedText);
    return strDecryptedText;
}
</code></pre>

<p>The error this method outputs is</p>

<blockquote>
  <p>InvalidKeyException java.security.InvalidKeyException: No installed provider supports this key: (null)</p>
</blockquote>

<p>UPDATE #1:</p>

<p>So i have updated the code as the following</p>

<pre><code>public String decryptAES(byte[] ciphertext) {
    String strDecryptedText = new String();
        try {
            byte[] byteDecryptedText = aesCipherForDecryption.doFinal(ciphertext);

            strDecryptedText = new String(byteDecryptedText);

        } catch (IllegalBlockSizeException e) {
            System.out.print(""IllegalBlockSizeException ""+e);
            e.printStackTrace();
        } catch (BadPaddingException e) {
            System.out.print(""BadPaddingException ""+e);
            e.printStackTrace();
        }

    System.out.println(""\nDecrypted Text message is "" + strDecryptedText);
    return strDecryptedText;
}    
</code></pre>

<p>and in the main class i have this line</p>

<pre><code>byte [] byteciphertext = ciphertext.getBytes();
</code></pre>

<p>just to convert the string to bytes</p>

<p>is it correct? i'm still having </p>

<pre><code>IllegalBlockSizeException javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipherjavax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
</code></pre>

<p>Could someone help me fix this issue?</p>

<p>Thank you.</p>
"	NULL	3	NULL	06:36.8	4	45:28.9	59:14.2	NULL	3022331	3022331	0	1	7	<java><encryption><aes>	InvalidKeyException java.security.InvalidKeyException: No installed provider supports this key: (null)	27661	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26693239	26693383	1	"<p>I know this question has been asked several times but it doesn't seem to work with my code.</p>

<p>I'm getting an exception when decrypting: </p>

<p>""javax.crypto.BadPaddingException: pad block corrupted""</p>

<p>My code is:</p>

<pre><code>private static byte[] appendIvToEncryptedData(byte[] eData, byte[] iv) throws Exception {
       ByteArrayOutputStream os = new ByteArrayOutputStream();
       os.write(eData);
       os.write(iv);
       return os.toByteArray();
    }

protected static byte[] dataEncryption(byte[] plainText)
    throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
    byte [] iv = new byte[Constants.AES_BYTE_LENGTH];
    random.nextBytes(iv);
    AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
    SecretKeySpec secretKeySpec = new SecretKeySpec(mAESKey, ""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, paramSpec);
    return appendIvToEncryptedData(cipher.doFinal(plainText), cipher.getIV());
}


protected static byte[] dataDecryption(byte[] encrypted)
    throws Exception {
    int ivIndex = encrypted.length - Constants.AES_BYTE_LENGTH;
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    SecretKeySpec secretKeySpec = new SecretKeySpec(mAESKey, ""AES"");
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, 
            new IvParameterSpec(encrypted, ivIndex, Constants.AES_BYTE_LENGTH));

    return cipher.doFinal(encrypted);
}
</code></pre>

<p>The exception is thrown when calling cipher.doFinal() in the dataDecryption() function. Besides, calling SecureRandom got this warning: ""Potentially insecure random numbers on Android 4.3 and older. Read <a href=""https://android-developers.blogspot.com/2013/08/some-"" rel=""nofollow noreferrer"">https://android-developers.blogspot.com/2013/08/some-</a>
 securerandom-thoughts.html for more info.""</p>

<p>I'm reading and writing files using RandomAccessFile and FileOutputStream so I'm working directly with byte arrays.</p>

<p>I've taken a look at this other question and modifyed my code as it says but still doesn't work:</p>

<p><a href=""https://stackoverflow.com/questions/13383006/encryption-error-on-android-4-2"">Encryption error on Android 4.2</a></p>

<p>By the way, I'm encrypting in one device and decrypting in another different.</p>

<p>This is my stack trace:</p>

<pre><code>11-01 20:57:14.820: I/Exception(26336): javax.crypto.BadPaddingException: pad block corrupted
11-01 20:57:14.820: I/Exception(26336):     at com.android.org.bouncycastle.jce.provider.JCEBlockCipher.engineDoFinal(JCEBlockCipher.java:701)
11-01 20:57:14.820: I/Exception(26336):     at javax.crypto.Cipher.doFinal(Cipher.java:1106)
11-01 20:57:14.820: I/Exception(26336):     at com.example.example.KeyManagement.dataDecryption(KeyManagement.java:132)
11-01 20:57:14.820: I/Exception(26336):     at com.example.example.SecureReceiving$1.onEvent(SecureReceiving.java:86)
11-01 20:57:14.820: I/Exception(26336):     at android.os.FileObserver$ObserverThread.onEvent(FileObserver.java:125)
11-01 20:57:14.820: I/Exception(26336):     at android.os.FileObserver$ObserverThread.observe(Native Method)
11-01 20:57:14.820: I/Exception(26336):     at android.os.FileObserver$ObserverThread.run(FileObserver.java:88)
</code></pre>

<p>Hope you can help me, thanks in advance.</p>
"	NULL	4	NULL	05:04.0	5	09:08.4	15:57.6	NULL	-1	3846857	0	1	2	<java><android><encryption><badpaddingexception>	BadPaddingException: pad block corrupted in android decrypting block	4107	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26723118	26743442	1	"<p>I , wrote java method, which encrypts - decrypts data.</p>

<pre><code>    String message = ""Hello world 123456"";

    // Creating Key. Key of size = 128
    byte [] raw ={-49, -44, 51, -114, 58, 79, 83, -38, 107, 64, 67, -108, -52, 109, 85, 77};
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

    // Encript
    byte[] encrypted = cipher.doFinal(message.getBytes());
    System.out.println(""encripted: "" + Arrays.toString(encrypted));
    System.out.println(""encripted: ""+ asHex(encrypted));

    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decript = cipher.doFinal(encrypted, 0, 32);
</code></pre>

<p>Everything works well! encrypted bytes size is 32.  That is correct. But can I dencrypt part to part (block to block - for instance, decrypt first block, then second) ? I mean to decript firstly 16 byte and then second 16 byte and etc..</p>

<p>might be something like this.</p>

<pre><code>byte[] decript = cipher.doFinal(encrypted, 0, 16);
</code></pre>

<p>I have such error:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
</code></pre>

<p><strong>In the other word, can I decrypt AES cipher text, block to block?</strong> </p>

<p><strong>Update:</strong>
I have encrypted video file.  It is for about 1 gb. I want to write my video player, which will open my file. If I will decript full video there will be memory problem. So I will give bytes of stream step to step to my player (block to block). Can I use AES for that?</p>
"	NULL	10	NULL	59:55.2	2	31:00.5	10:19.3	NULL	2590960	2590960	0	1	1	<java><encryption><cryptography><aes>	"how to decrypt partitions of cipertext - AES, Java"	574	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
26849580	26851569	1	"<p>I am trying to encrypt text using the AES encryption algorithm , save this encrypted text to a file and then reopen later and decrypt these. Following is my encryption and decryption logic</p>

<pre><code>    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    byte[] stringBytes = clear_text.getBytes();
    byte[] raw = cipher.doFinal(stringBytes);
    return Base64.encodeBase64String(raw);
</code></pre>

<p>And this is the decryption logic </p>

<pre><code>    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key, iv);
    byte[] raw = Base64.decodeBase64(encText);
    byte[] stringBytes = cipher.doFinal(raw);
    String clear_text = new String(stringBytes, ""UTF8"");
    return clear_text;
</code></pre>

<p>I get a <em>BadPaddingSize exception</em>. My guess is that by using the SecureRandom class, both the methods use different keys while encrypting or decypting text. Is there a way I can use the same key in both the routines?</p>
"	NULL	2	NULL	36:51.0	3	29:18.9	NULL	NULL	0	3987161	0	1	0	<java><encryption><aes><symmetric-key>	Alternative to using SecureRandom to generate AES key and IV	4324	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
27124931	29681521	2	"<p>We instantiate the cipher with the following statement:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES"");
SecretKeySpec key = new SecretKeySpec(cipherKey, ""AES"");
</code></pre>

<p>This works in java 7 (1.7_45) but no longer works in Java 8 (1.8_25). We pass the <code>cipher</code> to a <code>CipherInputStream</code> and use the streams to read/write data. The actual exception occurs during <code>close</code>.</p>

<p><strong>EDIT:</strong></p>

<p>A quick look at the JDK code shows that the BadPaddingException is rethrown and in 7 it was ignored:</p>

<p>JDK 7: CipherInputStream.close:</p>

<pre><code> try {
  this.cipher.doFinal();
} catch (BadPaddingException var2) {
  ;
} catch (IllegalBlockSizeException var3) {
  ;
}
</code></pre>

<p>JDK 8: CipherInputStream.close:</p>

<pre><code>try {
    if(!this.done) {
      this.cipher.doFinal();
    }
  } catch (IllegalBlockSizeException | BadPaddingException var2) {
    if(this.read) {
      throw new IOException(var2);
    }
  }
</code></pre>

<p>The question is how to avoid a BadPaddingException in the first place?</p>

<p><strong>EDIT 2:</strong></p>

<p>After doing some research and experimentation we came to the following test program:</p>

<pre><code>public final class CipherSpike2 {

  private static final byte[] SECRET_KEY = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

  public static void main(String[] args)
  throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException {
    encryptDecrypt(511);
    encryptDecrypt(512);
  }

  private static void encryptDecrypt(int i)
  throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {

    byte[] clearText = generateClearText(i);
    System.out.println(""Clear text length: "" + clearText.length);

    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    CipherOutputStream cos = new CipherOutputStream(bos, getCipher(Cipher.ENCRYPT_MODE));
    cos.write(clearText);
    cos.close();

    final byte[] content = bos.toByteArray();
    System.out.println(""written bytes: "" + content.length);

    CipherInputStream
    inputStream =
    new CipherInputStream(new ByteArrayInputStream(content), getCipher(Cipher.DECRYPT_MODE));

    inputStream.read();
    inputStream.close();
 }

 private static byte[] generateClearText(int size) {
    return new byte[size];
  }

  private static Cipher getCipher(int encryptMode)
  throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    SecretKeySpec key = new SecretKeySpec(SECRET_KEY, ""AES"");
    cipher.init(encryptMode, key);
    return cipher;
  }
}
</code></pre>

<p>First, the program writes 511 bytes which results in a 512 byte long ""file content"". 
We read exactly one byte. The CipherInputStream reads the data in a 512 byte chunk, so every byte is read and we can close the stream. </p>

<p>Next, we create a content of 512 bytes. This gets padded to 528. If we now read only one byte, we have some bytes left and if we close the stream now it crashes with the given exception. </p>

<p>Now this problem is especially problematic in conjunction with ZipStreams: The encrypted content is in a previous step zipped with a ZipOutputStream and read with a ZipInputStream. It seems, that the ZipInputStream does not consume the same amount of bytes as it has previously written.</p>

<p>It seems that the only solution is to catch the BadPaddingException in the close().(?) From an API view point it seems weird to me, that I cannot close a stream without exception regardless of the number of bytes I've read.</p>

<p><strong>EDIT 3 ZipStream elaboration:</strong></p>

<p>In our application we read a bunch of encrypted text files. So the consturction for the streams looks like this:</p>

<pre><code>BufferedReader/Writer -&gt; InputStreamReader/Writer -&gt; ZipInputStream/Output -&gt; CipherInputStream/Output -&gt; Underlying File Stream
</code></pre>

<p>We read the content of the file with a ""traditional"" while (reader.readLine != null) loop until we reach EOF. After that we try to close the file. But sometimes this results in an exception in Java 8 - see above (-:. It seems, that the ZipOutputStream writes more bytes then the ZipInputStreams  consumes, but I don't looked at the code yet. </p>
"	NULL	7	NULL	03:51.8	2	12:10.0	07:42.2	NULL	1716487	1716487	0	1	9	<java><encryption><aes><java-8>	"Java 7 -> Java 8: AES Causes exception: ""BadPaddingException: Given final block not properly padded"" in conjunction with BufferedReader & ZipStreams"	5249	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
27248644	27250179	2	"<p>I have the following cryptojs based javascript encryption/decryption functions which works perfectly fine. </p>

<p>I use a random salt, random iv value and a specific password while encrypting the message using cryptpjs. I reuse the same salt, iv and the password to generate the key while decrypting  the encrypted message.</p>

<p>This part works well..</p>

<pre><code>function  encrypt(){
  var salt = CryptoJS.lib.WordArray.random(128/8);
  var iv = CryptoJS.lib.WordArray.random(128/8);
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key128Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32 }); 
  console.log( 'key128Bits '+ key128Bits);
  var key128Bits100Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key128Bits100Iterations '+ key128Bits100Iterations);
  var encrypted = CryptoJS.AES.encrypt(""Message"", key128Bits100Iterations, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7  });
  console.log('encrypted   '+ encrypted  );
}

function  decrypt(){
  var salt = CryptoJS.enc.Hex.parse(""4acfedc7dc72a9003a0dd721d7642bde"");
  var iv = CryptoJS.enc.Hex.parse(""69135769514102d0eded589ff874cacd"");
  var encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key '+ key);
  var decrypt = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
  var ddd = decrypt.toString(CryptoJS.enc.Utf8); 
  console.log('ddd '+ddd);
} 
</code></pre>

<p>But the issue starts when I try to decrypt the same encrypted text at the java server side.
I want the encrypted message to be decrypted by my java  server code.
Here is the Java code that I wrote:</p>

<pre><code>public static void main(String args[]) throws Exception{
  String password = ""Secret Passphrase"";
  String salt = ""4acfedc7dc72a9003a0dd721d7642bde"";
  String iv = ""69135769514102d0eded589ff874cacd"";
  String encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  byte[] saltBytes = salt.getBytes(); //hexStringToByteArray(salt);
  byte[] ivBytes = iv.getBytes();//hexStringToByteArray(iv);
  IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);        
  SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(password, saltBytes);
  System.out.println( decrypt( encrypted , sKey ,ivParameterSpec));
}

public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {

  KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128/32);
  SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
  SecretKey secretKey = keyFactory.generateSecret(keySpec);
  return new SecretKeySpec(secretKey.getEncoded(), ""AES"");
}

public static String decrypt(String encryptedData, SecretKeySpec sKey, IvParameterSpec ivParameterSpec) throws Exception {

  Cipher c = Cipher.getInstance(""AES"");
  c.init(Cipher.DECRYPT_MODE, sKey, ivParameterSpec);
  byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
  byte[] decValue = c.doFinal(decordedValue);
  String decryptedValue = new String(decValue);
  return decryptedValue;
}
</code></pre>

<p>But I get the following exception:</p>

<pre><code>Exception breakpoint: SecretKeySpec.java:96, java.lang.IllegalArgumentException, Empty key
Exception in thread ""main"" java.lang.IllegalArgumentException: Empty key
at javax.crypto.spec.SecretKeySpec.&lt;init&gt;(SecretKeySpec.java:96)
</code></pre>

<p>I have no idea what I should do</p>
"	NULL	0	NULL	46:35.8	4	23:44.9	57:28.5	NULL	474189	1455719	0	1	11	<java><encryption><aes><cryptojs>	How to decrypt a cryptojs AES encrypted message at the java server side?	12670	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
27729937	0	1	"<p>How to Store the AES Key in Database using JavaKeyStore, please check the complete code and its straight forward. Currently i am storing the Key in .JCEKS extension in a given location, need to store the Key in database and read it back for encryption. Please help me out.</p>

<p>Note: This code is working any one who wants to encrypt and decrypt and store the date in the database use my code. Key generated gets save in file format and is retrieved back for reuse, encrypt or decrypt.</p>

<pre><code>package user.dao;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Security;
import java.security.KeyStore.PasswordProtection;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

import de.blowfish.core.Blowfish;

import user.util.UserConstants;

import user.bean.UserLoginBean;
import user.util.DButil;



public class UserDao {

public int insertUserDetails(Object bean)
{

    user.bean.UserLoginBean beanobj=(UserLoginBean)bean;
    Connection conn=null;
    PreparedStatement ps=null;
    PreparedStatement ps1=null;
    ResultSet rs = null;
    int result=0;
    try{

    conn=DButil.getConnection();
    StringBuffer sbinsert=new StringBuffer();
    sbinsert.append(""insert into "");
    sbinsert.append(UserConstants.USER_DETAILS_TABLE_NAME);
    sbinsert.append("" values(?,?,?,?,?,?)"");

    //KeyStore Table

    conn=DButil.getConnection();
    StringBuffer sbinsert1 =new StringBuffer();
    sbinsert1.append(""insert into "");
    sbinsert1.append(UserConstants.USER_DETAILS_TABLE_NAME1);
    sbinsert1.append("" values(?,?)"");

    //

    Security.addProvider(new blowfishProvider());


    Cipher cipher = Cipher.getInstance(""AES128_CBC"", ""blowfish"");
    KeyGenerator keyGen = KeyGenerator.getInstance(""AES"", ""blowfish"");
    SecretKey secKey = keyGen.generateKey();



    // Storing the secret Key
                final String keyStoreFile = ""C:\\mykey.jceks"";
                 //String keyStoreFile = new String(sbinsert1);
                //final String keyStoreDB = beanobj.getKeylock();
                 KeyStore keyStore = createKeyStore(keyStoreFile, ""java0123"");
                 System.out.println(""Stored Key: "" + (secKey));
                 System.out.println(""secured key: "" + (keyStore));


    // store the secret key
                 KeyStore.SecretKeyEntry keyStoreEntry = new KeyStore.SecretKeyEntry(secKey);
                 PasswordProtection keyPassword = new PasswordProtection(""www-secret"".toCharArray());
                 keyStore.setEntry(""mySecretKey"", keyStoreEntry, keyPassword);
                 keyStore.store(new FileOutputStream(keyStoreFile), ""java0123"".toCharArray());
                 //keyStore.store(new FileOutputStream(keyStoreDB), ""java0123"".toCharArray());


    //Encryption of string
    String clearText = beanobj.getPassword() ;
    byte[] clearTextBytes = clearText.getBytes(""UTF8"");
    cipher.init(Cipher.ENCRYPT_MODE, secKey);
    byte[] cipherBytes = cipher.doFinal(clearTextBytes);
    String cipherText = new String(cipherBytes, ""UTF8"");

    //Decryption of String
    cipher.init(Cipher.DECRYPT_MODE, secKey );
    byte[] decryptedBytes = cipher.doFinal(cipherBytes);
    String decryptedText = new String(decryptedBytes, ""UTF8"");

    System.out.println(""Before encryption: "" + clearText);
    System.out.println(""After encryption: "" + cipherText);
    System.out.println(""After decryption: "" + decryptedText);

    //


    ps=conn.prepareStatement(sbinsert.toString());
    ps.setString(1,beanobj.getFirstname());
    ps.setString(2, beanobj.getLastname());
    ps.setString(3, beanobj.getUsername());
    ps.setString(4, cipherText);
    ps.setString(5, beanobj.getEmail());
    ps.setString(6, beanobj.getMobileno());

    ps1=conn.prepareStatement(sbinsert1.toString());
    beanobj.setKeylock(""mykey""); // Dummy key for checking if logic works
    ps1.setString(1,beanobj.getUsername());
    ps1.setString(2,beanobj.getKeylock());

    result=ps.executeUpdate();
    result=ps1.executeUpdate();

    }
    catch(SQLException e)
    {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchProviderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();


    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (BadPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    finally{
        DButil.closeAllDBResources(conn, ps, null);
    }
    return result;


    }
public boolean isRegisteredUser(String un,String pw)
{
    boolean result=false;
    Connection conn=null;
    PreparedStatement ps=null;
    ResultSet rs=null;
    try
    {
        conn=DButil.getConnection();
        StringBuffer sbselect=new StringBuffer();
        sbselect.append(""select * from "");
        sbselect.append(UserConstants.USER_DETAILS_TABLE_NAME);
        sbselect.append("" where BINARY Username=? and Password=?"");
        ps=conn.prepareStatement(sbselect.toString());


        // Retreving the key 

        Security.addProvider(new FlexiCoreProvider());
        Cipher cipher1 = Cipher.getInstance(""AES128_CBC"", ""FlexiCore"");
        KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
        System.out.println(keyStore);
        FileInputStream fis = new FileInputStream(""C:\\mykey.jceks"";);

        keyStore.load(fis, ""java0123"".toCharArray());              
        Key secKey = keyStore.getKey(""mySecret"",""www-secret"".toCharArray());


        //Encrypting the User Passowrd and comparing with the DB enPassword one way process

        String clearText = pw ;
        byte[] clearTextBytes = clearText.getBytes(""UTF8"");
        cipher1.init(Cipher.ENCRYPT_MODE, secKey);
        byte[] cipherBytes = cipher1.doFinal(clearTextBytes);
        String cipherText1 = new String(cipherBytes, ""UTF8"");




        ps.setString(1, un);
        ps.setString(2, cipherText1);
        //System.out.println(ps.toString());
        rs=ps.executeQuery();
        if(rs.next())
        {
            result=true;
        }
    }
    catch(SQLException e)
    {
        System.out.println(e);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchProviderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (KeyStoreException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (UnrecoverableKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (BadPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    finally
    {
        DButil.closeAllDBResources(conn, ps, rs);
    }


    return result;
}
public int executeUpdate(String query)
{
    int result=0;
    Connection conn=null;
    PreparedStatement ps=null;
    try
    {
        conn=DButil.getConnection();
        ps=conn.prepareStatement(query);
        result=ps.executeUpdate();

    }
    catch(SQLException e)
    {
        e.printStackTrace();

    }
    finally{
        DButil.closeAllDBResources(conn, ps, null);
    }
    return result;
}

private static java.security.KeyStore createKeyStore(String keyStoreFile,
        String pw) throws Exception {
    // TODO Auto-generated method stub
     File file = new File(""mykey.jceks"");
     /**
      * Note that if you are storing a SecretKey or using any part of the SunJCE provider
      *  (Java Cryptography Extension),
      *  you will need to set your KeyStore type to JCEKS.
      */
        final KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
        if (file.exists()) {
            // .keystore file already exists =&gt; load it
            keyStore.load(new FileInputStream(file), www.toCharArray());
        } else {
            // .keystore file not created yet =&gt; create it
            keyStore.load(null, null);
            keyStore.store(new FileOutputStream(""mykey1.jceks""), www.toCharArray());
        }

        return keyStore;
       }

       }
</code></pre>
"	NULL	2	NULL	25:07.0	3	27:46.0	NULL	NULL	0	4337210	0	1	0	<java><security><encryption>	"How to store the AES Key in database using JavaKeyStore, currently i am storing the key in a folder with .JCEKS extension,"	1666	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
27900193	27969324	3	"<p>I have two classes named encryption.java and decryption.java. I want encrypt a text file using the encrypt.java class and decrypt from decrypt.java class. I can encrypt the text file successfully, but not able to decrypt it in same way. Can anyone tell me why not? </p>

<p>This is encrypt.java:</p>

<pre><code> public class Encrypt{


public static void main(String[] args) throws Exception {

   String FileName = ""D:/ashok/normal.txt"";
    String FileName1 = ""D:/ashok/encrypted.txt"";


    KeyGenerator KeyGen = KeyGenerator.getInstance(""AES"");
    KeyGen.init(128);

    SecretKey SecKey = KeyGen.generateKey();

    Cipher AesCipher = Cipher.getInstance(""AES"");



    byte[] cipherText = Files.readAllBytes(Paths.get(FileName));
    AesCipher.init(Cipher.ENCRYPT_MODE, SecKey);
    byte[] byteCipherText = AesCipher.doFinal(cipherText);
    Files.write(Paths.get(FileName1), byteCipherText);
 }
</code></pre>

<p>This is my decrypt.java class:</p>

<pre><code> class decrypt{
 public static void main(String[] args) {
    try {
   String FileName1 = ""D:/ashok/encrypted.txt"";
        String FileName2 = ""D:/ashok/decrypted.txt"";

        KeyGenerator KeyGen = KeyGenerator.getInstance(""AES"");
        KeyGen.init(128);

        SecretKey SecKey = KeyGen.generateKey();

        Cipher AesCipher =  Cipher.getInstance(""AES"");
        byte[] cipherrText = Files.readAllBytes(Paths.get(FileName1));

        AesCipher.init(Cipher.DECRYPT_MODE, SecKey);
        byte[] bytePlainText = AesCipher.doFinal(cipherrText);
        Files.write(Paths.get(FileName2), bytePlainText);  }}
</code></pre>

<p>and getting error when decrypt class runs, like this</p>

<pre><code> javax.crypto.BadPaddingException: Given final block not properly padded
  at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
  at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
  at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:313)
  at javax.crypto.Cipher.doFinal(Cipher.java:2086)
  at decryption.main(decryption.java:79)
</code></pre>
"	NULL	1	NULL	45:40.3	2	25:46.3	11:00.7	NULL	4140650	4140650	0	1	0	<java><encryption><cryptography>	Java error in decryption	1193	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
27965798	27967292	2	"<p>When retrieving instance of <code>javax.crypto.Cipher</code> you may request a particular provider or let the system to choose one:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"" /*, here may be Provider parameter*/);
</code></pre>

<p>Is it <strong>guaranteed</strong> that omitting of the provider parameter will work always and message encrypted on one system can be decrypted on another?<br>
Or, in other words, are providers responsible only for implementation and text encrypted by provider A can be always decrypted by provider B?</p>
"	NULL	3	NULL	36:01.8	3	27:24.8	42:07.0	NULL	3349800	3349800	0	1	0	<java><encryption>	Can javax.crypto.Cipher return different results for different providers?	651	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28015194	28015560	2	"<p>I am developing an android app that secures images and videos like <a href=""https://play.google.com/store/apps/details?id=com.theronrogers.vaultyfree&amp;hl=en/"" rel=""nofollow"" title=""Vaulty"">Vaulty</a> and <a href=""https://play.google.com/store/apps/details?id=com.kii.safe&amp;hl=en"" rel=""nofollow"" title=""Keep Safe"">Keep safe</a>. I am trying to use AES-128 encryption/decryption technique to store images and videos. I tried it by taking 3 sample images of size 5.13, 4.76 and 5.31 respectively. But the time it is consuming to encrypt is 25s, 22s, 27s respectively and time to decrypt is 31s, 30s, 34s respectively. I am testing it on HTC One X. </p>

<p>Such speed wont be feasible for my app as users will scroll and view images quickly without interruption. Can you please suggest me how can I improve the performance(speed) or should i switch to other algorithms? Can you please suggest me any other techniques through which i can encrypt/decrypt images and videos quickly without compromising security too much.</p>

<p>I tried <a href=""https://play.google.com/store/apps/details?id=com.theronrogers.vaultyfree&amp;hl=en/"" rel=""nofollow"" title=""Vaulty"">Vaulty</a> and <a href=""https://play.google.com/store/apps/details?id=com.kii.safe&amp;hl=en"" rel=""nofollow"" title=""Keep Safe"">Keep safe</a>, and they are very quick. Vaulty is said to be using AES-256, but it is still very fast and responsive in terms of encrypting and viewing images. How is it possible that vaulty is that quick using AES-256?</p>

<p>Code I am using is:</p>

<pre><code> static void encrypt(String filename) throws IOException, NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException {

    // Here you read the cleartext.
    File extStore = Environment.getExternalStorageDirectory();
    startTime = System.currentTimeMillis();
    Log.i(""Encryption Started"",extStore + ""/5mbtest/""+filename);
    FileInputStream fis = new FileInputStream(extStore + ""/5mbtest/""+filename);
    // This stream write the encrypted text. This stream will be wrapped by
    // another stream.



    FileOutputStream fos = new FileOutputStream(extStore + ""/5mbtest/""+filename+"".aes"", false);

    // Length is 16 byte
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(),
            ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);
    // Wrap the output stream
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while ((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();
    stopTime = System.currentTimeMillis();
    Log.i(""Encryption Ended"",extStore + ""/5mbtest/""+filename+"".aes"");
    Log.i(""Time Elapsed"", ((stopTime - startTime)/1000.0)+"""");
}

static void decrypt(String filename) throws IOException, NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException {
    File extStore = Environment.getExternalStorageDirectory();
    Log.i(""Decryption Started"",extStore + ""/5mbtest/""+filename+"".aes"");
    FileInputStream fis = new FileInputStream(extStore + ""/5mbtest/""+filename+"".aes"");

    FileOutputStream fos = new FileOutputStream(extStore + ""/5mbtest/""+""decrypted""+filename,false);
    SecretKeySpec sks = new SecretKeySpec(""MyDifficultPassw"".getBytes(),
            ""AES"");
    // Create cipher
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    startTime = System.currentTimeMillis();
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while ((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }

    stopTime = System.currentTimeMillis();

    Log.i(""Decryption Ended"",extStore + ""/5mbtest/""+""decrypted""+filename);
    Log.i(""Time Elapsed"", ((stopTime - startTime)/1000.0)+"""");

    fos.flush();
    fos.close();
    cis.close();
}
</code></pre>
"	NULL	0	NULL	47:33.3	7	34:22.0	57:15.7	NULL	3648324	3648324	0	1	5	<android><encryption><cryptography><aes><bouncycastle>	Android AES-128 encryption/decryption of file is very slow. How can I increase the speed	4485	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28023897	28024081	1	"<p>I'm new to Encryptions. I'm finding codes about encryption and i'm trying to know how it is working because it's interesting and I like to code it in the future. </p>

<p>Then I found this code:</p>

<pre><code>  System.out.print(""Enter text: "");
      String text = dataIn.readLine();
      String key = ""Bar12345Bar12345""; // 128 bit key

       // Create key and cipher
     Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
     Cipher cipher = Cipher.getInstance(""AES"");
 ...
</code></pre>

<p>Before I start working on it. I don't know how <code>String = Bar12345Bar12345</code> works. It says that it is <code>128 bit key</code>. Is the <code>String</code> constant? Is it okay to change it? </p>
"	NULL	6	NULL	44:08.4	2	22:28.6	22:28.6	NULL	1852723	4291832	0	1	0	<java><encryption><aes>	AES String Encryption/Decryption	599	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28540565	46462037	1	"<p>I create an encryption cipher as follows (in Scala, using bouncy-castle)</p>

<pre><code>  def encryptCipher(secret:SecretKeySpec, iv:IvParameterSpec):Cipher = {
    val e = Cipher.getInstance(""AES/GCM/NoPadding"")
    e.init(Cipher.ENCRYPT_MODE, secret, iv)
  }
</code></pre>

<p>You see that the slow operation of generating the key spec is already handled.  However calling init itself for each message is too slow.<br>
I'm currently processing 50K messages, and calling the init method adds nearly 4 seconds.</p>

<p>Is there a way to re-initialise with a new IV which is not so time intensive?</p>
"	NULL	4	NULL	36:35.6	2	29:21.6	NULL	NULL	0	591032	0	1	1	<java><performance><scala><encryption>	"Java crypto, reset the IV possible for performance improvement?"	472	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28622438	28624160	1	"<p>I found a guide for implementing AES encryption/decryption in Java and tried to understand each line as I put it into my own solution.  However, I don't fully understand it and am having issues as a result.  The end goal is to have passphrase based encryption/decryption. I've read other articles/stackoverflow posts about this, but most do not provide enough explanation (I am very new to crypto in Java)</p>

<p>My main issues right now are that even when I set <code>byte[] saltBytes = ""Hello"".getBytes();</code> 
I still get a different Base64 result in the end (<code>char[] password</code> is random each time, but I read that it is safer to leave passwords in <code>char[]</code> form.  My other problem is that when the program gets to <code>decrypt()</code>, I get a NullPointerException at
 <code>byte[] saltBytes = salt.getBytes(""UTF-8"");</code></p>

<p>Thank you in advance for any help/advice you can give me.</p>

<p>The code in question:</p>

<pre><code>import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    public static void main(String []args) throws Exception {

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + message.toString());
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {

        salt = getSalt();
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        SecretKey secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(plaintext.toString().getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        byte[] saltBytes = salt.getBytes(""UTF-8"");
        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(encryptedText.toString());

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(encryptedText, saltBytes, iterations, keySize);
        SecretKey secretkey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretkey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return decryptedTextBytes.toString();

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return salt.toString();
    }
}
</code></pre>
"	NULL	0	NULL	48:48.5	8	23:38.1	54:01.0	NULL	4586779	4586779	0	1	9	<java><encryption><passwords><aes><password-encryption>	AES-256 Password Based Encryption/Decryption in Java	48035	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28627398	28627577	1	"<p>I want to learn the basics of AES encryption so I started to make a very simple Java program. The program loads a text file in to a <code>String</code> and asks for a key from the user. The program then uses AES to encrypt the text creating a new text file with the encrypted text. The program prints the Initialization Vector (IV) to the user.</p>

<p>The program also has the decryption function. The user specifies the encrypted text file along with the Initialization Vector and the key to decrypt it back to the original text in a new text file. </p>

<p>However I think I'm doing something wrong. Is it normal procedure in AES encryption that the user needs to have both key and IV to decrypt the file? I have browsed through the internet and almost in every example, the encrypted data can be decrypted by the user specifying only the key but in my case the user needs to have both the key and the IV. The program is working fine but I think it isn't efficient.</p>

<p>So should I use a constant, known IV which is used in all the encryptions and decryptions or what? Also some tutorials are using ""salt"", what is it and should I use it?</p>

<p>Here are my encrypt and decrypt methods:</p>

<pre><code>public String encrypt(String stringToEncrypt, String userKey)
        throws NoSuchAlgorithmException, NoSuchPaddingException,
        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    // User gives string key which is formatted to 16 byte and to a secret
    // key
    byte[] key = userKey.getBytes();
    MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
    key = sha.digest(key);
    key = Arrays.copyOf(key, 16);
    SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");

    // Cipher initialization
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);

    // Encryption and encoding
    String encryptedData = new BASE64Encoder().encode(cipher
            .doFinal(stringToEncrypt.getBytes()));

    // IV is printed to user
    System.out.println(""\nENCRYPTION IV: \n""
            + new BASE64Encoder().encode(cipher.getIV()) + ""\n"");

    // Function returns encrypted string which can be writed to text file
    return encryptedData;

}

public String decrypt(String stringToDecrypt, String userKey, String userIv)
        throws NoSuchAlgorithmException, IOException,
        NoSuchPaddingException, InvalidKeyException,
        InvalidAlgorithmParameterException, IllegalBlockSizeException,
        BadPaddingException {

    // User gives the same string key which was used for encryption
    byte[] key = userKey.getBytes();
    MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
    key = sha.digest(key);
    key = Arrays.copyOf(key, 16);
    SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");

    // Decode string iv to byte
    byte[] iv = new BASE64Decoder().decodeBuffer(userIv);

    // Cipher initialization
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));

    // Decryption and decoding
    String decryptedData = new String(cipher.doFinal(new BASE64Decoder()
            .decodeBuffer(stringToDecrypt)));

    // Function returns decrypted string which can be writed to text file
    return decryptedData;

}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>I updated my code now to use ""PBKDF2WithHmacSHA256"" algorithm with salt and etc. I also combined the Initialization Vector (IV) byte array to the cipher text byte array as prefix so I can split them in decrypt method and get the IV there (That's working fine).</p>

<p>However there's now an issue with the key, because I'm generating new encrypted key also in decryption method which of course is a wrong key for encrypted data. I want to be able to close the program so I can't store the key as a class variable. It's very hard to explain the issue but I hope you understand the problem...</p>

<pre><code>public static byte[] getEncryptedPassword(String password, byte[] salt,
        int iterations, int derivedKeyLength)
        throws NoSuchAlgorithmException, InvalidKeySpecException {

    KeySpec mKeySpec = new PBEKeySpec(password.toCharArray(), salt,
            iterations, derivedKeyLength);

    SecretKeyFactory mSecretKeyFactory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA256"");

    return mSecretKeyFactory.generateSecret(mKeySpec).getEncoded();

}

public String encrypt(String dataToEncrypt, String key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException {

    byte[] mEncryptedPassword = getEncryptedPassword(key, generateSalt(),
            16384, 128);

    SecretKeySpec mSecretKeySpec = new SecretKeySpec(mEncryptedPassword, ""AES"");


    Cipher mCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec);

    byte[] ivBytes = mCipher.getIV();
    byte[] encryptedTextBytes = mCipher.doFinal(dataToEncrypt.getBytes());

    byte[] combined = new byte[ivBytes.length+encryptedTextBytes.length];       
    System.arraycopy(ivBytes, 0, combined, 0, ivBytes.length);
    System.arraycopy(encryptedTextBytes, 0, combined, ivBytes.length, encryptedTextBytes.length);

    return Base64.getEncoder().encodeToString(combined);

}

public String decrypt(String dataToDecrypt, String key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException {


    byte[] encryptedCombinedBytes = Base64.getDecoder().decode(dataToDecrypt);
    byte[] mEncryptedPassword = getEncryptedPassword(key, generateSalt(),
            16384, 128);

    byte[] ivbytes = Arrays.copyOfRange(encryptedCombinedBytes,0,16);

    SecretKeySpec mSecretKeySpec = new SecretKeySpec(mEncryptedPassword, ""AES"");

    Cipher mCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    mCipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, new IvParameterSpec(ivbytes));    

    byte[] encryptedTextBytes = Arrays.copyOfRange(encryptedCombinedBytes, 16, encryptedCombinedBytes.length);

    System.out.println(encryptedTextBytes.length);
    byte[] decryptedTextBytes = mCipher.doFinal(encryptedTextBytes);



    return Base64.getEncoder().encodeToString(decryptedTextBytes);

}

public byte[] generateSalt() {
    SecureRandom random = new SecureRandom();
    byte saltBytes[] = new byte[16];
    random.nextBytes(saltBytes);
    return saltBytes;
}}
</code></pre>

<p>I hope somebody knows how to make this better. Thanks!</p>
"	NULL	11	NULL	01:35.1	4	01:10.2	01:10.2	NULL	1790632	4587542	0	1	7	<java><encryption><cryptography><aes>	Java AES encryption/decryption procedure and usage of Initialization Vector	10911	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
28957479	28958878	1	"<p>I'm very new in Java and trying to implement Java encryption/decryption for a text file. Here I can see some of the starting characters in line 1 is getting truncated while decrypting a encrypted file.</p>

<p>Below is my code. Please suggest if I'm missing anything.</p>

<pre><code>package com.myprotection;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.UnsupportedEncodingException;
import java.security.AlgorithmParameters;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class Crypto
{
    private String mPassword = null;
    byte [] mInitVec = null;
    byte [] mSalt = null;
    Cipher mEcipher = null;
    Cipher mDecipher = null;
    private final int KEYLEN_BITS = 256;
    private final int ITERATIONS = 65536;
    private final int MAX_FILE_BUF = 1024;


    public Crypto (String password, String hint) throws Exception
    {
        mPassword = password;
        mSalt = getSaltedByteFromString( hint );
    }


    public void WriteEncryptedFile (String input, String output) throws Exception {

        FileInputStream fin = new FileInputStream (new File(input));
        FileOutputStream fout = new FileOutputStream (new File(output));
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        //Initialize Encryption Vector
        initializeInitVec();

        while ((nread = fin.read (inbuf)) &gt; 0 )
        {

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            // and results in full blocks of MAX_FILE_BUF being written. 
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i &lt; nread; i++)
                trimbuf[i] = inbuf[i];

            // encrypt the buffer using the cipher obtained previosly
            byte [] tmp = mEcipher.update (trimbuf);

            // I don't think this should happen, but just in case..
            if (tmp != null)
                fout.write (tmp);
        }

        // finalize the encryption since we've done it in blocks of MAX_FILE_BUF
        byte [] finalbuf = mEcipher.doFinal ();
        if (finalbuf != null)
            fout.write (finalbuf);

        fout.flush();
        fin.close();
        fout.close();
        fout.close ();
    }


    public void ReadEncryptedFile (String input, String output) throws Exception {

        FileInputStream fin = new FileInputStream (new File(input));
        FileOutputStream fout = new FileOutputStream (new File(output));
        CipherInputStream cin;
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        //Initializing decrypting 
        setupDecrypt();

        // creating a decoding stream from the FileInputStream above using the cipher created from setupDecrypt()
        cin = new CipherInputStream (fin, mDecipher);

        while ((nread = cin.read (inbuf)) &gt; 0 )
        {

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i &lt; nread; i++)
                trimbuf[i] = inbuf[i];

            // write out the size-adjusted buffer
            fout.write (trimbuf);
        }

        fout.flush();
        cin.close();
        fin.close ();       
        fout.close();
    }

    private void setupDecrypt () throws Exception {

        SecretKeyFactory factory = null;
        SecretKey tmp = null;
        SecretKey secret = null;

        //Get initialized the vector
        initializeInitVec();

        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);
        tmp = factory.generateSecret(spec);
        secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        /* Decrypt the message, given derived key and initialization vector. */
        mDecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec));
    }

    private void initializeInitVec() throws Exception {

        SecretKeyFactory factory = null;
        SecretKey tmp = null;

        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec (mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);
        tmp = factory.generateSecret (spec);
        SecretKey secret = new SecretKeySpec (tmp.getEncoded(), ""AES"");

        //Create the Encryption cipher object and store as a member variable
        mEcipher = Cipher.getInstance (""AES/CBC/PKCS5Padding"");
        mEcipher.init (Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = mEcipher.getParameters ();

        // get the initialization vectory and store as member var 
        mInitVec = params.getParameterSpec (IvParameterSpec.class).getIV();
    }

    private byte[] getSaltedByteFromString( String hintString ) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(hintString.getBytes(""UTF-8""));
        return md.digest();
    }
}
</code></pre>

<p>Testing of the above code:</p>

<pre><code>public class TestCrypto {
    public static void main(String[] args) throws Exception {

        String pwd = ""Tipu"";
        String hint = ""My Dog Name"";

        Crypto cpo = new Crypto(pwd, hint);
        cpo.WriteEncryptedFile(""C:\\Users\\roul\\Desktop\\TestEncryption.txt"", ""C:\\Users\\roul\\Desktop\\en-TestEncryption.txt"");
        cpo.ReadEncryptedFile(""C:\\Users\\roul\\Desktop\\en-TestEncryption.txt"", ""C:\\Users\\roul\\Desktop\\de-TestEncryption.txt"");


    }
}
</code></pre>

<p>Test Case File Content <em>TestEncryption.txt</em>:</p>

<blockquote>
  <p>My Encryption testing<br>
  This is my test encryption.</p>
</blockquote>

<p>encrypted <strong>TestEncryption.txt</strong>:</p>

<blockquote>
  <p>fè""Ç2¨1.ñ|#¼Ê¯Ã&amp;ýnfK[ùn§Ù @ÛPzÎ¯sö®õýóK8ÄÜ¨`¹*¢ÙFÃ</p>
</blockquote>

<p>decrypted <em>TestEncryption.txt</em>:</p>

<blockquote>
  <p>³XgÜOÂN¶×­Nsting<br>
  This is my test encryption.</p>
</blockquote>
"	NULL	3	NULL	32:33.1	3	01:32.4	01:32.4	NULL	1816580	596495	0	1	0	<java><encryption>	Initial few characters are getting truncated while decrypting	269	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29074406	29074670	1	"<p>I have a Java code for encryption which looks like this</p>

<pre><code>byte[] encrypt(byte[] clearData) {
   byte[] passwordKey = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,0x0f};
   byte[] rawSecretKey = new byte[]{0x34, (byte) 0xA4, 0x16, 0x09, 0x77, (byte) 0x85, (byte) 0xB4, 0x31,
                                                0x75, 0x12, (byte) 0x92, (byte) 0xDD, (byte) 0xCA, 0x15, (byte) 0xAB, (byte) 0xBA};
   secretKey = new SecretKeySpec(passwordKey, ""AES"");
   ivParameterSpec = new IvParameterSpec(rawSecretKey);
   Cipher aesCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
   aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);

   byte[] encryptedData;
   encryptedData = aesCipher.doFinal(clearData);

   return encryptedData;
}
</code></pre>

<p>I have to port this code to JNI. I have build openssl and made JNI wrapper function which looks like this:</p>

<pre><code>JNIEXPORT jbyteArray JNICALL Java_axon_voiceassistant_utils_JNIUtils_getcr(JNIEnv *env, jclass cls, jbyteArray srcData)
    {
        int srcLen=env-&gt;GetArrayLength(srcData);
        unsigned char* indata = new unsigned char[srcLen];
        env-&gt;GetByteArrayRegion (srcData, 0, srcLen, reinterpret_cast&lt;jbyte*&gt;(indata));

        const unsigned char ukey[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,0x0f};
        unsigned char iv [] = {0x34, 0xA4, 0x16, 0x09, 0x77,0x85, 0xB4, 0x31,
                               0x75, 0x12, 0x92,0xDD, 0xCA, 0x15, 0xAB, 0xBA};

        const size_t encs_length = ((srcLen + AES_BLOCK_SIZE) / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
        unsigned char enc_data[encs_length];
        memset(enc_data, 0, sizeof(enc_data));


        AES_KEY key;
        memset(&amp;key, 0, sizeof(AES_KEY));

        AES_set_encrypt_key(ukey, 128, &amp;key);
        AES_cbc_encrypt(indata, enc_data, srcLen, &amp;key, iv, AES_ENCRYPT);

        jbyteArray bArray = env-&gt;NewByteArray(encs_length);
        jboolean isCopy;
        void *enc_copy = env-&gt;GetPrimitiveArrayCritical((jarray)bArray, &amp;isCopy);
        memcpy(enc_copy, enc_data, encs_length);

        env-&gt;ReleasePrimitiveArrayCritical( bArray, enc_copy, 0);

        return bArray;

    }
</code></pre>

<p>But I don't get same results with the JNI version as with the Java version. What could be the problem?</p>
"	NULL	7	NULL	22:31.2	3	10:44.3	24:03.7	NULL	1816580	1520250	0	1	0	<java><android><encryption><android-ndk><openssl>	AES/CBC/PKCS5Padding different results in JAVA and JNI	770	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29239854	29258111	1	"<p>I'm trying to encrypt a file using AES key Wrapped in a RSA key pair.. </p>

<p>I'm trying to put the wrapped key at beginning of the file, and then for decrypting I take the first 256 bytes of the wrapped key for taking it.</p>

<p>The problem is I'm encrypting the file in blocks of 1024 bytes. So, for decrypting, I need to take the last bytes of the file (not the first 256 because they are the key)</p>

<p>So in <a href=""http://s1.postimg.org/o7bhp6127/Blank_Flowchart_New_Page.jpg"" rel=""nofollow"">this image</a> you can see the proces</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;a href='http://postimg.org/image/htmelww63/' target='_blank'&gt;&lt;img src='http://s1.postimg.org/htmelww63/Blank_Flowchart_New_Page.jpg' border='0' alt=""Blank Flowchart New Page"" /&gt;&lt;/a&gt;</code></pre>
</div>
</div>
</p>

<p>So the problem is when I need to decrypt the file except the first 256 bytes. I can't find a working algorithm...</p>

<p>Here the code for encrypting:  </p>

<pre><code>public static void fileEncripWrapped(File in, File out, PublicKey pub, byte [] key) {  

    try {
        SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");

        //Encrypting wrapped key      
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.WRAP_MODE, pub);
        byte[] encKey = cipher.wrap(keySpec);

        FileOutputStream osAppend  = new FileOutputStream(out);

        osAppend.write(encKey);
        osAppend.close();


        // Crypting the file 
         cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);

        FileInputStream is = new FileInputStream(in);
        CipherOutputStream os = new CipherOutputStream(new FileOutputStream(out, true), cipher);

        copy(is, os);

        is.close();
        os.close();

    } catch (Exception ex) {
        System.err.println(""Ha succeït un error xifrant: "" + ex);
    }
}
</code></pre>

<p>This is the code I use for copy the inputStream to the outputStream in blocks of 1024 Bytes.</p>

<pre><code>private static void copy(InputStream is, OutputStream os) throws IOException {
    int i;
    byte[] b = new byte[1024];
    while((i=is.read(b))!=-1) {
       os.write(b, 0, i);
    }
}
</code></pre>

<p>Now the problem is for uncrypting: </p>

<pre><code>public static void fileUncryptWrapped(File in, File out, PrivateKey priv) { 

   try {

       Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
       cipher.init(Cipher.UNWRAP_MODE, priv);

       //First we must to take the wrapped key in the first 256 bytes of the file: 
       byte[] bufferKey = new byte[256];
       InputStream is = new FileInputStream(in);
       if (is.read(bufferKey) != bufferKey.length) { 

       }
       is.close();

       Key ky = cipher.unwrap(bufferKey, ""AES"", Cipher.SECRET_KEY);¡

       // Now we must to uncrypt the rest of the file
       cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
       cipher.init(Cipher.DECRYPT_MODE, ky);

       CipherInputStream ix = new CipherInputStream(new FileInputStream(in), cipher);
       FileOutputStream os = new FileOutputStream(out);

       copy(ix, os);

       ix.close();
       os.close();

   } catch (Exception ex) {
       System.err.println(""Ha succeït un error xifrant: "" + ex);
   }
}
</code></pre>

<p>What modifications do I need to do in the copy function for taking the bytes after the first 256? I tried something like that but it doesn't work...</p>

<pre><code>// Get the size of the file
long streamLength = inputStream.available();

if (streamLength &gt; Integer.MAX_VALUE) {
    // File is too large
}

// Create the byte array to hold the data
byte[] bytes = new byte[1024];

// Read in the bytes
int block_size = 1024;
int offset = 256;
int numRead = 0;
while (offset &lt; (int) streamLength &amp;&amp; (numRead = inputStream.read(bytes, offset,  block_size)) &gt;= 0) {
    offset += numRead;
    outputStream.write(bytes, 0 , block_size );
 }
</code></pre>
"	NULL	0	NULL	06:53.4	4	12:57.6	38:59.4	NULL	1803692	4708664	0	1	1	<java><encryption><aes><rsa>	Encrypt a file appending wrapped key in unique file	720	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29354133	29354222	NULL	"<p>I am working on a <strong>text encryption and decryption</strong> project (following Struts 2)</p>

<p>Whenever I enter the password and the plain text I get a Invalid AES Key Length error.</p>

<p><strong>The Service Class</strong></p>

<pre><code>package com.anoncrypt.services;

import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class SymAES
{
    private static final String ALGORITHM = ""AES"";
    private static byte[] keyValue= new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };

     public  String encode(String valueToEnc) throws Exception {
        Key key = new SecretKeySpec(keyValue, ALGORITHM);
        Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encValue = c.doFinal(valueToEnc.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encValue);
        return encryptedValue;
    }

    public  String decode(String encryptedValue) throws Exception {
        Key key = new SecretKeySpec(keyValue, ALGORITHM);
        Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }

    public  void start(String passcode)throws Exception
    {
        keyValue = passcode.getBytes();
    }
}
</code></pre>

<hr>

<p>And this is the error </p>

<pre><code>java.security.InvalidKeyException: Invalid AES key length: 6 bytes
    com.sun.crypto.provider.AESCrypt.init(AESCrypt.java:87)
    com.sun.crypto.provider.ElectronicCodeBook.init(ElectronicCodeBook.java:93)
    com.sun.crypto.provider.CipherCore.init(CipherCore.java:582)
    com.sun.crypto.provider.CipherCore.init(CipherCore.java:458)
    com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:307)
    javax.crypto.Cipher.implInit(Cipher.java:797)
    javax.crypto.Cipher.chooseProvider(Cipher.java:859)
    javax.crypto.Cipher.init(Cipher.java:1229)
    javax.crypto.Cipher.init(Cipher.java:1166)
    com.anoncrypt.services.SymAES.encode(SymAES.java:35)
    com.anoncrypt.actions.SymEncrypt.execute(SymEncrypt.java:24)
</code></pre>
"	NULL	NULL	NULL	02:42.2	NULL	NULL	NULL	NULL	NULL	3560582	0	1	52	<java><encryption><aes>	How to fix Invalid AES key length?	179230	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29575024	29576774	3	"<p>I was wondering, is there any difference, if I init AES cipher, with and without IvParameterSpec?</p>

<h2>With IvParameterSpec</h2>

<pre><code>SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16]));
</code></pre>

<h2>Without IvParameterSpec</h2>

<pre><code>SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
</code></pre>

<p>I tested with some sample test data, their encryption and decryption result yield the same.</p>

<p>However, since I'm not the security expert, I don't want to miss out anything, and create a potential security loop hole. I was wondering, which is the correct way?</p>
"	NULL	1	NULL	50:17.9	12	50:26.7	44:00.7	NULL	1816580	72437	0	1	18	<java><android><security><encryption><aes>	"Is there any difference, if I init AES cipher, with and without IvParameterSpec"	21026	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29607500	0	2	"<p>I am trying to encrypt and decrypt my file in which all my passwords are stored using AES.</p>

<p>The algorithm works fine on encryption part. But while decryption it throws the error</p>

<pre><code>Message:Given final block not properly padded
javax.crypto.BadPaddingException: Given final block not properly padded
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:966)
        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
        at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
        at javax.crypto.Cipher.doFinal(Cipher.java:2121)
        at SearchDoc.dec_file(SearchDoc.java:327)
        at SearchDoc.access$100(SearchDoc.java:52)
        at SearchDoc$2$1.actionPerformed(SearchDoc.java:227)
        at javax.swing.AbstractButton.fireActionPerformed(Unknown Source)
        at javax.swing.AbstractButton$Handler.actionPerformed(Unknown Source)
        at javax.swing.DefaultButtonModel.fireActionPerformed(Unknown Source)
        at javax.swing.DefaultButtonModel.setPressed(Unknown Source)
        at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(Unknown Source)
        at java.awt.Component.processMouseEvent(Unknown Source)
        at javax.swing.JComponent.processMouseEvent(Unknown Source)
        at java.awt.Component.processEvent(Unknown Source)
        at java.awt.Container.processEvent(Unknown Source)
        at java.awt.Component.dispatchEventImpl(Unknown Source)
        at java.awt.Container.dispatchEventImpl(Unknown Source)
        at java.awt.Component.dispatchEvent(Unknown Source)
        at java.awt.LightweightDispatcher.retargetMouseEvent(Unknown Source)
        at java.awt.LightweightDispatcher.processMouseEvent(Unknown Source)
        at java.awt.LightweightDispatcher.dispatchEvent(Unknown Source)
        at java.awt.Container.dispatchEventImpl(Unknown Source)
        at java.awt.Window.dispatchEventImpl(Unknown Source)
        at java.awt.Component.dispatchEvent(Unknown Source)
        at java.awt.EventQueue.dispatchEventImpl(Unknown Source)
        at java.awt.EventQueue.access$400(Unknown Source)
        at java.awt.EventQueue$3.run(Unknown Source)
        at java.awt.EventQueue$3.run(Unknown Source)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.security.ProtectionDomain$1.doIntersectionPrivilege(Unknown Source)
        at java.security.ProtectionDomain$1.doIntersectionPrivilege(Unknown Source)
        at java.awt.EventQueue$4.run(Unknown Source)
        at java.awt.EventQueue$4.run(Unknown Source)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.security.ProtectionDomain$1.doIntersectionPrivilege(Unknown Source)
        at java.awt.EventQueue.dispatchEvent(Unknown Source)
        at java.awt.EventDispatchThread.pumpOneEventForFilters(Unknown Source)
        at java.awt.EventDispatchThread.pumpEventsForFilter(Unknown Source)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(Unknown Source)
        at java.awt.EventDispatchThread.pumpEvents(Unknown Source)
        at java.awt.EventDispatchThread.pumpEvents(Unknown Source)
        at java.awt.EventDispatchThread.run(Unknown Source)
</code></pre>

<p>What is the problem here?</p>

<p>code:</p>

<pre><code>//Starting decryption
try{
    byte[] key = c_key.getBytes(""ISO-8859-1"");
    key = Arrays.copyOf(key, 16); // use only first 128 bit
    //System.out.println(Arrays.toString(key));
    SecretKeySpec SecKey = new SecretKeySpec(key, ""AES"");
    Cipher AesCipher = Cipher.getInstance(""AES"");
    AesCipher.init(Cipher.DECRYPT_MODE, SecKey);

    BufferedReader breader = new BufferedReader(new FileReader(""download/enc_""+file));
    String line;
    boolean bool = false;
    File f = new File(file);
    bool = f.createNewFile();
    if(bool==false){
        f.delete();
        bool = f.createNewFile();
    }
    PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file, true)));
    while ((line = breader.readLine()) != null){
         byte[] cipher=null;
         byte[] plain=null;

         cipher=line.getBytes(""ISO-8859-1"");
         plain=AesCipher.doFinal(cipher);

         out.println(new String(plain,""ISO-8859-1""));
    }
    out.close();
    return 1;
}
catch(Exception dcf){
    System.out.println(""Message:""+dcf.getMessage());
    dcf.printStackTrace();
    return 0;
}
</code></pre>

<p>NEW AES CODE:</p>

<pre><code>import java.security.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.spec.InvalidKeySpecException;
import javax.crypto.*;
import sun.misc.*;

public class AESencrp {

     private static final String ALGO = ""AES"";
    private static final byte[] keyValue = 
        new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't',
'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };

public static String encrypt(String Data) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encVal = c.doFinal(Data.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encVal);
        return encryptedValue;
    }

    public static String decrypt(String encryptedData) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }
    private static Key generateKey() throws Exception {
        Key key = new SecretKeySpec(keyValue, ALGO);
        return key;
}

}
</code></pre>
"	NULL	0	NULL	12:32.7	3	00:22.8	00:22.8	NULL	608639	2820823	0	1	0	<java><encryption><aes><badpaddingexception>	Padding Exception: Given final block not properly padded	33626	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
29671427	0	3	"<p>I have an android project in which am getting an Triple DES encrypted piece of text from my web services.  I need to Triple DES decrypt.</p>

<p>However, I am getting invalid key exceptions.  My key is converted to HEX format and I got an error: <code>W/System.err? java.security.InvalidKeyException: DES key too long - should be 8 bytes</code> I found <a href=""https://community.oracle.com/thread/1528631"" rel=""nofollow"">here</a> a forum explaining that hex may cause issue </p>

<p><em>""DES keys are 56 bits normally packaged in 8 bytes so the chances are that the 16 bytes/characters they have given you are the hex encoded bytes of the key. You can get a hex decoder""</em></p>

<p>So I converted my hex string to a byte array using</p>

<pre><code> private static byte[] hexStringtoByteArray(String hex){
        int len = hex.length();

        byte [] data = new byte[len/2];
        for(int i=0; i&lt;len;i+=2){
            data[i/2] = (byte)((Character.digit(hex.charAt(i), 16)&lt;&lt;4) + Character.digit(hex.charAt(i+1),16));
        }
        return data;
    }
</code></pre>

<p>and passed that in to the cipher and I get an error:</p>

<pre><code>W/System.err? java.security.InvalidKeyException
W/System.err? at javax.crypto.spec.DESedeKeySpec.
</code></pre>

<p>here is my decrypt method.  I would appreciate if someone could shine some light on where I might be going wrong.</p>

<pre><code> public String DesDecryptPin(String pin, String encryptKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {

    String UNICODE_FORMAT = ""UTF8"";
    String decryptedPinText = null;

    byte[] hexConvert = hexStringtoByteArray(encryptKey);

    SecretKey desKey = null;
    KeySpec desKeySpec = new DESedeKeySpec(hexConvert); // Exception HERE
    Cipher desCipher;
    SecretKeyFactory skf = SecretKeyFactory.getInstance(""DESede"");
    desCipher = Cipher.getInstance(""DES/ECB/NoPadding"");
    try {
        desKey = skf.generateSecret(desKeySpec);
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    }

    desCipher.init(Cipher.DECRYPT_MODE, desKey);
    byte[] decryptPin = desCipher.doFinal(pin.getBytes());
    decryptedPinText = new String(decryptPin, ""UTF-8"");

    return decryptedPinText;
}
</code></pre>

<p>My key is C9AF269DF8A78A06D1216BFFF8F0536A.</p>

<p><em>I have checked with the client and the key is correct, so the same key is being used for encryption.</em></p>

<p><strong><em>Encryption Code</em></strong></p>

<pre><code> public string TripleDESEncrypt(string strClearText, string strKey)
    {
        byte[] bytClearText;
        byte[] bytClearTextChunk = new byte[8];
        byte[] bytEncryptedChunk = new byte[8];
        int BytesCount = 0;
        int nArrayPosition = 0;
        string strEncryptedChar;
        string strEncryptedText = """";

        ArrayList Input = new ArrayList();
        ArrayList Output = new ArrayList();

        TripleDESCryptoServiceProvider tdes = (TripleDESCryptoServiceProvider)TripleDESCryptoServiceProvider.Create();

        tdes.Key = HexToByteArray(strKey);
        tdes.Mode = CipherMode.ECB;

        ICryptoTransform tdesEncrypt = tdes.CreateEncryptor();

        bytClearText = ASCIIEncoding.ASCII.GetBytes(strClearText);
        BytesCount = bytClearText.Length;

        for (int i = 0; i &lt; BytesCount; i++)
        {
            if (nArrayPosition == 8)
            {
                Input.Add(bytClearTextChunk);
                bytClearTextChunk = new byte[8];
                nArrayPosition = 0;
            }
            bytClearTextChunk[nArrayPosition] = bytClearText[i];
            nArrayPosition++;
        }

        if (nArrayPosition != 0)
            Input.Add(bytClearTextChunk);


        foreach (byte[] Cbyte in Input)
        {
            tdesEncrypt.TransformBlock(Cbyte, 0, 8, bytEncryptedChunk, 0);
            Output.Add(bytEncryptedChunk);
            bytEncryptedChunk = null;
            bytEncryptedChunk = new byte[8];
        }


        foreach (byte[] Cbyte in Output)
        {
            foreach (byte BByte in Cbyte)
            {
                strEncryptedChar = BByte.ToString(""X"");
                strEncryptedChar = strEncryptedChar.PadLeft(2, Convert.ToChar(""0""));
                strEncryptedText += strEncryptedChar;
            }
        }

        return strEncryptedText;
    }
</code></pre>

<p>Here is an example of the decrypted text with 14 chars: 12345678901234</p>
"	NULL	4	NULL	03:21.8	4	34:06.2	30:53.6	NULL	1250031	1250031	0	1	1	<java><android><encryption><tripledes>	Triple DES decryption invalid key with 16 bytes	13311	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
30090679	0	1	"<p>I'm working with java security and openssl to encrypt a specific string with aes-ecb-256, but the result is not identical. 
Is there any lib for java that implements <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">Rijndael's key schedule</a> ?</p>

<p>C code:  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/aes.h&gt;

using namespace std;

int main(int argc, char** argv) {
    AES_KEY aes;
    char* key = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"";
    unsigned char* input_string;
    unsigned char* encrypt_string;
    unsigned char* decrypt_string;
    unsigned int len;        // encrypt length (in multiple of AES_BLOCK_SIZE)
    unsigned int i;

    // check usage
    if (argc != 2) {
        fprintf(stderr, ""%s &lt;plain text&gt;\n"", argv[0]);
        exit(-1);
    }

    // set the encryption length
    len = 0;
    if ((strlen(argv[1]) + 1) % AES_BLOCK_SIZE == 0) {
        len = strlen(argv[1]) + 1;
    } else {
        len = ((strlen(argv[1]) + 1) / AES_BLOCK_SIZE + 1) * AES_BLOCK_SIZE;
    }

    // set the input string
    input_string = (unsigned char*)calloc(len, sizeof(unsigned char));
    if (input_string == NULL) {
        fprintf(stderr, ""Unable to allocate memory for input_string\n"");
        exit(-1);
    }
    strncpy((char*)input_string, argv[1], strlen(argv[1]));

    if (AES_set_encrypt_key((unsigned char*)key, 256, &amp;aes) &lt; 0) {
        fprintf(stderr, ""Unable to set encryption key in AES\n"");
        exit(-1);
    }

    // alloc encrypt_string
    encrypt_string = (unsigned char*)calloc(len, sizeof(unsigned char));
    if (encrypt_string == NULL) {
        fprintf(stderr, ""Unable to allocate memory for encrypt_string\n"");
        exit(-1);
    }

    // encrypt
    AES_ecb_encrypt(input_string, encrypt_string, &amp;aes, AES_ENCRYPT);


    // print
    printf(""input_string = %s\n"", input_string);
    printf(""encrypted string = "");
    for (i=0; i&lt;len; ++i) {
        printf(""%02X "", encrypt_string[i]);
    }
    printf(""\n"");
    //printf(""decrypted string = %s\n"", decrypt_string);

    return 0;
}
</code></pre>

<p>Java code: </p>

<pre><code>public class testMain {
    private static byte[] key = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"".getBytes();
    private static byte[] plaintext = ""fjaiejrfoi"".getBytes();
    private static Cipher cipher;
    private static byte[] result;

    public static void main(String[] args) {
        try {
            cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
        SecretKeySpec secretKey = null;
        try {
            secretKey = makeKey();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        try {
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        }
        try {
            result = cipher.doFinal(plaintext);
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }
        StringBuffer sb = new StringBuffer();
        for(byte b : result) {
            sb.append(Integer.toHexString((int)(b&amp;0xff)));
        }
        System.out.println(""result is "" + sb.toString());

    }

    private static SecretKeySpec makeKey() throws NoSuchAlgorithmException{
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(256, new SecureRandom(key));
        SecretKey secretKey = kgen.generateKey();
        SecretKeySpec keySpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
        return keySpec;
    }
}
</code></pre>

<p>the plain text is <strong>fjaiejrfoi</strong>. result of the two pieces of code are different.</p>
"	NULL	5	NULL	59:57.9	2	26:21.3	37:58.1	NULL	608639	487832	0	1	0	<java><openssl><aes>	AES with Rijndael's key schedule	1029	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
30098239	30099780	2	"<p>I have an issue with the decryption in the following code. I have a encrypted string being sent to setData(). I am trying to decrypt the encrypted string(data). The error I keep getting is </p>

<blockquote>
  <p>javax.crypto.IllegalBlockSizeException: last block incomplete in decryption</p>
</blockquote>

<pre><code>byte[] data;
String key = ""tkg96827pco74510"";

byte[] encryptedOut;
String decryptedOut;

Key aesKey;
Cipher cipher;

public void setData(String dataIn){
    this.data = dataIn.getBytes();
    try {
        aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
        cipher = Cipher.getInstance(""AES"");

    }catch(Exception e){
        System.out.println(""SET DATA ERROR - "" + e);
    }
}
public void encrypt() {
    try{
        cipher.init(Cipher.ENCRYPT_MODE, aesKey);
        encryptedOut = cipher.doFinal(data);
    }catch(Exception e){
        System.out.println(e);
    }
}

public void decrypt(){
    try {
        cipher.init(Cipher.DECRYPT_MODE, aesKey);
        decryptedOut = new String(cipher.doFinal(data));

    }catch(Exception e){
        System.out.println(""Decrypt Error: "" + e);
    }
}

public byte[] getEncrypted() {
   return encryptedOut;
}

public String getDecrypted(){
    return decryptedOut;
}
</code></pre>
"	NULL	2	NULL	20:42.8	3	09:40.1	NULL	NULL	0	1935433	0	1	0	<java><android><security><encryption>	Android Encryption and Decryption Error - javax.crypto.IllegalBlockSizeException: last block incomplete in decryption	3451	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
30688609	0	1	"<p>I have a concurrent encryption/decryption program in which multiple AES128 keys are randomly generated concurrently by invoking the following code (written in scala, the Java version should be fairly similar):</p>

<pre><code>  private def AESKeyGen: KeyGenerator = {
    val keyGen = KeyGenerator.getInstance(""AES"")
    keyGen.init(128)
    keyGen
  }

  def generateKey: SecretKey = this.synchronized {
    AESKeyGen.generateKey()
  }
</code></pre>

<p>each key is use to encrypt a fixed byte array, then decrypt it by using AESEncrypt and AESDecrypt functions:</p>

<pre><code>  def ivParameterSpec = this.synchronized{
    import com.schedule1.datapassport.view._

    new IvParameterSpec(""DataPassports==="")
  }

  private def getCipher = this.synchronized {
    Cipher.getInstance(""AES/CBC/PKCS5Padding"")
  }

  private def nextCipher(aesKey: Key): Cipher = this.synchronized{
    val cipher = getCipher
    cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivParameterSpec)
    cipher
  }

  private def nextDecipher(aesKey: Key): Cipher = this.synchronized{
    val cipher = getCipher
    cipher.init(Cipher.DECRYPT_MODE, aesKey, ivParameterSpec)
    cipher
  }

  def nullBytes = Array.fill[Byte](16)(0)

  def aesEncrypt(bytes: Array[Byte], key: Key): Array[Byte] = this.synchronized{
    val effectiveBytes = if (bytes == null) nullBytes
    else bytes
    nextCipher(key).doFinal(effectiveBytes)
  }

  def aesDecrypt(cipher: Array[Byte], key: Key): Array[Byte] = this.synchronized{
    val effectiveBytes = Utils.retry(3){
      nextDecipher(key).doFinal(cipher)
    }
    if (effectiveBytes.toList == nullBytes.toList) null
    else effectiveBytes
  }
</code></pre>

<p>The program runs smoothly on 1 core/thread, but when I increase concurrency gradually to 8. I have gradually higher chance of encountering the following error:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:966)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
    at javax.crypto.Cipher.doFinal(Cipher.java:2165)
...
</code></pre>

<p>Looks like at least one of the cryptocurrency component is not thread safe, despite I have marked most of them as synchronized as possible. How to fix this problem? (Or which library should I switch to to avoid it?)</p>
"	NULL	4	NULL	33:47.9	0	05:54.9	NULL	NULL	0	1732418	0	1	3	<java><scala><cryptography><aes><key-generator>	Is Java security module KeyGenerator thread safe? If not then how to fix it?	788	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
30852316	30853043	2	"<p>I try to encrypt some text (here it is named code) and decrypt it again.
For this i use a 4 digit Pin which is salted.</p>

<p>After this the text is encrypted, also again some Base64 decoding, so i can safely output the String again.</p>

<p>As i understand i have to base64.decode it and then again decrypt it.</p>

<p>But i don't get my encrypted text correctly decrypted back. Just some different text. ( something like this[B@3ceB...)</p>

<p>It is just a small project nothing serious. Also it is my second android app, so some good examples would be great.</p>

<pre><code>String pinstr = new String();
pinstr = ""5555"";
try {
    EncryptDecrypt encryptor = new EncryptDecrypt(pinstr);
    //encryptor.encrypt(code);
    String encrypted = new String();
    encrypted = encryptor.encrypt(code);

    String decrypted = new String();
    decrypted = encryptor.decrypt(encrypted);

    Toast.makeText(MainActivity.this, decrypted, Toast.LENGTH_SHORT).show();
} catch (InvalidKeyException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (NoSuchAlgorithmException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (UnsupportedEncodingException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (NoSuchPaddingException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (IllegalBlockSizeException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (BadPaddingException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
public class EncryptDecrypt {
    private SecretKeySpec skeySpec;
    private Cipher cipher, cipher2;


    EncryptDecrypt(String password) throws NoSuchAlgorithmException,
    UnsupportedEncodingException, NoSuchPaddingException,
    IllegalBlockSizeException, BadPaddingException, InvalidKeyException {
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        byte[] key = Arrays.copyOf(sha.digest((""ThisisMySalt1234"" + password).getBytes(""UTF-8"")),
        16);
        skeySpec = new SecretKeySpec(key, ""AES"");
        cipher = Cipher.getInstance(""AES"");
        cipher2 = Cipher.getInstance(""AES"");
    }

    String encrypt(String clear) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {
        String encrypted = new String();

        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] encryptedBytes = null;
        encryptedBytes = cipher.doFinal(clear.getBytes());

        encrypted = Base64.encodeToString(encryptedBytes, Base64.DEFAULT);

        return encrypted;
    }

    // fehlerhaft
    String decrypt(String encryptedBase64) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        String decrypted = new String();
        cipher2.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decodedBytes = null;


        decodedBytes = Base64.decode(encryptedBase64, Base64.DEFAULT);

        decrypted = cipher2.doFinal(decodedBytes).toString();

        return decrypted;

    }
}
</code></pre>
"	NULL	1	NULL	22:59.9	4	53:19.4	44:11.1	NULL	1176870	4996101	0	1	0	<android><security><encryption><encryption-symmetric>	Android encryption and decryption of text fails	255	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
31159573	31160125	1	"<p>Trying to decrypt data as byte array encrypted with AES-128 with String key ""keykeykeykeykey1"" </p>

<p>code:</p>

<pre><code>byte[] dataBytes = new byte []{(byte)0xf3,(byte)0x8b,(byte)0x0c,(byte)0xb3,(byte)0xa3,(byte)0x26,(byte)0x12,(byte)0x23,(byte)0xe0,(byte)0xe0,(byte)0x9f,(byte)0x1f,(byte)0x28,(byte)0x01,(byte)0x28,(byte)0x35};
SecretKeySpec secretKeySpec = new SecretKeySpec(""keykeykeykeykey1"".getBytes(""UTF-8""), ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
byte[] decryptedData = cipher.doFinal(dataBytes); //this line throws exception
</code></pre>

<p>gives me BadPaddingException. What I missed?</p>
"	NULL	4	NULL	07:47.6	2	12:49.1	12:49.1	NULL	4899695	4899695	0	1	0	<java><encryption><aes>	Java AES 128 decryption with String key BadPaddingException	457	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
31238352	31245375	3	"<p>I have an application that needs to store some secret passwords in a configuration file such as database and ftp passwords/detail. I've looked around and found a lot of encryption/decryption solutions using AES, but I can't seem to figure out how to make it work without changing the key. That means I can encrypt and decrypt (using the same SecretKey), but to maintain persistence across restarts etc. I can't seem to make the SecretKey stay the same. The example below shows my methods working:</p>

<pre><code>String secret = Encryptor.encrpytString(""This is secret"");
String test = Encryptor.decrpytString(secret);
System.out.println(test); //This is secret is printed
</code></pre>

<p>So far so good. However if I run it once I might get the value of '2Vhht/L80UlQ184S3rlAWw==' as my secret, the next time it is 'MeC4zCf9S5wUUKAu8rvpCQ==', so presumably the key is changing. I'm assuming I am applying some counter-intuative logic to the problem and would appreciate if someone can shed some light on either a) what I'm doing wrong, or b) a solution that would allow me to store the password information encrypted and retrievable with the information provided.</p>

<p>My methods are as follows:</p>

<pre><code>private static final String salt = ""SaltySalt"";

private static byte [] ivBytes = null;

private static byte[] getSaltBytes() throws Exception {
    return salt.getBytes(""UTF-8"");
}

private static char[] getMasterPassword() {
    return ""SuperSecretPassword"".toCharArray();
}

private static byte[] getIvBytes() throws Exception {
    if (ivBytes == null) {
        //I don't have the parameters, so I'll generate a dummy encryption to create them
        encrpytString(""test"");
    }
    return ivBytes;
}

public static String encrpytString (String input) throws Exception {
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    PBEKeySpec spec = new PBEKeySpec(getMasterPassword(), getSaltBytes(), 65536,256);
    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    ivBytes = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
    byte[] encryptedTextBytes = cipher.doFinal(input.getBytes(""UTF-8""));
    return DatatypeConverter.printBase64Binary(encryptedTextBytes);        
}

public static String decrpytString (String input) throws Exception {
    byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(input);
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    PBEKeySpec spec = new PBEKeySpec(getMasterPassword(), getSaltBytes(), 65536, 256);
    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(getIvBytes()));
    byte[] decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
    return new String(decryptedTextBytes);
}
</code></pre>

<p>Thanks for the help!</p>
"	NULL	0	NULL	33:48.9	3	54:40.1	NULL	NULL	0	2629159	0	1	8	<java><encryption><aes><password-encryption>	Java AES encryption and decryption with static secret	7982	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
31851612	31863209	1	"<p>I'm using <code>AES/GCM/NoPadding</code> encryption in Java 8 and I'm wondering whether my code has a security flaw.  My code seems to <em>work</em>, in that it encrypts and decrypts text, but a few details are unclear.</p>
<p>My main question is this:</p>
<pre><code>Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] iv = cipher.getIV(); // ?????
</code></pre>
<p><strong>Does that IV satisfy the requirement of &quot;For a given key, the IV MUST NOT repeat.&quot; from <a href=""https://www.rfc-editor.org/rfc/rfc4106#section-3.1"" rel=""nofollow noreferrer"">RFC 4106</a>?</strong></p>
<p>I'd also appreciate any answers / insight for my related questions (see below), but that first question is bugging me the most.  I don't know where to find source code or documentation that answers this.</p>
<hr />
<p>Here is the full code, roughly.  I apologize in case I introduced errors while writing this post:</p>
<pre><code>class Encryptor {
  Key key;

  Encryptor(byte[] key) {
    if (key.length != 32) throw new IllegalArgumentException();
    this.key = new SecretKeySpec(key, &quot;AES&quot;);
  }

  // the output is sent to users
  byte[] encrypt(byte[] src) throws Exception {
    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    cipher.init(Cipher.ENCRYPT_MODE, key);
    byte[] iv = cipher.getIV(); // See question #1
    assert iv.length == 12; // See question #2
    byte[] cipherText = cipher.doFinal(src);
    assert cipherText.length == src.length + 16; // See question #3
    byte[] message = new byte[12 + src.length + 16]; // See question #4
    System.arraycopy(iv, 0, message, 0, 12);
    System.arraycopy(cipherText, 0, message, 12, cipherText.length);
    return message;
  }

  // the input comes from users
  byte[] decrypt(byte[] message) throws Exception {
    if (message.length &lt; 12 + 16) throw new IllegalArgumentException();
    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    GCMParameterSpec params = new GCMParameterSpec(128, message, 0, 12);
    cipher.init(Cipher.DECRYPT_MODE, key, params);
    return cipher.doFinal(message, 12, message.length - 12);
  }
}
</code></pre>
<p>Suppose that users cracking my secret key = game over.</p>
<hr />
<p>More detailed questions / related questions:</p>
<ol>
<li>Is the IV returned by cipher.getIV() safe for me to use in this way?</li>
</ol>
<ul>
<li>Does it avoid the catastrophe of reusing the IV,key combination in Galois/Counter Mode?</li>
<li>Is it still safe when I have multiple applications running this code at once, all displaying encrypted messages to users from the same src data (possibly in the same millisecond)?</li>
<li>What's the returned IV made of?  Is it an atomic counter plus some random noise?</li>
<li>Do I need to avoid <code>cipher.getIV()</code> and construct an IV myself, with my own counter?</li>
<li>Is the source code implementing <code>cipher.getIV()</code> available online somewhere, assuming I'm using Oracle JDK 8 + JCE Unlimited Strength extension?</li>
</ul>
<ol start=""2"">
<li><p>Is that IV always 12 bytes long?</p>
</li>
<li><p>Is the authentication tag always 16 bytes (128 bits) long?</p>
</li>
<li><p>With #2 and #3, and the lack of padding, does that mean my encrypted messages are always <code>12 + src.length + 16</code> bytes long?  (And so I can safely squish them into one byte array, for which I know the correct length?)</p>
</li>
<li><p>Is it safe for me to display an unbounded number of src data encryptions to users, given constant src data that the users know?</p>
</li>
<li><p>Is it safe for me to display an unbounded number of src data encryptions to users, if the src data is different every time (e.g. including <code>System.currentTimeMillis()</code> or random numbers)?</p>
</li>
<li><p>Would it help if I padded the src data with random numbers before encryption?  Say 8 random bytes in front and back, or only on one end?  Or would that not help at all / make my encryption worse?</p>
</li>
</ol>
<p>(Because these questions are all about the same block of my own code, and they are strongly related to each other, and others might/should have the same set of questions when implementing the same functionality, it felt wrong to split the questions into multiple posts.  I can re-post them separately if that is more appropriate for StackOverflow's format.  Let me know!)</p>
"	NULL	3	NULL	14:31.8	19	50:18.5	50:18.5	NULL	589259	359008	0	1	55	<java><security><encryption><cryptography><aes-gcm>	"How are the IV and authentication tag handled for ""AES/GCM/NoPadding""?"	35951	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
32269928	32285044	1	"<p>Java: Oracle jre1.8.0_45</p>

<p>Provider: BC, BouncyCastle v1.52</p>

<p>Cipher: AES 256bit keys (security policy installed)</p>

<p>AEAD Mode: GCM</p>

<p>Algo: AES/GCM/NoPadding</p>

<p>I have a perfectly working AES encryption/decryption with the parameters shown above. Then during my debug I added a simple TAMPERING simulation by changing data in the Encrypted buffer before decrypting. I expected an AEADBadTagException to be thrown but it didn't happen. I did NOT use any upedateAAD() yet, we are talking about pure ciphered data pay-load.</p>

<p>I do that tampering simply like this, I overwrite the first byte of the byte[] after it already contains the encrypted data and the 16 extra bytes of the authentication tag. </p>

<pre><code>// set-up for encryption, key, IV, etc...
...
try
{
  String sPlainText=""The non-encrypted (AES) message."";    
  byte[] baEncrypted=oCIPH.doFinal(sPlainText.getBytes());

  MetaLogbook.info(baEncrypted); // Shows well encrypted buffer

  // Tampering simulations
  baEncrypted[0]=0x67;

  // re-initialize for decryption, same key and IV...

  String sDecryptedText=new String(oCIPH.doFinal(baEncrypted),""UTF-8"");
  MetaLogbook.info(sDecryptedText);

  // The above log line shows the plain text with a different first letter
  // each time that i change 0x67 in other values. The rest of the message
  // matches the plain text on input. I can see the 16 extra bytes of the 
  // authentication tag appended to the clear text.
}
catch(Exception e)
{
  // I expected to come here due to a AEADBadTagException but I never 
  // come here.
  MetaLogbook.error(e);
}
</code></pre>

<p>The resulting decrypted text changes at the first character as i change the value that i assign while simulating the tampering. It changes in a non-linear way. While 0x65 produces a 'c', 0x67 produces a '?' and so on. The rest of the plain message remains correct, only the first character of the decrypted output seems affected.</p>

<p>I understood from the standard Java 8 doc of the Cipher class that in AEAD GCM mode the authentication tag is created at encryption time (and it was because I see it in my encrypted output byte[] appended at the end) and verified at decryption time (and I provided the full output of encryption including the 16 bytes tag as decryption input) and if the tag would not verify with that data (including AAD data that i don't use now but will) it would throw a AEADBadTagException. In my code it doesn't do that.</p>

<p>I tried this with data that is a multiple of 16 bytes as well as with data that is not. The result is the same for both.  If using the same tampering (0x67) value that first letter in the plain text output changes if the message gets longer but that makes sense. The mentioned erroneous first character 'c' becomes a '6' if i add some bytes to the message so that it is not a multiple of 16. In the used AES/GCM/NoPadding the length must not be a multiple of 16 anyway.  </p>

<p>Is this a mis-understanding of the documentation, is there some other method that needs to be called to 'enable' this throw behaviour (I could find any),  or doesn't BounceyCastle throw it (I understood that a provider needs to implement the crypto classes ISP such that everything behaves as described in the Java 8 Docs Cipher class. </p>

<p>I could not compare with the SunJCE provider because it doesn't support AES/GCM/NoPadding.</p>

<p>Does anyone has some extra info.
TIA</p>

<p>UPDATE 29/AUG: Added code to show that identical code throws with SunJCE and not with BC provider as part of discussion in comments.</p>

<pre><code>private static void testing()
{
  try
  {
    // Unremark these lines to see it work
    //Security.addProvider(new BouncyCastleProvider()); // ""BC""
    //Cipher oCIPH=Cipher.getInstance(""AES/GCM/NoPadding"", ""BC"");

    // Unremark these lines to see it fail
    Cipher oCIPH=Cipher.getInstance(""AES/GCM/NoPadding"", ""SunJCE""); 

    // Make a quick and dirty IV and Symmetric Key
    byte[] baIV=""EECE34808EF2A9AC"".getBytes(""UTF-8"");
    byte[] baKey=""010F05E3E0104EB59D10F37EA8D4BB6B"".getBytes(""UTF-8"");

    // Make IV and Key (well KeySpec for AES) object. Use IV parspec because
    // defaults to 128bit Authentication tag size &amp; works in both GCM &amp; CBC.
    IvParameterSpec ps=new IvParameterSpec(baIV);
    SecretKeySpec sk=new SecretKeySpec(baKey,""AES"");

    // Unremakr one line, either shrtline (multiple of 16 bytes) or long line   
    //String sPlainText=""The non-encrypted (AES) message."";
    String sPlainText=""The non-encrypted (AES) message. Everything after the . makes this NOT a multiple of 16 bytes."";

    // Encrypt
    oCIPH.init(Cipher.ENCRYPT_MODE, sk, ps);
    byte[] baEncrypted=oCIPH.doFinal(sPlainText.getBytes());

    // Decrypt
    oCIPH.init(Cipher.DECRYPT_MODE, sk, ps);
    String sDecryptedText=new String(oCIPH.doFinal(baEncrypted),""UTF-8"");        
  }
  catch(Exception e)
  {
    MetaLogbook.log(""Security Tools Exception"",e);
  }
} 
</code></pre>

<p>The code above can be run with SunJCE or with BouncyCastle by unremarking the the wanted lines at the top. In BC these code runs and does what it is expected to do. With SunJCE provider unremarked an error is thrown:</p>

<blockquote>
  <p>class java.security.InvalidAlgorithmParameterException: Unsupported
  parameter: javax.crypto.spec.IvParameterSpec@4fccd51b
  com.sun.crypto.provider.CipherCore.init (CipherCore.java:509)
  com.sun.crypto.provider.AESCipher.engineInit (AESCipher.java:339)
  javax.crypto.Cipher.init (Cipher.java:1394) javax.crypto.Cipher.init
  (Cipher.java:1327)</p>
</blockquote>
"	NULL	5	NULL	22:53.5	2	49:30.7	49:30.7	NULL	2225646	3759477	0	1	1	<java><cryptography><aes><bouncycastle><aes-gcm>	AEADBadTagException doesn't throw when tampering with AES encrypted buffer in AEAD GCM mode	1713	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
32508961	32565922	4	"<p>I'm not a cryptography profi and specially due to the fact that OpenSSL has lots of missing documentation, I'm not sure how can I solve this problem.</p>

<p>I have an external system which expects to receive encrypted messages. The only example provided uses OpenSSL in this way:</p>

<pre class=""lang-none prettyprint-override""><code>$ openssl enc -aes-256-cbc -a -in t.txt -k testpass
U2FsdGVkX1/RUdaSJKRXhHv3zUyTsQwu5/ar2ECKDlrNyH5GL4xRR4fgxkiWqkS1
cQstcoSIgWfRPSOFj/5OtdNLeNXiVR6MxSKJ+NvS9LyUD8+Rg6XIcYUvxR4gHi3w
DWT44LAMCpRAh1Q0t4Z2g7rwb0D05T6ygLaWvB5zD/xGZD3brTqSlWmiJb9Imgda
M6soZO7BhbYdqWqEUl5r6+EbkD21f6L3NX3hJFo+BJ+VFctiAlBO8NwT5l4ogo/s
GErm8gqRr57XoX/kvKAimg==
</code></pre>

<p>Where the <code>t.txt</code> file contains this string on one line:</p>

<pre class=""lang-none prettyprint-override""><code>AMOUNT=10&amp;TID=#19:23&amp;CURRENCY=EUR&amp;LANGUAGE=DE&amp;SUCCESS_URL=http://some.url/sucess&amp;ERROR_URL=http://some.url/error&amp;CONFIRMATION_URL=http://some.url/confirm&amp;NAME=customer full name`
</code></pre>

<p>I have found <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">this</a> other question and I have been able to do the encryption using following code:</p>

<pre class=""lang-java prettyprint-override""><code>String password = ""passPhrase"";
String salt = ""15charRandomSalt"";
int iterations = 100;

/* Derive the key, given password and salt. */
SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(Charset.forName(""UTF8"")), iterations, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

/* Encrypt the message. */
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
byte[] cipherText = cipher.doFinal(toBeEncrypted.getBytes(""UTF-8""));
encryptedData = Base64.getEncoder().encodeToString(cipherText);
encryptedData += Base64.getEncoder().encodeToString(iv);
</code></pre>

<p>What I can not understand is how should I generate similar output (encryptedData) to what OpenSSL does. I have the salt, iv and cipherText, is the OpenSSL output Base64 encoded result of a concatenation of these? or only one single of them?</p>

<p>The only thing I share with that other system before encryption is the pass phrase. How could they decrypt the result if salt and number of iterations is not known to them?</p>

<p>Can somebody give answers to those unknown parameters and also tell me if the above code is the equivalent of OpenSSL process?</p>
"	NULL	6	NULL	13:47.8	5	14:00.3	32:33.3	NULL	-1	438727	0	1	9	<java><encryption><openssl><cryptography>	Java equivalent of an OpenSSL AES CBC encryption	18322	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34193514	34198995	1	"<p>I found this well written example of how to use AES encryption, and I will admit some of the more advanced aspects are beyond me. The class works fine, provided I'm using the same instance object. If I create another object, using the same exact passPhrase - that object can no longer properly decode any kind of string or data that the previous object created. I can only conclude that since this code takes the rather weak passPhrase string, mixes SALT, and builds a stronger 128-bit key - that this process of key construction is somehow randomized each time around. The significance being:</p>

<pre><code>new AESEncrypter(""MyPassword"") &lt;&gt; new AESEncrypter(""MyPassword"")
</code></pre>

<p>Could someone help me modify the class below to get the desired behavior:</p>

<pre><code>AESEncrypter a = new AESEncrypter(""MyPassword"")
String encoded = a.encrypt(""my message"")

AESEncrypter b = new AESEncrypter(""MyPassword"")
b.decrypt(encoded) == ""my message""
</code></pre>



<pre><code>import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class AESEncrypter {

    private static final byte[] SALT = {
            (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,
            (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03
    };
    private static final int ITERATION_COUNT = 65536;
    private static final int KEY_LENGTH = 128;
    public Cipher ecipher;
    public Cipher dcipher;

    AESEncrypter(String passPhrase) throws Exception {

    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT, KEY_LENGTH);
        SecretKey tmp = factory.generateSecret(spec);

        // I Think the problem is here???

        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        ecipher.init(Cipher.ENCRYPT_MODE, secret);

        dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] iv = ecipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
        dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    }

    public String encrypt(String encrypt) throws Exception {
        byte[] bytes = encrypt.getBytes(""UTF8"");
        byte[] encrypted = encrypt(bytes);
        return new BASE64Encoder().encode(encrypted);
    }

    public byte[] encrypt(byte[] plain) throws Exception {
        return ecipher.doFinal(plain);
    }

    public String decrypt(String encrypt) throws Exception {
        byte[] bytes = new BASE64Decoder().decodeBuffer(encrypt);
        byte[] decrypted = decrypt(bytes);
        return new String(decrypted, ""UTF8"");
    }

    public byte[] decrypt(byte[] encrypt) throws Exception {
        return dcipher.doFinal(encrypt);
    }

   public static void main(String[] args) throws Exception {

        String message = ""MESSAGE"";
        String password = ""PASSWORD"";

        AESEncrypter encrypter1 = new AESEncrypter(password);
        AESEncrypter encrypter2 = new AESEncrypter(password);

        String encrypted1 = encrypter1.encrypt(message);
        String encrypted2 = encrypter2.encrypt(message);

        System.out.println(""Display Encrypted from object 1 and 2..why do they differ?"" );

        System.out.println(encrypted1) ;
        System.out.println(encrypted2) ;

        System.out.println(""Display Each object decrypting its own encrypted msg. Works as expected"" );

        System.out.println(encrypter1.decrypt(encrypted1)) ;
        System.out.println(encrypter2.decrypt(encrypted2)) ;

        System.out.println(""Attempt to decrypt the each others msg.. will fail"" );

        System.out.println(encrypter1.decrypt(encrypted2)) ;
        System.out.println(encrypter2.decrypt(encrypted1)) ;

    }

}
</code></pre>

<p>Display Encrypted from object 1 and 2..why do they differ?</p>

<pre>
drGy+BNSHPy34NWkkcNqLQ==

9p06VfBgTuh7TizZSbvKjw==
</pre>

<p>Display Each object decrypting its own encrypted msg. Works as expected</p>

<pre>
MESSAGE

MESSAGE
</pre>

<p>Attempt to decrypt the each others msg.. will fail</p>

<p>Error:</p>

<pre><code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:966)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
    at javax.crypto.Cipher.doFinal(Cipher.java:2165)
</code></pre>
"	NULL	3	NULL	06:41.2	3	12:18.4	12:18.4	NULL	1816580	1243034	0	1	1	<java><encryption>	AES Encryption key generation that is consistent each execution?	462	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34317194	34317419	1	"<p>I was expecting to get the same encryted result if I use the same input string, same key and same iv.  However, each time I run my encrypt program it generates different results.  Is there some other random number that's being used by the encryption code?</p>

<p>my encrypt code:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.nio.charset.StandardCharsets;
import javax.xml.bind.DatatypeConverter;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.security.InvalidAlgorithmParameterException;
import javax.crypto.BadPaddingException;

public class Encrypt
{
    private static byte[] _key = new byte[] {
            (byte) 0x02, (byte) 0xb2, (byte) 0xc4, (byte) 0x9e,
            (byte) 0xf9, (byte) 0x44, (byte) 0x99, (byte) 0xc9,
            (byte) 0x80, (byte) 0x65, (byte) 0xcd, (byte) 0x8f,
            (byte) 0x69, (byte) 0x2b, (byte) 0x74, (byte) 0x34};

    private static byte[] _iv = new byte[] {
            (byte) 0x69, (byte) 0x2b, (byte) 0x74, (byte) 0x34,
            (byte) 0x02, (byte) 0xb2, (byte) 0xc4, (byte) 0x9e,
            (byte) 0xf9, (byte) 0x44, (byte) 0x99, (byte) 0xc9,
            (byte) 0x80, (byte) 0x65, (byte) 0xcd, (byte) 0x8f};

    public static void main(String[] args)
            throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException,
            NoSuchPaddingException, InvalidAlgorithmParameterException,
            BadPaddingException
    {
        if (args.length != 1)
            System.out.println(""Error, expecting a single string to encrypt as a command line argument."");
        else
            {
            Cipher cipher = Cipher.getInstance(""AES/CBC/ISO10126Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(_key, ""AES""),
                    new IvParameterSpec(_iv));
            byte[] encrypted = cipher.doFinal(args[0].getBytes(StandardCharsets.US_ASCII));
            String result = DatatypeConverter.printBase64Binary(encrypted);
            System.out.println(""result: "" + result);
            }
    }
}
</code></pre>

<p>Thanks,
Nick</p>
"	NULL	1	NULL	28:32.4	2	40:53.7	NULL	NULL	0	4238474	0	1	2	<java><encryption><aes>	"java Cipher.doFinal() returning different results when using same input, key and iv"	2170	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34349662	34350096	1	"<p>I'm working on a security application using my own customized cryptography method, and having a problem on message decryption.</p>

<p>Here is an my Code</p>

<pre><code>private static void myCryptography(){

Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
byte[] input = ""Hitesh Dhamshaniya"".getBytes();
byte[] keyBytes = ""ABCD657865BHNKKK"".getBytes();
SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"", ""BC"");

// encryption pass

cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
ctLength += cipher.doFinal(cipherText, ctLength);
Log.e(""==&gt; "", "" == &gt; Encode "" + Base64.encodeToString(cipherText, Base64.DEFAULT));
String encodedStr = Base64.encodeToString(cipherText, Base64.DEFAULT);
// decryption pass

cipherText = Base64.decode(encodedStr, Base64.DEFAULT);
cipher.init(Cipher.DECRYPT_MODE, key);
byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);
ptLength += cipher.doFinal(plainText, ptLength);
Log.e(""==&gt; "", "" == &gt; Decoded "" + new String(plainText, ""UTF-8""));

}
</code></pre>

<p>Getting below output</p>

<p>== > Encode TteNmufoa5AWWmEPBmQ3N8fdqRpahvwUR7CSclAcsjM=</p>

<p>== > Decoded Hitesh Dhamshaniya?????????????????????</p>

<p>How to remove unwanted character like '??' from decode string.</p>
"	NULL	0	NULL	26:19.0	1	15:50.7	15:50.7	NULL	3797630	3797630	0	1	3	<android><aes>	How to remove PKCS7 padding from an AES encrypted string in android?	1360	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34440854	34914092	2	"<p>Android M provides AES support via the AndroidKeyStore however I can not find any combination of generating a key that provides a method of full encryption and decryption without a user password/device locking. It appears that my current approach is appropriate for these requirements as the key store is storing my key, I can load the key and perform encryption and in the case that I hold onto the IV from the encryption process I can decrypt the data.</p>

<p>Unfortunately in the real world use case I can not hold onto the IV for decryption at a later time without writing it to disk, maybe this is what I should be doing? </p>

<p>I have glanced at the updated key store and related testing in the SDK but was unable to find any test cases I could use as example. The examples also seem to be devoid of actually using AndroidKeyStore generated SecretKeys without tying them to device locking/finger prints.</p>

<p>I have created a repository to try and highlight what I have done along with some comments explaining where my issue is. The relevant code is also included below.</p>

<p>For clarity, my question is simply how can I generate an AndroidKeyStore backed AES SecretKey that allows me to encrypt and decrypt via cipher input/output streams without writing the IV to disk or using the fingerprint/device locking approaches?</p>

<p><a href=""https://github.com/ToxicBakery/AES-Testing/blob/master/app/src/androidTest/java/com/toxicbakery/app/aes/AesTest.java"" rel=""nofollow"">https://github.com/ToxicBakery/AES-Testing/blob/master/app/src/androidTest/java/com/toxicbakery/app/aes/AesTest.java</a></p>

<pre><code>    final String suchAlphabet = ""abcdefghijklmnopqrstuvwxyz"";

    KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
    keyStore.load(null);

    /*
    KEY GENERATION
     */

    // Define the key spec
    KeyGenParameterSpec aesSpec = new KeyGenParameterSpec.Builder(ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
            .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
            .setKeySize(128)
            .build();

    // Create the secret key in the key store
    KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE);
    keyGenerator.init(aesSpec);
    keyGenerator.generateKey();

    Cipher cipher;
    SecretKey secretKey;

    /*
    ENCRYPTION
     */

    // Load the secret key and encrypt
    secretKey = ((KeyStore.SecretKeyEntry) keyStore.getEntry(ALIAS, null)).getSecretKey();
    cipher = Cipher.getInstance(TRANSFORMATION);
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);

    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);
    cipherOutputStream.write(suchAlphabet.getBytes());
    cipherOutputStream.flush();
    cipherOutputStream.close();

    /*
    DECRYPTION
     */

    // Load the secret key and decrypt
    secretKey = ((KeyStore.SecretKeyEntry) keyStore.getEntry(ALIAS, null)).getSecretKey();

    // The following two lines attempt to represent real world usage in that the previous line loaded
    // the key from the store and the next two lines attempt to create the cipher and then initialize
    // the cipher such that an IV can be extracted as it does not seem that you can use the spec or the
    // parameters. Interestingly, the following two lines only 'half' such that a-p fail to decrypt and
    // q-z decrypt successfully 100% of the time. Leaving the lines commented results an in a successful
    // decryption of the alphabet but this is not a usable scenario
    //
    //        cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    //        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

    IvParameterSpec ivParameterSpec = new IvParameterSpec(cipher.getIV());
    cipher = Cipher.getInstance(TRANSFORMATION);
    cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);

    byte[] in = new byte[suchAlphabet.getBytes().length];
    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
    CipherInputStream cipherInputStream = new CipherInputStream(inputStream, cipher);
    IOUtils.readFully(cipherInputStream, in);
    cipherInputStream.close();

    /*
    VERIFY
     */

    String muchWow = new String(in);
    assertEquals(suchAlphabet, muchWow);
</code></pre>
"	NULL	0	NULL	29:56.8	1	59:49.3	NULL	NULL	0	1286667	0	1	4	<android><encryption><cryptography>	Using AES with AndroidKeyStore	7001	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34584743	34584883	1	"<p>I'm very new to encryption and I've been tasked to encrypt a password before verifying to the server (I know it's bad practice but I'll have to follow.). This is my encryption method:</p>

<pre><code>public static String encrypt(String src) {
    try {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        Key key = makeKey();
        AlgorithmParameterSpec iv = makeIv();

        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        return Base64.encodeBytes(cipher.doFinal(src.getBytes()));
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}

 static AlgorithmParameterSpec makeIv() {
        return new IvParameterSpec(ENCRYPTION_IV.getBytes(encoding));
}


static Key makeKey() {
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        byte[] key = md.digest(ENCRYPTION_KEY.getBytes(encoding));
        return new SecretKeySpec(key, ""AES"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>Where the iv is composed of a 13 character string. I specified the padding but why do I still get the <code>InvalidAlgorithmParameterException: IV must be 16 bytes long.</code> error? How do I really implement this encryption method?</p>
"	NULL	0	NULL	37:09.9	4	55:29.6	NULL	NULL	0	5096562	0	1	-1	<android><encryption><cryptography><aes>	AES/CBC Encryption: added padding but still getting IV error	397	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34854288	34913939	1	"<p>Android provides a API to generate keys for crypto operations and to store/load them in/from Androids Systemkeystore.</p>

<p>I followed the Example in the JavaDocs of <a href=""http://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html"" rel=""nofollow"">KeyGenParameterSpec</a> class. Generation, store and load of the Secret Key works. But if I try to use the key, the init() call of the Cipher Object fails. I debugged a little bit, and I can see, that the loaded Key is of type ""android.security.keystore.AndroidKeyStoreSecretKey"". This implementation prevents, that the byte[] of the key is exposed. I understand this for security reasons, but if I want to use the key, I have to get the key content. So, I must do something wrong. Maybe, there exists another way for using crypto operations in Android? Or is the loading code of the Key wrong? </p>

<p>Here is the code:</p>

<pre><code>KeyGenerator keyGenerator = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");

KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(""demo-alias"", KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT);
builder.setKeySize(256);
builder.setBlockModes(KeyProperties.BLOCK_MODE_CBC);
builder.setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7);
keyGenerator.init(builder.build());

// this key will work with a CipherObject ...
SecretKey key = keyGenerator.generateKey();

// Load the key from the Keystore
KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
keyStore.load(null);

// This key will not work with the Cipher Object
SecretKey notWorkingKey = (SecretKey) keyStore.getKey(""demo-alias"", null);

Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
// That call fails
cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(new byte[]{87, 99, -94, 23, -17, 26, 84, -117, 59, -59, 25, -88, -66, 86, -42, 78}));

byte[] crypted = cipher.doFinal(""testdata"".getBytes());
</code></pre>

<p>the init(...) of the cipher fails with the following exception:</p>

<pre><code>java.lang.NullPointerException: Attempt to get length of null array
    at com.android.org.bouncycastle.crypto.params.KeyParameter.&lt;init&gt;(KeyParameter.java:13)
    at com.android.org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineInit(BaseBlockCipher.java:557)
    at javax.crypto.Cipher.tryTransformWithProvider(Cipher.java:608)
    at javax.crypto.Cipher.tryCombinations(Cipher.java:532)
    at javax.crypto.Cipher.getSpi(Cipher.java:437)
    at javax.crypto.Cipher.init(Cipher.java:909)
    at javax.crypto.Cipher.init(Cipher.java:859)
    at de.demo.crypt.LoginActivity.executeLogin(LoginActivity.java:95)
    at de.demo.crypt.LoginActivity.access$000(LoginActivity.java:37)
    at de.demo.crypt.LoginActivity$1.onClick(LoginActivity.java:58)
    at de.demo.crypt.ActionButton.buttonClicked(ActionButton.java:104)
    at de.demo.crypt.ActionButton.access$000(ActionButton.java:17)
    at de.demo.crypt.ActionButton$1.onClick(ActionButton.java:60)
    at android.view.View.performClick(View.java:5198)
    at android.view.View$PerformClick.run(View.java:21147)
    at android.os.Handler.handleCallback(Handler.java:739)
    at android.os.Handler.dispatchMessage(Handler.java:95)
    at android.os.Looper.loop(Looper.java:148)
    at android.app.ActivityThread.main(ActivityThread.java:5417)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)
</code></pre>
"	NULL	0	NULL	00:05.7	3	42:35.7	NULL	NULL	0	2115024	0	1	3	<android>	Problems loading private Key from AndroidKeystore	4211	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
34925407	34965976	2	"<p>In android/java app </p>

<pre><code>   public static void setKey(String myKey) {

        MessageDigest sha = null;
        try {
            key = new byte[]{(byte) '5', (byte) 'F', (byte) '8', (byte) 'p', (byte) 'J', (byte) 't', (byte) 'v', (byte) 'U', (byte) 'm', (byte) 'q', (byte) 'k', (byte) '7', (byte) 'A', (byte) 'M', (byte) 'v', (byte) 'b', (byte) 'q', (byte) 'o', (byte) 'H', (byte) 'M', (byte) '9', (byte) 'a', (byte) 'p', (byte) '4', (byte) '9', (byte) 'm', (byte) 'c', (byte) 'u', (byte) 'u', (byte) '5', (byte) 'B', (byte) 'X'};
            System.out.println(new String(key, ""UTF-8""));
            secretKey = new SecretKeySpec(key, ""AES"");
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }


    public static String encrypt(String strToEncrypt) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            setEncryptedarr(cipher.doFinal(strToEncrypt.getBytes(""UTF-8"")));
            setEncryptedString(String.valueOf(Base64.encode(cipher.doFinal(strToEncrypt.getBytes(""UTF-8"")), Base64.DEFAULT)));
            //setEncryptedString(Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(""UTF-8""))));
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(""Error while encrypting: "" + e.toString());
        }
        return null;
    }

    public static String decryptbyte(byte[] strToDecrypt) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            setDecryptedarr(cipher.doFinal(strToDecrypt));
            System.out.println(""encrypt : decropted size : "" + getDecryptedarr().length);
            setDecryptedString(new String(cipher.doFinal(strToDecrypt)));
        } catch (Exception e) {
            System.out.println(""Error wnhile decrypting: "" + e.toString());
            e.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String strToDecrypt) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            setDecryptedarr(cipher.doFinal(Base64.decode(strToDecrypt, Base64.DEFAULT)));
            setDecryptedString(new String(cipher.doFinal(Base64.decode(strToDecrypt, Base64.DEFAULT))));

        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(""Error while decrypting: "" + e.toString());

        }
        return null;
    }
</code></pre>

<p>I am working on this code : <a href=""http://aesencryption.net/"" rel=""noreferrer"">http://aesencryption.net/</a>
I use this snipped code is working well when use it in case of :
encryptbyte and decryptbyte whitch take byte[] 
and I test it it's result of encryption in this site <a href=""http://aesencryption.net/"" rel=""noreferrer"">http://aesencryption.net/</a></p>

<p><strong>but i need it to decript data came from server (response is came string)
and when I convert the String to byte[] the code always thraw exception :</strong>
javax.crypto.IllegalBlockSizeException: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length**</p>

<p>I think it's when covert the String to byte[] it change , if that what is the right way to convert .
Advice please .</p>

<p>This code thraw exception :</p>

<pre><code>try {
    AES.setKey("""");
    final String strToDecrypt = ""tATTXSdXI4w0oiu/fzgpyA=="";
    AES.decryptbyte(toBytes(strToDecrypt.toCharArray()));
} catch (Exception ex) {
    ex.printStackTrace();
}
</code></pre>

<p>this is the exception </p>

<pre><code>01-21 15:24:55.861 15700-15700/ W/System.err: javax.crypto.IllegalBlockSizeException: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
01-21 15:24:55.861 15700-15700/ W/System.err:     at com.android.org.conscrypt.NativeCrypto.EVP_CipherFinal_ex(Native Method)
01-21 15:24:55.861 15700-15700/ W/System.err:     at com.android.org.conscrypt.OpenSSLCipher.doFinalInternal(OpenSSLCipher.java:430)
01-21 15:24:55.861 15700-15700/ W/System.err:     at com.android.org.conscrypt.OpenSSLCipher.engineDoFinal(OpenSSLCipher.java:466)
01-21 15:24:55.861 15700-15700/ W/System.err:     at javax.crypto.Cipher.doFinal(Cipher.java:1340)
 01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1118)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2648)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2769)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.ActivityThread.access$900(ActivityThread.java:177)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:102)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.os.Looper.loop(Looper.java:135)
01-21 15:24:55.861 15700-15700/ W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:5910)
01-21 15:24:55.861 15700-15700/ W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
01-21 15:24:55.861 15700-15700/ W/System.err:     at java.lang.reflect.Method.invoke(Method.java:372)
01-21 15:24:55.861 15700-15700/ W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1405)
01-21 15:24:55.861 15700-15700/ W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1200)
</code></pre>
"	NULL	1	NULL	40:22.8	3	35:26.2	01:41.9	NULL	4373188	4373188	0	1	5	<java><android><encryption><aes>	Encrypt and Decrypt with AES ECB mode 'BadPaddingException' in some cases	10137	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
35403878	0	0	"<p>I am trying to find the correct way to encrypt files using Pycrypto. Every method I have found online doesn't seem to decrypt in Android or online at sites like <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow"">http://aes.online-domain-tools.com/</a></p>

<p>Here is the Python code I have tried:</p>

<pre><code>from Crypto import Random
from Crypto.Cipher import AES

def pad(s):
    return s + b""\0"" * (AES.block_size - len(s) % AES.block_size)

def encrypt(message, key, iv):
    message = pad(message)
    #iv = Random.new().read(AES.block_size)
    print iv
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(message)

def decrypt(ciphertext, key, iv):
    iv = ciphertext[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    return plaintext.rstrip(b""\0"")

def encrypt_file(file_name, key, iv):
    with open(file_name, 'rb') as fo:
        plaintext = fo.read()
    enc = encrypt(plaintext, key, iv)
    with open(file_name + "".enc"", 'wb') as fo:
        fo.write(enc)

def decrypt_file(file_name, key, iv):
    with open(file_name, 'rb') as fo:
        ciphertext = fo.read()
    dec = decrypt(ciphertext, key, iv)
    with open(file_name[:-1], 'wb') as fo:
        fo.write(dec)


#key = b'\xbf\xc0\x85)\x10nc\x94\x02)j\xdf\xcb\xc4\x94\x9d(\x9e[EX\xc8\xd5\xbfI{\xa2$\x05(\xd5\x18'
from random import choice
from string import ascii_uppercase

key = (''.join(choice(ascii_uppercase) for i in range(16)))
print key
iv = (''.join(choice(ascii_uppercase) for i in range(16)))
#iv = hex(iv)
print iv
encrypt_file('Grass.jpg', key, iv)
decrypt_file('Grass.jpg.enc', key, iv)
</code></pre>

<p>Here is the Android code I am using to decrypt (I have tried Nopadding and PKCS5Padding)</p>

<pre class=""lang-java prettyprint-override""><code>package com.jgarin.encryptingtestapp;

import android.util.Base64;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

   /*****************************************************************
    * CrossPlatform CryptLib
    * 
    * &lt;p&gt;
    * This cross platform CryptLib uses AES 256 for encryption. This library can
    * be used for encryptoion and de-cryption of string on iOS, Android and Windows
    * platform.&lt;br/&gt;
    * Features: &lt;br/&gt;
    * 1. 256 bit AES encryption
    * 2. Random IV generation. 
    * 3. Provision for SHA256 hashing of key. 
    * &lt;/p&gt;
    * 
    * @since 1.0
    * @author navneet
    *****************************************************************/

public class CryptLib {

   /**
    * Encryption mode enumeration
    */
   private enum EncryptMode {
      ENCRYPT, DECRYPT;
   }

   // cipher to be used for encryption and decryption
   Cipher cipher;

   // encryption key and initialization vector
   byte[] key, iv;

   public CryptLib() throws NoSuchAlgorithmException, NoSuchPaddingException {
      // initialize the cipher with transformation AES/CBC/PKCS5Padding
      cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
//    cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
      key = new byte[16]; //256 bit key space
      iv = new byte[16]; //128 bit IV
   }

   /**
    * Note: This function is no longer used. 
    * This function generates md5 hash of the input string
    * @param inputString
    * @return md5 hash of the input string
    */
   public static final String md5(final String inputString) {
       final String MD5 = ""MD5"";
       try {
           // Create MD5 Hash
           MessageDigest digest = java.security.MessageDigest
                   .getInstance(MD5);
           digest.update(inputString.getBytes());
           byte messageDigest[] = digest.digest();

           // Create Hex String
           StringBuilder hexString = new StringBuilder();
           for (byte aMessageDigest : messageDigest) {
               String h = Integer.toHexString(0xFF &amp; aMessageDigest);
               while (h.length() &lt; 2)
                   h = ""0"" + h;
               hexString.append(h);
           }
           return hexString.toString();

       } catch (NoSuchAlgorithmException e) {
           e.printStackTrace();
       }
       return """";
   }

   /**
    * 
    * @param inputData
    *            Text to be encrypted or decrypted
    * @param _encryptionKey
    *            Encryption key to used for encryption / decryption
    * @param _mode
    *            specify the mode encryption / decryption
    * @param _initVector
    *           Initialization vector
    * @return encrypted or decrypted string based on the mode
    * @throws UnsupportedEncodingException
    * @throws InvalidKeyException
    * @throws InvalidAlgorithmParameterException
    * @throws IllegalBlockSizeException
    * @throws BadPaddingException
    */
      private byte[] encryptDecrypt(byte[] inputData, String _encryptionKey,
         EncryptMode _mode, String _initVector) throws UnsupportedEncodingException,
         InvalidKeyException, InvalidAlgorithmParameterException,
         IllegalBlockSizeException, BadPaddingException {
      byte[] _out = new byte[0];// output string

      int len = _encryptionKey.getBytes(""UTF-8"").length; // length of the key    provided

      if (_encryptionKey.getBytes(""UTF-8"").length &gt; key.length)
         len = key.length;

      int ivlen = _initVector.getBytes(""UTF-8"").length;

      if(_initVector.getBytes(""UTF-8"").length &gt; iv.length)
         ivlen = iv.length;

      System.arraycopy(_encryptionKey.getBytes(""UTF-8""), 0, key, 0, len);
      System.arraycopy(_initVector.getBytes(""UTF-8""), 0, iv, 0, ivlen);
      //KeyGenerator _keyGen = KeyGenerator.getInstance(""AES"");
      //_keyGen.init(128);

      SecretKeySpec keySpec = new SecretKeySpec(key, ""AES""); // Create a new SecretKeySpec
                           // for the
                           // specified key
                           // data and
                           // algorithm
                           // name.

      IvParameterSpec ivSpec = new IvParameterSpec(iv); // Create a new
                        // IvParameterSpec
                        // instance with the
                        // bytes from the
                        // specified buffer
                        // iv used as
                        // initialization
                        // vector.

      // encryption
      if (_mode.equals(EncryptMode.ENCRYPT)) {
         // Potentially insecure random numbers on Android 4.3 and older.
         // Read
         // https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html
         // for more info.
         cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);// Initialize this cipher instance
         _out = cipher.doFinal(inputData); // Finish
                              // multi-part
                              // transformation
                              // (encryption)
      }

      // decryption
      if (_mode.equals(EncryptMode.DECRYPT)) {
         cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);// Initialize this cipher instance

         _out = cipher.doFinal(inputData); // Finish
                           // multi-part
                           // transformation
                           // (decryption)
      }
      System.out.println(_out);
      return _out; // return encrypted/decrypted string
   }

   /***
    * This function computes the SHA256 hash of input string
    * @param text input text whose SHA256 hash has to be computed
    * @param length length of the text to be returned
    * @return returns SHA256 hash of input text 
    * @throws NoSuchAlgorithmException
    * @throws UnsupportedEncodingException
    */
   public static String SHA256 (String text, int length) throws NoSuchAlgorithmException, UnsupportedEncodingException {

       String resultStr;
      MessageDigest md = MessageDigest.getInstance(""SHA-256"");

       md.update(text.getBytes(""UTF-8""));
       byte[] digest = md.digest();

       StringBuffer result = new StringBuffer();
       for (byte b : digest) {
           result.append(String.format(""%02x"", b)); //convert to hex
       }
       //return result.toString();

       if(length &gt; result.toString().length())
       {
          resultStr = result.toString();
       }
       else 
       {
          resultStr = result.toString().substring(0, length);
       }

       return resultStr;

   }

   /***
    * This function encrypts the plain text to cipher text using the key
    * provided. You'll have to use the same key for decryption
    * 
    * @param _plainText
    *            Plain text to be encrypted
    * @param _key
    *            Encryption Key. You'll have to use the same key for decryption
    * @param _iv
    *         initialization Vector
    * @return returns encrypted (cipher) text
    * @throws InvalidKeyException
    * @throws UnsupportedEncodingException
    * @throws InvalidAlgorithmParameterException
    * @throws IllegalBlockSizeException
    * @throws BadPaddingException
    */

   public String encrypt(String _plainText, String _key, String _iv)
         throws InvalidKeyException, UnsupportedEncodingException,
         InvalidAlgorithmParameterException, IllegalBlockSizeException,
         BadPaddingException {

        byte[] bytes = encryptDecrypt(_plainText.getBytes(""UTF-8""), _key, EncryptMode.ENCRYPT, _iv);
        String result = Base64.encodeToString(bytes, Base64.DEFAULT); // ciphertext
        return result;
   }

   public byte[] encrypt(byte[] data, String _key, String _iv)
         throws InvalidKeyException, UnsupportedEncodingException,
         InvalidAlgorithmParameterException, IllegalBlockSizeException,
         BadPaddingException {
      return encryptDecrypt(data, _key, EncryptMode.ENCRYPT, _iv);
   }

   /***
    * This funtion decrypts the encrypted text to plain text using the key
    * provided. You'll have to use the same key which you used during
    * encryprtion
    * 
    * @param data
    *            Encrypted/Cipher text to be decrypted
    * @param _key
    *            Encryption key which you used during encryption
    * @param _iv
    *         initialization Vector
    * @return encrypted value
    * @throws InvalidKeyException
    * @throws UnsupportedEncodingException
    * @throws InvalidAlgorithmParameterException
    * @throws IllegalBlockSizeException
    * @throws BadPaddingException
    */
   public byte[] decrypt(byte[] data, String _key, String _iv)
         throws InvalidKeyException, UnsupportedEncodingException,
         InvalidAlgorithmParameterException, IllegalBlockSizeException,
         BadPaddingException {
      return encryptDecrypt(data, _key, EncryptMode.DECRYPT, _iv);
   }

   public String decrypt(String inputString, String _key, String _iv)
         throws InvalidKeyException, UnsupportedEncodingException,
         InvalidAlgorithmParameterException, IllegalBlockSizeException,
         BadPaddingException {
        byte[] decryptedVal = encryptDecrypt(Base64.decode(inputString, Base64.DEFAULT), _key, EncryptMode.DECRYPT, _iv);
        String result = new String(decryptedVal, ""UTF-8"");
        return result;
   }

   /**
   * this function generates random string for given length
   * @param length
   *           Desired length
   * * @return 
   */
   public static String generateRandomIV(int length)
   {
      SecureRandom ranGen = new SecureRandom();
      byte[] aesKey = new byte[16];
      ranGen.nextBytes(aesKey);
      StringBuffer result = new StringBuffer();
       for (byte b : aesKey) {
           result.append(String.format(""%02x"", b)); //convert to hex
       }
       if(length&gt; result.toString().length())
       {
          return result.toString();
       }
       else
       {
          return result.toString().substring(0, length);
       }
   }
}
</code></pre>

<p>Any help with what I am doing wrong will be appreciated.</p>
"	NULL	3	NULL	40:46.0	1	01:45.2	01:45.2	NULL	1816580	521401	0	1	0	<android><python><encryption><pycrypto>	AES encryption of file using Pycrypto	1692	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
35661789	35670112	2	"<p>I've tried to gather all possible information about Encryption/Decryption from here. Tinkered with it, some success and failures. <br>
But now I've applied the code and its hit and a miss too. Some files (exe or msi's) are working but they still gives error about BadPaddingException. Moreover, some other media files like (mp4, mkv etc) are stuck at 99% and doesn't go beyond that, although they r fully received (just some minor bytes difference but <strong>Size on Disk</strong> always matches).<br><br>
I just want some help to get rid of these both problems. The files r transfering from 1 PC to another via socket programming.<br>
<strong>Server: (Edited)</strong> </p>

<pre><code>    DataInputStream dis = new DataInputStream(msock.getInputStream());
    DataOutputStream dos = new DataOutputStream(msock.getOutputStream());

    String file2dl = dis.readLine(); //2
    File file = new File(sharedDirectory.toString() + ""\\"" + file2dl);
    dos.writeLong(file.length()); //3+

    //Get file name without extension.
    String fileName = Files.getNameWithoutExtension(file2dl);

    //AES-128 bit key initialization.
    byte[] keyvalue = ""AES128BitPasswd"".getBytes();
    SecretKey key = new SecretKeySpec(keyvalue, ""AES"");

    //Initialize the Cipher.
    Cipher encCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    encCipher.init(Cipher.ENCRYPT_MODE, key);

    //Get the IV from cipher.
    IvParameterSpec spec = null;
    try {
        spec = encCipher.getParameters().getParameterSpec(IvParameterSpec.class);
    } catch (InvalidParameterSpecException ex) {
        Logger.getLogger(PeersController.class.getName()).log(Level.SEVERE, null, ex);
    }

    byte[] iv = spec.getIV();

    dos.write(iv, 0, iv.length);
    File tempDir = new File(tempDirectory.toString());
    //Encryption Mechanism.
        try (FileInputStream fis = new FileInputStream(file)) {
            try (CipherOutputStream cos = new CipherOutputStream(dos, encCipher);
                    FileInputStream stream = new FileInputStream(tempDir + ""\\"" + fileName + "".encr"")) {
                int read, r;
                byte[] buffer = new byte[1024 * 1024];
                while ((read = fis.read(buffer)) != -1) {
                    cos.write(buffer, 0, read);
                }
        }
    }
 }
</code></pre>

<p><br>
<strong>Client:</strong> </p>

<pre><code> long len;
 int count = 0;
 int dflag = 0;
 String size;
 dos.writeBytes(""Download\r\n""); //1+
 dos.writeBytes(filename + ""\r\n""); //2+
 System.out.println(""File to fetch: -&gt; "" + filename);
 len = dis.readLong(); //3
 System.out.println(""Size of file: -&gt; "" + len);

//Get file name without Extension.
String fileName = Files.getNameWithoutExtension(filename);

//Get Initialization Vector from Encryption Cypher.
byte[] iv = new byte[16];
int j = dis.read(iv, 0, iv.length);

final File encrypted = new File(sharedDirectory.toString() + ""\\"" + fileName + "".encr"");
final File decrypted = new File(sharedDirectory.toString() + ""\\"" + filename);
try (FileOutputStream fos = new FileOutputStream(encrypted)) {
    byte[] b = new byte[1024 * 1024];
    while (fetching) {
        int r = dis.read(b, 0, b.length); //4
        count = count + r;
        double p = (double) count / len;
        double per = new BigDecimal(p).setScale(4, BigDecimal.ROUND_HALF_UP).doubleValue();
        fos.write(b, 0, r);
        System.out.println(""Size Appending: -&gt; "" + count);
        System.out.println(""Percentage: -&gt;"" + per);
        Platform.runLater(() -&gt; {
            pBar.setProgress(per);
        });
        if (count &gt;= len) {
         dflag = 1;
         break;
        }
    }
}
</code></pre>

<p><br> <strong>If encrypted data is fully received</strong></p>

<pre><code>if(dflag == 1) {
     //AES-128 bit key initialization.
     System.out.println(""File completely received"");
     byte[] keyvalue = ""AES128PeerBuLLet"".getBytes();
     Key key = new SecretKeySpec(keyvalue, ""AES"");

     //Initialization Vector initialized
     IvParameterSpec ivParameterSpec = null;

     //Cipher Initialization.
     Cipher decCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
      try {
           decCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
     } catch (InvalidAlgorithmParameterException ex) {
                        Logger.getLogger(PeersController.class.getName()).log(Level.SEVERE, null, ex);
      }
      System.out.println(decCipher.getProvider().getInfo());

      //Decryption Mechanism.
      try (FileOutputStream stream = new FileOutputStream(decrypted)) {
             try (FileInputStream fis = new FileInputStream(encrypted)) {
                    try (CipherInputStream cis = new CipherInputStream(fis, decCipher)) {
                           int read, i = 0;
                           byte[] buffer = new byte[(1024 * 1024) + 16];
                           while ((read = cis.read(buffer)) != -1) {
                                    stream.write(buffer, 0, read);
                                    i = i + read;
                                    double d = (double) i / len;
                                    double progress = new BigDecimal(d).setScale(3, BigDecimal.ROUND_HALF_UP).doubleValue();
                                    Platform.runLater(() -&gt; {
                                        pBar.setProgress(progress);
                                        progressText.setText(""Decrypting.."");
                                    });
                                }
                            } catch (Exception e) {
                                System.out.println(e.getMessage());
                            }
                        }
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
        }
</code></pre>

<p>Any input is highly appreciated. Thank You.</p>

<p><strong>Edit 1:</strong> Added the link to the sizes of encrypted and decrypted file received via stream. <a href=""https://dl.dropboxusercontent.com/u/9747708/Images/Capture1.JPG"" rel=""nofollow noreferrer"">Dropbox Link</a>
<br><br><strong>Edit 2:</strong> So finally the problem is solved with the help of three members who participated in helping me to the fullest. I was reviewing other solutions to my problem and I encounter with <a href=""https://stackoverflow.com/questions/31474283/aes-file-decrypting-given-final-block-not-properly-padded?rq=1"">this</a> solution which helped me to think deep bout the actual scenario happening in the background. Thanks to <strong>Artjom B.</strong> for his referral solution and <strong>@zaph &amp; @jtahlborn</strong> for clearing my false assumptions bout padding and Input/Output streams.</p>
"	NULL	7	NULL	09:15.8	2	49:34.8	23:25.1	NULL	-1	5016871	0	1	2	<java><javafx><aes><encryption-symmetric><badpaddingexception>	BadPaddingException and some files stuck at 99%	267	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
35689983	35691309	1	"<p>I am trying to decrypt a byte array using the following code. I left out exception handling and other practices for brevity:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
byte[] key = getKey(); \\Assume it is implemented.
byte[] iv = getIv(); \\Assume it is implemented;
SecretKeySpec sc = new SecretKeySpec(key, ""AES"");
cipher.init(Cipher.DECRYPT_MODE, sc, new IvParameterSpec(iv));
byte[] encrypted = getBytesFromFile(); \*Assume it is implemented. Simply reads bytes from a binary file into a byte array and returns them as are.*\
byte[] clear = new byte[cipher.getOutputSize(encrypted.length)];
int processed = cipher.doFinal(encrypted, 0, encrypted.length, clear, 0);
</code></pre>

<p><strong>Note: PKCS7Padding is not supported natively in Java, but I did get it to work by adding the securtiy BouncyCastleProvider. For the sake of argument, PKCS5Padding has the same issue.</strong></p>

<pre><code>import org.bouncycastle.jce.provider.BouncyCastleProvider;
</code></pre>

<p><strong>The problem:</strong></p>

<p>doFinal throws throws a <strong>BadPaddingException: pad block corrupt</strong>. However, If I replace <em>doFinal</em> with <em>update</em>, that is:</p>

<pre><code>int processed = cipher.update(encrypted, 0, encrypted.length, clear, 0); 
</code></pre>

<p>It works perfectly. The result is as expected. </p>

<p>Can some please help me understand what the difference is and how I can make doFinal work? Please let me know if more information is required.  </p>
"	NULL	0	NULL	06:21.9	0	08:27.6	NULL	NULL	0	181218	0	1	0	<java><encryption><aes><block-cipher>	cipher.doFinal(...) fails while cipher.update(...) succeeds	1068	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
35853757	35854224	NULL	"<p>I have tried adding getbytes(""UTF"") or getbytes(""UTF-8""), since it was suggested in a similar question.
It said we need to try UTF while converting bytes to string and vice a versa. 
But still it is not working for my code...please help</p>

<pre><code>public class Password1 {

    private static final String ALGO = ""AES"";
    private static byte[] keyValue = new byte[]{'t','h','y','u','e','f','z','s','y','k','f','l','d','a','b','m'};

    public static void main(String[] args) {
        //Password1 p = new Password1();
        Scanner sc = new Scanner(System.in);
        String i = sc.nextLine();
        System.out.println(""Password = ""+i);

        try {
            String en = encrypt(i);
            System.out.println(en);
            String dec = decrypt(en);

            System.out.println(""Encrypted = "" + en);
            System.out.println(""Decrypted = "" + dec);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static String encrypt(String Data) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encVal = c.doFinal(Data.getBytes(""UTF-8""));
        String encrypted = new BASE64Encoder().encode(encVal);

        return encrypted;
    }

    public static String decrypt(String encrypted) throws Exception {
        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.DECRYPT_MODE, key);
        //Byte bencrypted = Byte.valueOf(encrypted);
        byte[] decoded = new BASE64Decoder().decodeBuffer(encrypted);

        byte[] decValue = c.doFinal(decoded);
        String decrypted = new String(decValue);
        return decrypted;
    }

    private static Key generateKey() throws Exception {
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        keyValue = sha.digest(keyValue);
        keyValue = Arrays.copyOf(keyValue, 16);
        SecretKeySpec key = new SecretKeySpec(keyValue, ALGO);
        return key;
    }

}
</code></pre>
"	NULL	NULL	NULL	50:47.1	NULL	NULL	NULL	NULL	NULL	6031140	0	1	1	<java><encryption><badpaddingexception>	"javax.crypto.BadPaddingException: Given final block not properly padded...tried using getbytes(""UTF"")"	15453	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
35907877	35926771	1	"<p>I am using this below (E.1) for my application, there is obviously a huge glaring security hole in this that I recognize and understand. I have grown interested in encryption and want to understand it better, I need to generate a random key along with an IV but am unsure how to do so properly Can someone explain to me whom is familiar with AES encryption how this works (IV &amp; KEY) So I am better able to understand in the future and can apply my knowledge, essentially I just want to make the code more secure, thank you.</p>

<p><strong>(E.1)</strong></p>

<pre><code>    byte[] key = ""mykey"".getBytes(""UTF-8"");

    private byte[] getKeyBytes(final byte[] key) throws Exception {
        byte[] keyBytes = new byte[16];
        System.arraycopy(key, 0, keyBytes, 0, Math.min(key.length, keyBytes.length));
        return keyBytes;
    }

    public Cipher getCipherEncrypt(final byte[] key) throws Exception {
        byte[] keyBytes = getKeyBytes(key);
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        return cipher;
    }

    public void encrypt(File in, File output, byte[] key) throws Exception {

        Cipher cipher = getCipherEncrypt(key);
        FileOutputStream fos = null;
        CipherOutputStream cos = null;
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(in);
            fos = new FileOutputStream(output);
            cos = new CipherOutputStream(fos, cipher);
            byte[] data = new byte[1024];
            int read = fis.read(data);
            while (read != -1) {
                cos.write(data, 0, read);
                read = fis.read(data);
             System.out.println(new String(data, ""UTF-8"").trim());

            }
            cos.flush();

        } finally {

            System.out.println(""performed encrypt method now closing streams:\n"" + output.toString());
            cos.close();
            fos.close();
            fis.close();


        }
    }


public void watchMeEncrypt(){

encrypt(file, new File (""example.txt),key);
</code></pre>
"	NULL	3	NULL	54:27.6	6	54:41.7	10:42.2	NULL	589259	5673705	0	1	7	<java><encryption><cryptography><byte><aes>	AES Encryption IV's	24881	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
36202917	36205061	1	"<p>I used following code to encrypt the data. My input is 16 bytes and key is 16 bytes but the output I am getting (encrypted data ) is 32 bytes. Why?</p>

<pre><code> public static byte[] encrypt(byte[] plainText, byte[] key)  {
try {
  byte[] passwordKey128 = Arrays.copyOfRange(key, 0, 16);
  SecretKeySpec secretKey = new SecretKeySpec(passwordKey128, ""AES"");
  Cipher cipher = Cipher.getInstance(""AES"");
  cipher.init(Cipher.ENCRYPT_MODE, secretKey);
  byte[] cipherText = cipher.doFinal(plainText);
  // String encryptedString = Base64.getEncoder().encodeToString(cipherText);
  return cipherText;
</code></pre>

<p>What can be the reason? Does AES add some data?</p>
"	NULL	5	NULL	42:20.3	2	22:15.4	NULL	NULL	0	0	0	1	0	<java><encryption><cryptography><byte><aes>	Why does AES 128 encryption expanding the data?	130	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
36397356	36410337	1	"<p>I'm trying to decrypt some text and I get an error:</p>

<blockquote>
  <p>javax.crypto.BadPaddingException: error:06065064:digital envelope
   routines:EVP_DecryptFinal_ex:bad decrypt
   com.android.org.conscrypt.NativeCrypto.EVP_CipherFinal_ex(Native
   Method)  com.android.org.conscrypt.OpenSSLCipher.doFinalInternal(OpenSSLCipher.java:430)
  com.android.org.conscrypt.OpenSSLCipher.engineDoFinal(OpenSSLCipher.java:466)javax.crypto.Cipher.doFinal(Cipher.java:1340)</p>
</blockquote>

<pre><code>import android.util.Base64;

import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class AESEncrypter {

    private static final byte[] SALT = {
            (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,
            (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03
    };
    private static final int ITERATION_COUNT = 65536;
    private static final int KEY_LENGTH = 256;
    private Cipher ecipher;
    private Cipher dcipher;

    public AESEncrypter(String passPhrase) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT, KEY_LENGTH);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); // ""AES/CBC/NoPadding""
        ecipher.init(Cipher.ENCRYPT_MODE, secret);

        dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] iv = ecipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
        dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    }

    public String encrypt(String encrypt) throws Exception {
        encrypt = encrypt.replace(""\n"", """");

        byte[] bytes = encrypt.getBytes(""UTF8"");
        byte[] encrypted = encrypt(bytes);
        return Base64.encodeToString(encrypted, Base64.DEFAULT);
    }

    public byte[] encrypt(byte[] plain) throws Exception {
        return ecipher.doFinal(plain);
    }

    public String decrypt(String encrypt) throws Exception {
        encrypt = encrypt.replace(""\n"", """");
        byte[] bytes = Base64.decode(encrypt, Base64.DEFAULT);
        byte[] decrypted = decrypt(bytes);
        return new String(decrypted, ""UTF8"");
    }

    public byte[] decrypt(byte[] encrypt) throws Exception {
        return dcipher.doFinal(encrypt);
    }

}
</code></pre>

<p>Any suggestions?</p>
"	NULL	8	NULL	02:45.0	4	58:06.7	58:06.7	NULL	3787519	5969121	0	1	1	<java><android><encryption><cryptography><aes>	"Java Android, error when decoding AES-256"	2522	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
36839254	36844556	2	"<p>I am encrypting a file in Java and need to decrypt it at client side.
This is the <strong>server side</strong> code:</p>

<pre><code>Key secretKey = new SecretKeySpec(""mysecretmysecret"".getBytes(), ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
byte[] outputBytes = cipher.doFinal(read(sampleFile));
return outputBytes;
</code></pre>

<p>At client side I use Ajax request to fetch the file and use CryptoJS AES:</p>

<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', 'file', true);
xhr.responseType = 'arraybuffer';

xhr.onload = function (e) {
        var encryptedData = this.response;
        var decrypted = CryptoJS.AES.decrypt(encryptedData, ""mysecretmysecret"");
        console.log(decrypted);
};
xhr.send();
</code></pre>

<p>But this does not decrypt the file. I get this printed as value of decrypted in the console:</p>

<pre><code>Wy.init {words: Array[0], sigBytes: 0}
</code></pre>

<p>I have also tried converting arraybuffer to WordArray suggested <a href=""https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer"">here</a> but still the same result.
I would be more than glad if someone could point me in the right direction and tell me what I did wrong.</p>

<p><strong>Edit 1:</strong>
I have solved the issue. The code I used is posted as an answer.</p>
"	NULL	5	NULL	27:53.8	3	53:28.9	17:27.7	NULL	-1	2281800	0	1	3	<java><encryption><cryptography><aes><cryptojs>	CryptoJS decrypting (AES) a file bytearray coming from Java	3915	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37016483	37030469	1	"<p>I have the following code to define a cipher class</p>

<pre><code>import java.util.*;
import javax.crypto.Cipher;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
import java.security.AlgorithmParameters;
import javax.crypto.*;
import javax.crypto.SecretKeyFactory;
import javax.crypto.SecretKey;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class Cipher{
    private SecureRandom rand;
    private SecretKeyFactory kFact;
    private Cipher AESCipher;
    private SecretKey key;

    public Cipher(char[] mpw, byte[] salt){
            try{
                    kFact = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
                    rand = SecureRandom.getInstance(""SHA1PRNG"");
                    AESCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                    PBEKeySpec spec = new PBEKeySpec(mpw, salt, 1024, 256);
                    key = new SecretKeySpec(kFact.generateSecret(spec).getEncoded(),""AES"");
            }catch(Exception e){
                    System.out.println(""no such algorithm"");
            }
    }
    /*Henc[k,m] will return c such that Hdec[k,HEnc[k,m]] = m
     */
    public ArrayList&lt;byte[]&gt; HEnc(byte[] message) throws Exception{
            ArrayList&lt;byte[]&gt; res = new ArrayList&lt;byte[]&gt;(2);
            AESCipher.init(Cipher.ENCRYPT_MODE ,key);
            AlgorithmParameters params = AESCipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
            byte[] ctxt = AESCipher.doFinal(message);
            res.add(0,iv);
            res.add(1,ctxt);
            return res;
    }
    public byte[] HDec(byte[] iv, byte[] cipher) throws Exception{
            AESCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv) );
            System.out.println(""decrypting"");
            return AESCipher.doFinal(cipher);
    }
    /*public abstract byte[] HDec(SecretKey k, byte[] cipher);
    */
</code></pre>

<p>I am interested in decrypting cipher-text with incorrect passwords, to do so i defined the following test class,</p>

<pre><code>import java.util.*;
import java.io.*;

public class testCipher{
    public static void main(String[] args) throws Exception{
            while(true){
                    Scanner sc = new Scanner(System.in);
                    System.out.println(""Enter master password"");
                    String pass = sc.nextLine();
                    System.out.println(""Enter incorrect password"");
                    String fakepass = sc.nextLine();
                    System.out.println(""Enter message to encrypt"");
                    String message = sc.next();
                    String salt = ""123"";
                    HCipher goodEnc = new HCipher(pass.toCharArray(),salt.getBytes());
                    HCipher badEnc = new HCipher(fakepass.toCharArray(),salt.getBytes());
                    byte[] toEncrypt = message.getBytes();
                    ArrayList&lt;byte[]&gt; cipher = goodEnc.HEnc(toEncrypt);
                    byte[] ciphertxt = cipher.get(1);
                    byte[] iv = cipher.get(0);

                    while(true){
                            System.out.println(""Enter 1 to decrypt with correct pass, 2 to decrypt with incorrect pass and 0 to end simulation"");
                            int i = sc.nextInt();
                            if(i == 1){
                                    System.out.println(""Decrypting with correct password"");
                                    byte[] plaintxt = goodEnc.HDec(iv, ciphertxt);
                                    System.out.println(new String(plaintxt));
                            }
                            if(i == 2){
                                    System.out.println(""Decrypting with incorrect password"");
                                    byte[] plaintxt = badEnc.HDec(iv, ciphertxt);
                                    System.out.println(new String(plaintxt));

                            }
                            if(i == 0){
                                    break;
                            }
                    }
            }
    }
}
</code></pre>

<p>Encrypting and Decrypting using the correct password works well.  However, when I try to decrypt using an incorrect password, I get the follwing error:</p>

<pre><code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:420)
at javax.crypto.Cipher.doFinal(Cipher.java:1966)
at HCipher.HDec(HCipher.java:54)
at testCipher.main(testCipher.java:52)
</code></pre>

<p>I am guessing it has something to do with my IV but im not sure how to fix it.  Does anyone have any suggestions?</p>
"	NULL	0	NULL	22:25.9	3	18:27.8	NULL	NULL	0	5040972	0	1	-1	<encryption><aes><password-encryption>	"Decrypting with the wrong password, final block not properly padded"	605	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37139036	37140160	2	"<p>How can I switch between <code>AES-128</code>, <code>AES-192</code> and <code>AES-256</code>. My present implementation uses only <code>AES-128</code></p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
IvParameterSpec ivspec = new IvParameterSpec(initialztnVector);
cipher.init(Cipher.ENCRYPT_MODE, key, ivspec);
byte[] enc = cipher.doFinal(toEncrypt);
</code></pre>

<p>Changing to <code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");</code> </p>

<p>Will it make <code>AES-256</code> possible ? What should I do to have <code>AES-192</code></p>
"	NULL	1	NULL	47:54.2	3	46:19.1	NULL	NULL	0	3104485	0	1	1	<java><encryption><cryptography><aes>	"How to switch between AES-128, AES-192 and AES-256"	1725	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37248569	37311108	3	"<p>I am trying to implement AES 256 bit CBC algorithm in java. I want to make something like this. <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow noreferrer"">Click here</a></p>

<p>Below is the picture for sample run.
<a href=""https://i.stack.imgur.com/RPfFE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RPfFE.png"" alt=""Sample Run""></a></p>

<p>I am using below program from multiple SO threads , following is the code I am using to encrypt/decrypt. Updated the code as per @dave_thompson suggestion but still same error for length of IV.</p>

<pre><code>import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Scanner;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};
    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {
        Scanner in = new Scanner(System.in);
        salt = getSalt();
        String s = in.nextLine();
        char[] message = s.toCharArray();

        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}
</code></pre>

<p>Problem with current code shows me the following error, but if I change IV back to 16bit it works.</p>

<p>Following are the SO threads I am referring to.</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">Java 256-bit AES Password-Based Encryption</a></li>
<li><a href=""https://stackoverflow.com/questions/901251/decrypting-data-with-aes-cbc-pkcs5padding-using-blackberry"">decrypting data with AES/CBC/PKCS5Padding using blackberry</a></li>
<li><a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">Java 256-bit AES Password-Based Encryption</a>
<a href=""https://i.stack.imgur.com/MUfzQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MUfzQ.png"" alt=""enter image description here""></a></li>
</ul>
"	NULL	4	NULL	14:19.0	3	47:22.1	32:31.7	NULL	-1	1616317	0	1	-1	<java><encryption><cryptography><aes>	how to implement AES 128bit with CBC (with 32bit IV and key)in java?	8845	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37253622	37253886	2	"<p>I am pretty new in Java Cryptography.I have provided with the following PHP code to decrypt a AES-256 / CBC / ZeroBytePadding encrypted object.</p>

<pre><code>function decrypt($key, $data)
{
    if (!in_array(strlen($key), array(32, 48, 64)))
{
    throw new Exception(""Invalid key"");
}

$key_hex = pack('H*', $key);

$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);

$ciphertext = base64_decode($data);

# retrieves the IV, iv_size should be created using mcrypt_get_iv_size()
$iv_dec = substr($ciphertext, 0, $iv_size);

# retrieves the cipher text (everything except the $iv_size in the front)
$ciphertext_dec = substr($ciphertext, $iv_size);

# may remove 00h valued characters from end of plain text
$result = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key_hex, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);

return $result;
}
</code></pre>

<p>I need to do the same in java. After lots of searching I have made the following code:</p>

<pre><code> public String decrypt(byte key[], String encrypted)
            throws GeneralSecurityException {
        if (key.length != 32 || key.length != 48 || key.length != 64) {
            throw new IllegalArgumentException(""Invalid key size."");
        }
    byte[] ciphertextBytes = Base64.decodeBase64(encrypted.getBytes());

    // Need to find the IV length here. I am using 16 here

    IvParameterSpec iv = new IvParameterSpec(ciphertextBytes, 0, 16);
    ciphertextBytes = Arrays.copyOfRange(ciphertextBytes, 16,
            ciphertextBytes.length);

    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
    byte[] original = cipher.doFinal(ciphertextBytes);

    // remove zero bytes at the end
    int lastLength = original.length;
    for (int i = original.length - 1; i &gt; original.length - 16; i--) {
        if (original[i] == (byte) 0) {
            lastLength--;
        } else {
            break;
        }
    }

    return new String(original, 0, lastLength);
}
</code></pre>

<p>But I need to find the IV length here. In PHP they are doing this using:
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
How to implement it in java? Can anybody help me please?</p>

<p>I am calling the method like this:</p>

<pre><code>public static void main(String args[]) {
        String key =     ""F5D4471791B79B6360C1EFF4A76250C1D7E5C23F5E4C3C43893B6CCAA796E307"";
        String encrypted =     ""F4N8SvpF1zgyMnQKwLlX\\/Dfgsj4kU58pg3kaSrt+AJt9D7\\/3vAfngegtytAdCUwwkQ2nxj8PVABRy0aaeBfsJN9n2Ltco6oPjdcmx8eOI"";

    try {
        String decrypted = decrypt(Hex.decodeHex(key.toCharArray()), encrypted);
        System.out.println(decrypted);
    } catch (GeneralSecurityException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}
</code></pre>
"	NULL	2	NULL	10:30.1	3	27:34.3	25:49.5	NULL	2134441	2134441	0	1	0	<java><php><encryption><aes><initialization-vector>	How to decode a AES-256 / CBC / ZeroBytePadding encrypted object	2300	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37274768	37315137	1	"<p>I am trying to encrypt and then decrypt audio file . Everything goes right but when I try to decrypt the encrypted audio , everytime I got this exception </p>

<p>javax.crypto.BadPaddingException: pad block corrupted</p>

<p>My MainActivity is like this: I want to decrypt and play the song side by side </p>

<pre><code>public class MainActivity extends Activity{

private final String KEY = ""abc"";
Button btn_Dec, btn_In;
byte[] incrept;
byte[] decrpt;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    ctx = this;
    btn_Dec = (Button) findViewById(R.id.button2);
    btn_In = (Button) findViewById(R.id.button1);
    btn_Dec.setOnClickListener(btnDecListner);
    btn_In.setOnClickListener(btnInListner);

}

public OnClickListener btnDecListner = new OnClickListener() {
    public void onClick(View v) {
        VincentFileCrypto simpleCrypto = new VincentFileCrypto();
        try {
            // decrypt the file here first argument is key and second is encrypted file which we get from SD card.
            decrpt = simpleCrypto.decrypt(KEY, getAudioFileFromSdCard());
            //play decrypted audio file.
            playMp3(decrpt);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

};
Context ctx;
public OnClickListener btnInListner = new OnClickListener() {
    public void onClick(View v) {
        VincentFileCrypto simpleCrypto = new VincentFileCrypto();
        try {
            // encrypt audio file send as second argument and corresponding key in first argument.
            incrept = simpleCrypto.encrypt(KEY, getAudioFile());
            //Store encrypted file in SD card of your mobile with name vincent.mp3.
            FileOutputStream fos = new FileOutputStream(new File(""/sdcard/vincent.mp3""));
            fos.write(incrept);
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();

        }

    }

};


/**
 * @return byte array for encryption.
 * @throws FileNotFoundException
 */


public byte[] getAudioFile() throws FileNotFoundException

{

    byte[] audio_data = null;

    byte[] inarry = null;


    AssetManager am = ctx.getAssets();

    try {

        InputStream is = am.open(""Sleep Away.mp3""); // use recorded file instead of getting file from assets folder.

        int length = is.available();

        audio_data = new byte[length];


        int bytesRead;

        ByteArrayOutputStream output = new ByteArrayOutputStream();

        while ((bytesRead = is.read(audio_data)) != -1)

        {

            output.write(audio_data, 0, bytesRead);

        }

        inarry = output.toByteArray();


    } catch (IOException e) {

        // TODO Auto-generated catch block

        e.printStackTrace();

    }


    return inarry;

}


/**
 * This method fetch encrypted file which is save in sd card and convert it in byte array after that this  file will be decrept.
 *
 * @return byte array of encrypted data for decription.
 * @throws FileNotFoundException
 */

public byte[] getAudioFileFromSdCard() throws FileNotFoundException
{
    byte[] inarry = null;
    try {
        //getting root path where encrypted file is stored.
        File sdcard = Environment.getExternalStorageDirectory();
        File file = new File(sdcard, ""vincent.mp3""); //Creating file object
        //Convert file into array of bytes.
        FileInputStream fileInputStream = null;
        byte[] bFile = new byte[(int) file.length()];
        fileInputStream = new FileInputStream(file);
        fileInputStream.read(bFile);
        fileInputStream.close();
        inarry = bFile;
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return inarry;

}


/**
 * This Method is used to play audio file after decrepting.
 *
 * @param mp3SoundByteArray : This is our audio file which will be play and it converted in byte array.
 */

private void playMp3(byte[] mp3SoundByteArray) {

    try {
        // create temp file that will hold byte array
        File tempMp3 = File.createTempFile(""kurchina"", ""mp3"", getCacheDir());
        tempMp3.deleteOnExit();
        FileOutputStream fos = new FileOutputStream(tempMp3);
        fos.write(mp3SoundByteArray);
        fos.close();
        // Tried reusing instance of media player
        // but that resulted in system crashes...
        MediaPlayer mediaPlayer = new MediaPlayer();
        FileInputStream fis = new FileInputStream(tempMp3);
        mediaPlayer.setDataSource(fis.getFD());
        mediaPlayer.prepareAsync();
        mediaPlayer.start();
    } catch (IOException ex) {
        ex.printStackTrace();

    }

}
</code></pre>

<p>}</p>

<p>The encryption and decryption methods are mentioned in this class</p>

<pre><code>public class VincentFileCrypto {

public  byte[] encrypt(String seed, byte[] cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext);
    //  return toHex(result);
    return result;
}

public  byte[] decrypt(String seed, byte[] encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = encrypted;
    byte[] result = decrypt(rawKey, enc);
    return result;
}

//done
private  byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}

private  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

}
</code></pre>
"	NULL	0	NULL	25:45.4	21	35:57.1	13:04.6	NULL	3531756	4067548	0	1	17	<android>	how to encrypt and decrypt audio file android	15383	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37368710	37368832	2	"<p>I generate 128bit <code>AES/CBC/PKCS5Padding</code> key using Java <code>javax.crypto</code> API. Here is the algorithm that I use:</p>

<pre><code>public static String encryptAES(String data, String secretKey) {
    try {
        byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)
                .toString().substring(0, 16)
                .getBytes(Charsets.UTF_8);

        final SecretKey secret = new SecretKeySpec(secretKeys, ""AES"");

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);

        final AlgorithmParameters params = cipher.getParameters();

        final byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        final byte[] cipherText = cipher.doFinal(data.getBytes(Charsets.UTF_8));

        return DatatypeConverter.printHexBinary(iv) + DatatypeConverter.printHexBinary(cipherText);
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}


public static String decryptAES(String data, String secretKey) {
    try {
        byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)
                .toString().substring(0, 16)
                .getBytes(Charsets.UTF_8);

        // grab first 16 bytes - that's the IV
        String hexedIv = data.substring(0, 32);

        // grab everything else - that's the cipher-text (encrypted message)
        String hexedCipherText = data.substring(32);

        byte[] iv = DatatypeConverter.parseHexBinary(hexedIv);
        byte[] cipherText = DatatypeConverter.parseHexBinary(hexedCipherText);

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secretKeys, ""AES""), new IvParameterSpec(iv));

        return new String(cipher.doFinal(cipherText), Charsets.UTF_8);
    } catch (BadPaddingException e) {
        throw new IllegalArgumentException(""Secret key is invalid"");
    }catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
</code></pre>

<p>I can easily encrypt and decrypt messages using secretKey with these methods. Since Java has 128bit AES encryption by default, it generates a hash of the original secret key with SHA1 and takes the first 16-bytes of the hash to use it as secret key in AES. Then it dumps the IV and cipherText in HEX format.</p>

<p>For example <code>encryptAES(""test"", ""test"")</code> generates <code>CB5E759CE5FEAFEFCC9BABBFD84DC80C0291ED4917CF1402FF03B8E12716E44C</code> and I want to decrypt this key with CryptoJS.</p>

<p>Here is my attempt:</p>

<pre><code>var str = 'CB5E759CE5FEAFEFCC9BABBFD84DC80C0291ED4917CF1402FF03B8E12716E44C';

CryptJS.AES.decrypt( 
CryptJS.enc.Hex.parse(str.substring(32)),
CryptJS.SHA1(""test"").toString().substring(0,16),  
{
  iv: CryptJS.enc.Hex.parse(str.substring(0,32)),
  mode: CryptJS.mode.CBC,
  formatter: CryptJS.enc.Hex, 
  blockSize: 16,  
  padding: CryptJS.pad.Pkcs7 
}).toString()
</code></pre>

<p>However it returns an empty string. </p>
"	NULL	4	NULL	42:12.0	4	05:01.3	NULL	NULL	0	689144	0	1	1	<java><cryptography><aes><cryptojs><javax.crypto>	Decrypt AES/CBC/PKCS5Padding with CryptoJS	11736	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37671623	0	2	"<p>I'm trying to convert JAVA Code into Objective - C language. I have a requirement where I should Use the same code that Android developers are using. Code follows as</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;



public class EncDec {

    public static void main(String args[])
    {


        String reqMessage=""{\""accountType\"":\""ALL\"",\""uId\"":\""c8ff46be-a083-4009-8a33-fc2d22cc40e3|123456784\"",\""deviceId\"":\""qvxy1234\""}"";
        Map requestMap=new HashMap();
        requestMap.put(""body"", reqMessage);
        String bodyString=(String) requestMap.get(""body"");
        String authKey=""M/98hZivBqJQftMHsPvMgg&amp;&amp;"";

         String encString= encode(authKey,bodyString);
         System.out.println(""encString ::: ""+ encString);

         String decString= decode(authKey,encString);  
         System.out.println(""decString ::: ""+ decString);



    }
    public static String encode(String keyString, String stringToEncode) throws NullPointerException {
        if (keyString.length() == 0 || keyString == null) {
            throw new NullPointerException(""Please give Password"");
        }

        if (stringToEncode.length() == 0 || stringToEncode == null) {
            throw new NullPointerException(""Please give text"");
        }

        try {
            SecretKeySpec skeySpec = getKey(keyString);
            byte[] clearText = stringToEncode.getBytes(""UTF8"");

            // IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID
            final byte[] iv = new byte[16];
            Arrays.fill(iv, (byte) 0x00);
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

            // Cipher is not thread safe
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);
            byte[] encryptedByte=cipher.doFinal(clearText); 
            String encrypedValue = new String(Base64.encodeBase64(encryptedByte));
           System.out.println(""Encrypted: "" + stringToEncode + "" -&gt; "" + encrypedValue);
            return encrypedValue;

        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
        return """";
    }

    /**
     * Decodes a String using AES-128 and Base64
     *
     * @param context
     * @param password
     * @param text
     * @return desoded String
     */
    public static String decode(String password, String text) throws NullPointerException {

        if (password.length() == 0 || password == null) {
            throw new NullPointerException(""Please give Password"");
        }

        if (text.length() == 0 || text == null) {
            throw new NullPointerException(""Please give text"");
        }

        try {
            SecretKey key = getKey(password);

            // IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID
            final byte[] iv = new byte[16];
            Arrays.fill(iv, (byte) 0x00);
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

            byte[] encrypedPwdBytes = Base64.decodeBase64(text.getBytes());
            // cipher is not thread safe
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
            byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));

            String decrypedValue = new String(decrypedValueBytes);
            System.out.println(""Decrypted: "" + text + "" -&gt; "" + decrypedValue);
            return decrypedValue;

        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        }
        return """";
    }

    /**
     * Generates a SecretKeySpec for given password
     *
     * @param password
     * @return SecretKeySpec
     * @throws UnsupportedEncodingException
     */
    private static SecretKeySpec getKey(String password) throws UnsupportedEncodingException {

        // You can change it to 256 if you wish
        int keyLength = 128;
        byte[] keyBytes = new byte[keyLength / 8];
        // explicitly fill with zeros
        Arrays.fill(keyBytes, (byte) 0x0);

        // if password is shorter then key length, it will be zero-padded
        // to key length
        byte[] passwordBytes = password.getBytes(""UTF-8"");
        int length = passwordBytes.length &lt; keyBytes.length ? passwordBytes.length : keyBytes.length;
        System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
        return key;
    }


}
</code></pre>

<p>So I want this to be converted in to Objective C. I don't know how to do this. Help me out in this !!</p>

<p>I have searched some code in JAVA And I tried of doing it. But the problem is it will give some other decrypted data but not the exact one that gives using this code. So If I convert the same thing I may get the exact code I guess.
People might be knowing JAVA as well as Objective c here. Those people can help me i guess.</p>
"	NULL	1	NULL	02:12.6	3	54:07.7	NULL	NULL	0	6250049	0	1	0	<java><android><ios><objective-c>	Hi I'm trying to do AES Encryption using JAVA Code Help me in converting?	210	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
37898824	37898970	1	"<p>I need to send some crypted data over REST. My crypter / decrypter class is as follows:</p>

<pre><code>public class AesCrypter {
    static String IV = ""AAAAAAAAAAAAAAAA"";
    static String aesKey = ""0123456789abcdef"";

    public static byte[] encrypt(String unecryptedText) throws Exception {
        Cipher encrypt = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
        SecretKeySpec key = new SecretKeySpec(aesKey.getBytes(""UTF-8""), ""AES"");
        encrypt.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(""UTF-8"")));
        return encrypt.doFinal(unecryptedText.getBytes(""UTF-8""));
    }

    public static String decrypt(String cryptedText) throws Exception{
        byte[] bytes = cryptedText.getBytes(StandardCharsets.UTF_8);
        Cipher decrypt = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
        SecretKeySpec key = new SecretKeySpec(aesKey.getBytes(""UTF-8""), ""AES"");
        decrypt.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(""UTF-8"")));
        return new String(decrypt.doFinal(bytes),""UTF-8""); // this line
    }
}
</code></pre>

<p>But I'm getting a <code>javax.crypto.BadPaddingException: Given final block not properly padded</code> on the decrypt method, console points out error to be on the line I commented with <code>// this line</code>.</p>

<p>What am I missing out here?</p>
"	NULL	4	NULL	48:05.5	2	04:18.9	NULL	NULL	0	512115	0	1	0	<java><encryption>	How to ensure crypted data to be properly decrypted?	194	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
38869230	38881778	1	"<p>I have a Java algorithm for AES encryption and decryption and have to realize the decryption in JavaScript.</p>

<pre class=""lang-java prettyprint-override""><code>public String encryptWithAES(String value, String key, String encoding) throws NoSuchAlgorithmException, NoSuchPaddingException, DecoderException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    byte[] keyBytes = Hex.decodeHex(key.toLowerCase().toCharArray());
    byte[] dataToSend = value.getBytes(encoding);
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec k = new SecretKeySpec(keyBytes, ""AES"");
    c.init(1, k);
    byte[] encryptedData = c.doFinal(dataToSend);
    return new String(Hex.encodeHex(encryptedData));
}

public String decryptAES(String encrypted, String key, String encoding) throws NoSuchAlgorithmException, NoSuchPaddingException, DecoderException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    byte[] keyBytes = Hex.decodeHex(key.toCharArray());
    byte[] encryptedData = Hex.decodeHex(encrypted.toCharArray());
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec k = new SecretKeySpec(keyBytes, ""AES"");
    c.init(2, k);
    byte[] dencryptedData = c.doFinal(encryptedData);
    return new String(dencryptedData, encoding);
}
</code></pre>

<p>I have found many examples in the Internet, but no one gave me a proper result.</p>

<p>Now I try decrypt with that code:</p>

<pre class=""lang-js prettyprint-override""><code>var algos = ['aes-128-cbc', 'aes-128-cfb', 'aes-128-cfb1', 'aes-128-cfb8', 'aes-128-ctr', 'aes-128-ecb', 'aes-128-gcm', 'aes-128-ofb', 'aes-128-xts', 'aes-256-cbc', 'aes-256-cfb', 'aes-256-cfb1', 'aes-256-cfb8', 'aes-256-ctr', 'aes-256-ecb', 'aes-256-gcm', 'aes-256-ofb', 'aes-256-xts', 'aes128', 'aes256'];
//var masterData - string like 'c07abe96dde490b3aba7d2f21a43ba94960619ff110ffb53433f0ff39f4cf138e48511b1fb4030'
//const ENCRYPTION_KEY - string like '94960619ff110ffb53433f0ff39f4cf1' with 32 symbols

function decrypt(text, algorithm) {
    var decipher = crypto.createDecipher(algorithm, ENCRYPTION_KEY);

    var dec = decipher.update(text, 'hex', 'utf8');

    dec += decipher.final('utf8');
    return dec;
}

algos.map(algo =&gt; {
    try {
        const dec = decrypt(masterData, algo);

        console.log(algo, dec);
    } catch (error) {
        console.log(algo, 'error', error);
    }
});
</code></pre>

<p>Encoded string is a JSON.</p>
"	NULL	2	NULL	22:43.9	2	17:50.1	17:50.1	NULL	1816580	6041289	0	1	0	<javascript><java><node.js><encryption><aes>	decryptAES from Java to node.js	758	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
39401521	39404398	2	"<p>I have this encrypting function:</p>

<pre><code>String Encrypt(String text, byte[] keyBytes) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CFB/PKCS5Padding"");
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(""AAAAAAAAAAAAAAAA"".getBytes(""UTF-8""));
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
    return Base64.encodeToString(results, Base64.URL_SAFE);
}
</code></pre>

<p>On most Android devices, it works properly. However, on some old devices (Note 3, LG G2, with Android 4.4) it does not encrypt as it should.</p>

<p>Here's the comparison between two devices. Note3 encryption is wrong and Nexus 6 is OK.</p>

<pre><code>Note 3
---------
String to encrypt: Hello, world
Encryption key: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
Encryption result bytes: [108, -63, -66, 117, 62, -78, -108, 22, 12, -128, 119, 22]
Encryption result Base64: bMG-dT6ylBYMgHcW

Nexus 6
---------
String to encrypt: Hello, world
Encryption key: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
Encryption result bytes: [108, -63, -66, 117, 62, -78, -108, 22, 12, -128, 119, 22, 89, -73, -23, 114]
Encryption result Base64: bMG-dT6ylBYMgHcWWbfpcg==
</code></pre>

<p>Is this a known bug? Anything I can do to fix the problem?</p>
"	NULL	0	NULL	17:41.2	3	26:50.0	NULL	NULL	0	325358	0	1	1	<android><encryption>	AES/CFB/PKCS5Padding behaving differently on different Android versions	907	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
39484455	39484568	1	"<p>I am trying to encrypt some data using <strong>AES Encryption and Decryption</strong> . In there, I created a <code>Cipher</code> with following paramters,</p>

<p>Algorithm name - AES</p>

<p>Mode - CBC mode</p>

<p>Padding - PKCS7</p>

<pre><code>Cipher aesCipherForEncryption = Cipher.getInstance(""AES/CBC/PKCS7PADDING"");
</code></pre>

<p>Following exception is throwing when I run my encryption code.</p>

<pre><code>No Such Algorithm exists java.security.NoSuchAlgorithmException: Cannot find any provider supporting DES/CBC/PKCS7Padding.
</code></pre>

<p>This is my source code,</p>

<pre><code>    String strDataToEncrypt = new String();
    String strCipherText = new String();
    String strDecryptedText = new String();

    try {
        KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();

        final int AES_KEYLENGTH = 128;  
        byte[] iv = new byte[AES_KEYLENGTH / 8];    
        SecureRandom prng = new SecureRandom();
        prng.nextBytes(iv);

        Cipher aesCipherForEncryption = Cipher.getInstance(""AES/CBC/PKCS7PADDING"");

        aesCipherForEncryption.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));

        strDataToEncrypt = ""Hello World of Encryption using AES "";
        byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();
        byte[] byteCipherText = aesCipherForEncryption.doFinal(byteDataToEncrypt);

        strCipherText = new BASE64Encoder().encode(byteCipherText);
        System.out.println(""Cipher Text generated using AES is "" + strCipherText);


        Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS7PADDING""); 

        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);
        strDecryptedText = new String(byteDecryptedText);

        System.out.println("" Decrypted Text message is "" + strDecryptedText);

    } catch (NoSuchAlgorithmException noSuchAlgo) {
        System.out.println("" No Such Algorithm exists "" + noSuchAlgo);
    } catch (NoSuchPaddingException noSuchPad) {
        System.out.println("" No Such Padding exists "" + noSuchPad);
    } catch (InvalidKeyException invalidKey) {
        System.out.println("" Invalid Key "" + invalidKey);
    } catch (BadPaddingException badPadding) {
        System.out.println("" Bad Padding "" + badPadding);
    } catch (IllegalBlockSizeException illegalBlockSize) {
        System.out.println("" Illegal Block Size "" + illegalBlockSize);
    } catch (InvalidAlgorithmParameterException invalidParam) {
        System.out.println("" Invalid Parameter "" + invalidParam);
    }
</code></pre>

<p>But this is working with <strong>PKCS5</strong> with same parameters in <code>Cipher</code></p>

<p>Have any ideas ?</p>
"	NULL	1	NULL	10:10.0	3	10:56.2	10:56.2	NULL	1816580	4924272	0	1	0	<java><security><encryption><cryptography>	Java Encryption: NoSuchAlgorithmException error	3012	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
39497369	39500138	1	"<p>I am trying to encrypt a huge .txt file, The problem is the decryption is very slow, I tried AES,DES,3DES,BlowFish algorithms with different modes but the decryption still slow  </p>

<p>here is my code :</p>

<pre><code>static
{
    try
    {
        //ciphers initialization 

        SecretKey secretKey = THE_KEY;

        //Decryption cipher
        Cipher dec = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] ivDec = new byte[dec.getBlockSize()];
        IvParameterSpec ivparDec = new IvParameterSpec(ivDec);
        dec.init(Cipher.DECRYPT_MODE, secretKey,ivparDec);

        //Encryption cipher
        Cipher enc = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] iv = new byte[enc.getBlockSize()];
        IvParameterSpec ivpar = new IvParameterSpec(iv);
        enc.init(Cipher.ENCRYPT_MODE, secretKey,ivpar);
    }
    catch (Exception e){e.printStackTrace();}
}
</code></pre>

<p>Here is the encrypt/decrypt methods :</p>

<pre><code>public static String encrypt (String data)
{   
    String encData = null;
    byte [] arr = null;
    try
    {
        arr = enc.doFinal(data.getBytes(""UTF-8""));
        //convert to base 64
        String base64 = Base64.encodeBase64String(arr);
        encData = base64;
    }
    catch(Exception e){e.printStackTrace();}
    return encData;
}
public static String decrypt (String data)
{   
    String decData = null;
    byte [] arr = null;
    try
    {
        //convert base64 to bytes[] 
        byte[] base64 = Base64.decodeBase64(data);
        arr = dec.doFinal(base64);
        decData = new String(arr,Charset.forName(""UTF-8""));
    }
    catch(Exception e){e.printStackTrace();}
    return decData;
}
</code></pre>

<p>How can I improve the performance of this code ?</p>
"	NULL	9	NULL	33:28.5	0	47:21.2	26:01.4	NULL	6819716	6819716	0	1	0	<java><security><encryption><cryptography>	java Encryption performance	2180	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
39733712	39736122	1	"<p>I'm trying to decrypt an AES-ECB 128 encrypted string. That string was not encrypted with Java, I receive it as an input in Java and I want to decrypt it.</p>

<p>I've encrypted the message ""0123456789012345"" in Arduino with AESLib </p>

<pre><code>  uint8_t key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
  char data[] = ""0123456789012345""; //16 chars == 16 bytes
  aes128_enc_single(key, data);
</code></pre>

<p>The string in encrypted form is ""1425EC9B5D983FF7DF45A4A8089E69FC"".</p>

<p>That's what I do in java to decrypt it:</p>

<pre><code>private static byte[] key = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15};

 public static String decrypt()
   {

       byte[] info= hexStrToByteArray(""1425EC9B5D983FF7DF45A4A8089E69FC""); 
       try
       {
           Cipher cipher = Cipher.getInstance(""AES/ECB/NOPADDING"");
           final SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");
           cipher.init(Cipher.DECRYPT_MODE, secretKey);
           byte[] decryptedResult= cipher.doFinal(info);
           String result = new String(result, ""UTF-8"");
           return result;
       }
       catch (Exception e)
       {
         e.printStackTrace();

       }
       return null;
   }


  private static byte[] hexStrToByteArray(String hex) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream(hex.length() / 2);

        for (int i = 0; i &lt; hex.length(); i += 2) {
            String output = hex.substring(i, i + 2);
            int decimal = Integer.parseInt(output, 16);
            baos.write(decimal);
        }
        return baos.toByteArray();
    }
</code></pre>

<p>what I get from this function is: .1?@JY?y??v?</p>

<p>I guess is a problem of encodings. How can I get the result of the decryption in a readable form?</p>

<p>Thank you!</p>
"	NULL	4	NULL	27:03.3	1	10:14.3	47:36.4	NULL	6890137	6890137	0	1	1	<java><encryption><aes>	I get strange characters when performing AES decryption in Java	1251	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
39750298	0	0	"<p>I know that when you first look on the title you said that it had been asked a hundred time before.
But no this is different, at least the way I coded this.
I used this <a href=""https://trivedihardik.wordpress.com/2014/09/04/securely-store-user-credentials/"" rel=""nofollow"">code</a> to encrypt/decrypt my data.</p>

<pre><code>import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESHelper {
public static String encrypt(String seed, String cleartext)
        throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted)
        throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}

private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}

private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted)
        throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt) {
    return toHex(txt.getBytes());
}

public static String fromHex(String hex) {
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString) {
    int len = hexString.length() / 2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),
                16).byteValue();
    return result;
}

public static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2 * buf.length);
    for (int i = 0; i &lt; buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}

private final static String HEX = ""0123456789ABCDEF"";

private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f));
}

}
</code></pre>

<p>Actually, Encryption goes so fine. My problem goes with the decryption that returns <strong>BadPaddingException: pad block corrupted</strong>.
I am so new to this whole security thing and I really hope you could help.
Thanks :)</p>
"	NULL	5	NULL	22:51.1	2	22:51.1	NULL	NULL	0	5164643	0	1	0	<android><security><encryption><cryptography><aes>	Android AES encryption/decryption pad lock corrupted	189	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
40050594	40052708	1	"<p>I am trying to inline my IV, so that I can decrypt my message without knowing the initial IV, just the secret key.</p>

<p>I generate my key.
I generate my IV with SecureRandom
I randominze the IV byte array.
(I create a message with the iv+message)
And finally, I encrypt the message with the unique IV.</p>

<p>As expected, I can decrypt the message if I remove the IV on the receiving end.
However, the generated cipher text is always the same.</p>

<p>I am at a loss as to why this is and have yet to find a solution online.</p>

<p>Below is my code and output.</p>

<p>Can anyone help me understand why this is?</p>

<pre><code>enter code 
  String mssg = ""Hello hellow hello"";
        byte[] key = ""kljhn1234512345abcde123451234512"".getBytes();
        SecretKeySpec spec = new SecretKeySpec(key, ""AES"");

        SecureRandom rand = new SecureRandom();
        for (int i = 0; i &lt; 5; i++) {

            //
            //initialzize empty byte array for random IV

            byte[] iv = new byte[16];
            System.out.println(""IV pre rand: "" + Arrays.toString(iv));
            rand.nextBytes(iv); //RANDOMIZE
            System.out.println(""IV POST rand: "" + Arrays.toString(iv));

            //CONCATENTATE IV TO FRONT OF MESSAGE TO ENCRYPT
            //CONCATENATE MESSAGE TO END OF IV

            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            try {
                bout.write(iv);
                bout.write(mssg.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }

            byte[] message = bout.toByteArray();

            try {

                //ENCRYPT USING RANDIMIZED IV.. THIS SHOULD RESULT IN NON EQUAL CIPHER TEXT FOR SAME MESSAGE.
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                cipher.init(Cipher.ENCRYPT_MODE, spec, new IvParameterSpec(iv));
                byte[] ct = cipher.doFinal(message);
                System.out.println(""CIPHER TEXT: "" + Arrays.toString(ct));

                //DECRYPT. AND USING A WRONG IV.
                cipher.init(Cipher.DECRYPT_MODE, spec, new IvParameterSpec(new byte[16]));
                System.out.println(""DECRYPTED: "" + new String(cipher.doFinal(ct)));

            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                e.printStackTrace();
            } catch (InvalidAlgorithmParameterException e) {
                e.printStackTrace();
            } catch (InvalidKeyException e) {
                e.printStackTrace();
            } catch (BadPaddingException e) {
                e.printStackTrace();
            } catch (IllegalBlockSizeException e) {
                e.printStackTrace();
            }


        }
</code></pre>

<p>here</p>

<p>And the output:</p>

<p>ITERATION 1
IV pre rand: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p>

<p>IV POST rand: [13, 68, 83, 113, 86, 48, 50, -71, -75, -25, 56, 100, -25, 34, -27, -23]</p>

<p>CIPHER TEXT: [-102, -52, -21, -92, -85, 119, -10, -18, -52, 0, -39, -19, 11, -83, 70, 44, 101, -92, -93, -60, 4, 73, -17, 73, -58, 119, 81, 66, -114, 54, -107, -83, 11, 42, -92, 121, -15, -61, 92, 83, 24, 10, 89, -21, 110, 100, 116, 119]</p>

<p>DECRYPTED: ????????????????????????????????Hello hellow hello</p>

<p>ITERATION 2:
IV pre rand: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p>

<p>IV POST rand: [90, 115, 91, 124, 27, -80, -32, -46, -66, -50, -85, 43, 34, -18, -74, -3]</p>

<p>CIPHER TEXT: [-102, -52, -21, -92, -85, 119, -10, -18, -52, 0, -39, -19, 11, -83, 70, 44, 101, -92, -93, -60, 4, 73, -17, 73, -58, 119, 81, 66, -114, 54, -107, -83, 11, 42, -92, 121, -15, -61, 92, 83, 24, 10, 89, -21, 110, 100, 116, 119]</p>

<p>DECRYPTED: ????????????????????????????????Hello hellow hello</p>

<p>ITERATION 3</p>

<p>IV pre rand: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p>

<p>IV POST rand: [113, 112, 9, 47, -125, -4, 80, 10, -97, 44, 42, 90, -58, -44, -46, 17]</p>

<p>CIPHER TEXT: [-102, -52, -21, -92, -85, 119, -10, -18, -52, 0, -39, -19, 11, -83, 70, 44, 101, -92, -93, -60, 4, 73, -17, 73, -58, 119, 81, 66, -114, 54, -107, -83, 11, 42, -92, 121, -15, -61, 92, 83, 24, 10, 89, -21, 110, 100, 116, 119]</p>

<p>DECRYPTED: ????????????????????????????????Hello hellow hello</p>
"	NULL	2	NULL	22:00.0	2	11:49.3	27:04.7	NULL	6939109	3302764	0	1	1	<java><encryption><aes>	Java AES CBC with Inline Secure Random IV - Produces same Cipher text?	2004	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
40772711	40774959	1	"<p>I am having problems with <code>keys AES</code> in Java</p>

<p>This is my code:</p>

<pre><code>public Core(String key) {
    try {
        this.SecretKey = key;
        this.ivspec = new IvParameterSpec(this.iv.getBytes());
        this.keyspec = new SecretKeySpec(SecretKey.getBytes(""UTF-8""), ""AES"");
        try {
            this.cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>Whenever I pass the String ""key"" that contains for example <code>Pizza</code>, it just generates errors. When I pass for example a String that contains precisely 16 bytes, it works. I would like to use AES, but I would not like it to only be limited to 16, 24 or 32 bytes. How can I fix this? </p>
"	NULL	1	NULL	29:55.1	3	38:00.3	37:22.2	NULL	7357920	6422820	0	1	0	<java><android><encryption><aes><secret-key>	"AES custom key instead of 16, 24 or 32 bytes"	1461	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
41286149	41287949	2	"<p>I am <code>reading</code> a <code>large file</code> in small-small <code>bytes</code> <code>chunks</code>. I am <code>encrypting</code> that file, chunk by chunk, using <code>AES 128 bit encryption</code> and <code>writing</code> each encrypted chunk into another file.  The File is <code>Encrypted</code> <code>successfully</code>. </p>

<p>But when I am <code>reading</code> that <code>encrypted</code> file back in small-small <code>bytes</code> <code>chunks</code> and trying to <code>decrypt</code> that file- chunk by chunk, it throws an Exception    </p>

<pre><code>java - javax.crypto.BadPaddingException: Given final block not properly padded 
</code></pre>

<p>But when I am trying to read the whole file and try to <code>decrypt</code> bytes, it <code>decryptes</code> successfully.    </p>

<p>Here is my code: </p>

<pre><code>import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.io.File;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * Created by Ashish Pancholi on 22-12-2016.
 */
public class EncryDecryPtion implements Securable{
    public static void main(String[] argu){
        EncryDecryPtion encryDecryPtion = new EncryDecryPtion();
        File file = new File(""shouldbeoriginal.jpg"");
        try {
            encryDecryPtion.encryptFile(file,""Pa$$w0rd"");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }

        File file_ = new File(""shouldbeoriginal.jpg"");
        try {
            encryDecryPtion.decryptFile(file_,""Pa$$w0rd"");
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }
} 




import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * Encrypt and decrypt file with AES algorithm
 * Created by Ashish Pancholi on 20-12-2016.
 */
public interface Securable {

    /**
     * Read and write the file in chunk.
     * Encrypts the chunks with AES algorithm.
     * It creates a new a file which having encrypted data,
     * deletes old original file and
     * rename a new file with the old file
     * @param file which is to be encrypted and password.
     */

    default File encryptFile(File file, String password) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
        String encryptedFilePath = file.getAbsolutePath() + "".ENCRYPTED"";
        File encryptedFile = new File(encryptedFilePath);
        encryptedFile.createNewFile();
        try
                (FileInputStream in = new FileInputStream(file)) {

            try
                    (OutputStream out = new FileOutputStream(encryptedFile)) {
                byte[] chunk = new byte[1024];
                int chunkLen = 0;
                while ((chunkLen = in.read(chunk)) != -1) {
                    byte[] encryptedChunk = aesEncryptionDecryption.encrypt(chunk);
                    out.write(encryptedChunk);
                }
            }
        }
        Path path_originalFile = Paths.get(file.getAbsolutePath());
        Path path_encryptedFile = Paths.get(encryptedFile.getAbsolutePath());
        try {
            Files.delete(path_originalFile);
        }catch (IOException ex){
            try {
                FileUtils.forceDelete(file);
            }catch (IOException ex1){
                //ignore
            }
        }
        Path path = Files.move(path_encryptedFile, path_originalFile);
        return path.toFile();
    }

    default File encryptWholeFile(File file, String password) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
        String encryptedFilePath = file.getAbsolutePath() + "".ENCRYPTED"";
        File encryptedFile = new File(encryptedFilePath);
        encryptedFile.createNewFile();
        try(FileInputStream in = new FileInputStream(file)) {
            byte[] bytes = IOUtils.toByteArray(in);
            byte[] encryptedChunk = aesEncryptionDecryption.encrypt(bytes);
            FileUtils.writeByteArrayToFile(encryptedFile, encryptedChunk);
        }
        Path path_originalFile = Paths.get(file.getAbsolutePath());
        Path path_encryptedFile = Paths.get(encryptedFile.getAbsolutePath());
        try {
            Files.delete(path_originalFile);
        }catch (IOException ex){
            try {
                FileUtils.forceDelete(file);
            }catch (IOException ex1){
                //ignore
            }
        }
        Path path = Files.move(path_encryptedFile, path_originalFile);
        return path.toFile();
    }

    /**
     * Read and write the file in chunk.
     * Encrypts the chunks with AES algorithm.
     * It creates a new a file which having encrypted data,
     * deletes old original file and
     * rename a new file with the old file
     * @param inputStream of file which is to be encrypted and a password.
     */
    default InputStream encryptFile(InputStream inputStream, String password) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        InputStream in;
        try {
            AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                byte[] chunk = new byte[1024];
                int chunkLen = 0;
                while ((chunkLen = inputStream.read(chunk)) != -1) {
                    byte[] encryptedChunk = aesEncryptionDecryption.encrypt(chunk);
                    baos.write(encryptedChunk);
                }
                baos.flush();
                in = new ByteArrayInputStream(baos.toByteArray());
            }
        }finally {
            inputStream.close();
        }
        return in;
    }

    /**
     * Read and write the file in chunk.
     * Encrypts the chunks with AES algorithm.
     * It creates a new a file which having encrypted data,
     * deletes old original file and
     * rename a new file with the old file
     * @param inputStream of file which is to be encrypted and a password.
     */
    default File encryptFile(InputStream inputStream, String password, String targetFileName) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        File encryptedFile = new File(targetFileName);
        try {
            AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
            encryptedFile.getParentFile().mkdirs();
            encryptedFile.createNewFile();
            try (OutputStream baos = new FileOutputStream(encryptedFile)) {
                byte[] chunk = new byte[1024];
                int chunkLen = 0;
                while ((chunkLen = inputStream.read(chunk)) != -1) {
                    byte[] encryptedChunk = aesEncryptionDecryption.encrypt(chunk);
                    baos.write(encryptedChunk);
                }
            }
        }finally {
            inputStream.close();
        }
        return encryptedFile;

    }

    /**
     * Read and write the file in chunk.
     * Decrypts the chunks with AES algorithm.
     * It creates a new a file which having decrypted data,
     * deletes old original encrypted file and
     * rename a new file with the old file
     * @param file which is to be decrypted and password.
     */

    default void decryptFile(File file, String password) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
        String decryptedFilePath = file.getAbsolutePath() + "".DECRYPTED"";
        File decryptedFile = new File(decryptedFilePath);
        decryptedFile.createNewFile();
        try
                (FileInputStream in = new FileInputStream(file)) {

            try
                    (OutputStream out = new FileOutputStream(decryptedFile)) {
                byte[] chunk = new byte[1024];
                int chunkLen = 0;
                while ((chunkLen = in.read(chunk)) != -1) {
                    byte[] encryptedChunk = aesEncryptionDecryption.decrypt(chunk);
                    out.write(encryptedChunk);
                }
            }
        }
        Path path_originalFile = Paths.get(file.getAbsolutePath());
        Path path_decryptedFile = Paths.get(decryptedFile.getAbsolutePath());
        try {
            Files.delete(path_originalFile);
        }catch (IOException ex){
            try {
                FileUtils.forceDelete(file);
            }catch (IOException ex1){
                //ignore
            }
        }
        Files.move(path_decryptedFile, path_originalFile);
    }

    default File decryptWholeFile(File file, String password) throws IOException, NoSuchAlgorithmException, IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchPaddingException {
        AESEncryptionDecryption aesEncryptionDecryption = new AESEncryptionDecryption(password);
        String decryptedFilePath = file.getAbsolutePath() + "".DECRYPTED"";
        File decryptedFile = new File(decryptedFilePath);
        decryptedFile.createNewFile();
        try(FileInputStream in = new FileInputStream(file)) {
                byte[] bytes = IOUtils.toByteArray(in);
                byte[] encryptedChunk = aesEncryptionDecryption.decrypt(bytes);
                FileUtils.writeByteArrayToFile(decryptedFile, encryptedChunk);
          }
        Path path_originalFile = Paths.get(file.getAbsolutePath());
        Path path_decryptedFile = Paths.get(decryptedFile.getAbsolutePath());
        try {
            Files.delete(path_originalFile);
        }catch (IOException ex){
            try {
                FileUtils.forceDelete(file);
            }catch (IOException ex1){
                //ignore
            }
        }
       Path path =  Files.move(path_decryptedFile, path_originalFile);
        return path.toFile();
    }

}


import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;


/**
 * Encrypt and decrypt file with AES algorithm
 * Created by Ashish Pancholi on 20-12-2016.
 */

public class AESEncryptionDecryption {

    private SecretKeySpec secretKey;
    private byte[] key;

    public AESEncryptionDecryption(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{
        MessageDigest sha = null;
        key = password.getBytes(""UTF-8"");
        sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16); // use only first 128 bit
        this.secretKey = new SecretKeySpec(key, ""AES"");
    }

    /**
     * Encrypts the file with AES algorithm
     * @param bytes of file which is to encrypted
     * @return byte[] which is encrypted bytes
     */
    public byte[] encrypt(byte[] bytes) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);
            byte[] encrytedBytes = cipher.doFinal(bytes);
            return encrytedBytes;

    }

    /**
     * Decrypts the file with AES algorithm
     * @param encrytedBytes of file that to be decrypted
     * @return byte[] which is original data.
     */
    public byte[] decrypt(byte[] encrytedBytes) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException
    {
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, this.secretKey);
        byte[] bytes = cipher.doFinal(encrytedBytes);
        return bytes;
    }
}
</code></pre>

<p>SO my Question is- <strong>How to encrypt a large file without loading the whole file in the memory?</strong> Please help. </p>

<p><strong>EDITED</strong></p>

<p>Here is the updated code but still I am getting the same exception on line <code>cipher.doFinal()</code> when decrypting: </p>

<pre><code>public void encrypt(File sourceFile, File targetFile) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, IOException {
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);
    try(InputStream inputStream = new FileInputStream(sourceFile)){
        try(OutputStream outputStream = new FileOutputStream(targetFile)){
            byte[] chunk = new byte[8192];
            int chunkLen = 0;
            while ((chunkLen = inputStream.read(chunk)) != -1) {
                byte[] encrytedBytes = cipher.update(chunk);
                outputStream.write(encrytedBytes);
            }
            byte[] finalBytes =  cipher.doFinal();
            if(finalBytes!=null) {
                outputStream.write(finalBytes);
            }
        }
    }
}

public void decrypt(File encryptedFile, File targetFile) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, IOException {
    Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, this.secretKey);
    try(InputStream inputStream = new FileInputStream(encryptedFile)){
        try(OutputStream outputStream = new FileOutputStream(targetFile)){
            byte[] chunk = new byte[8192];
            int chunkLen = 0;
            while ((chunkLen = inputStream.read(chunk)) != -1) {
                byte[] decrytedBytes = cipher.update(chunk);
                outputStream.write(decrytedBytes);
            }
            byte[] finalBytes =  cipher.doFinal();
            if(finalBytes!=null) {
                outputStream.write(finalBytes);
            }
        }
    }
}
</code></pre>
"	NULL	2	NULL	07:43.4	2	19:31.7	16:25.6	NULL	219865	219865	0	1	0	<java><file><encryption><memory-management><aes>	java - javax.crypto.BadPaddingException: Given final block not properly padded	9594	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
41432896	41434590	2	"<p>I'm only asking this because I have read many posts for 2 days now about crypto AES encryption, and just when I thought I was getting it, I realized I wasn't getting it at all.  </p>

<p>This post is the closest one to my issue, I have exactly the same problem but it is unanswered:</p>

<p><a href=""https://stackoverflow.com/questions/17780734/cryptojs-aes-encryption-and-java-aes-decryption-value-mismatch"">CryptoJS AES encryption and JAVA AES decryption value mismatch</a></p>

<p>I have tried doing it in many ways but I haven't gotten it right.</p>

<p><strong>First Off</strong></p>

<p><strong>I'm getting the already encrypted string (I only got the code to see how they were doing it), so modifying the encryption way is not an option. That's why all the similar questions aren't that useful to me.</strong></p>

<p><strong>Second</strong></p>

<p><strong>I do have access to the secret key and I can modify it (so adjusting length is an option if neccessary).</strong></p>

<p>The encryption is done on CryptoJS and they send the encrypted string as a GET parameter.</p>

<pre><code>GetParamsForAppUrl.prototype.generateUrlParams = function() {
const self = this;
 return new Promise((resolve, reject) =&gt; {
   const currentDateInMilliseconds = new Date().getTime();
   const secret = tokenSecret.secret;
   var encrypted = CryptoJS.AES.encrypt(self.authorization, secret);
   encrypted = encrypted.toString();
   self.urlParams = {
     token: encrypted,
     time: currentDateInMilliseconds
   };
   resolve();
 });
};
</code></pre>

<p>I can easily decrypt this on javascript using CryptoJS with:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted_string, secret);
    console.log(decrypted.toString(CryptoJS.enc.Utf8)); 
</code></pre>

<p>But I don't want to do this on Javascript, for security reasons, so I'm trying to decrypt this on Java:</p>

<pre><code>String secret = ""secret"";
byte[] cipherText = encrypted_string.getBytes(""UTF8"");
SecretKey secKey = new SecretKeySpec(secret.getBytes(), ""AES"");
Cipher aesCipher = Cipher.getInstance(""AES"");
aesCipher.init(Cipher.DECRYPT_MODE, secKey);
byte[] bytePlainText = aesCipher.doFinal(byteCipherText);
String myDecryptedText = = new String(bytePlainText);
</code></pre>

<p>Before I had any idea of what I was doing, I tried base64 decoding, adding some IV and a lot of stuff I read, of course none of it worked. </p>

<p>But after I started to understand, kinda, what I was doing, I wrote that simple script above, and got me the same error on the post: <strong>Invalid AES key length</strong></p>

<p>I don't know where to go from here. After reading a lot about this, the solution seems to be hashing or padding, but I have no control on the encryption method, so I can't really hash the secret or pad it.</p>

<p>But as I said, I can change the secret key so it can match some specific length, and I have tried changing it, but as I'm shooting in the dark here, I don't really know if this is the solution.</p>

<p>So, my question basically is, If I got the encrypted string (<strong>in javascript like the first script</strong>) and the secret key, is there a way to decrypt it (<strong>in Java</strong>)? If so, how to do it?</p>
"	NULL	2	NULL	26:18.9	11	46:38.8	24:37.1	NULL	-1	2958190	0	1	21	<java><encryption><cryptography><cryptojs>	CryptoJS AES encryption and Java AES decryption	40570	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
42235976	42236422	3	"<p>I'm trying to decrypt with AES some data. I've been given a 256 bit key and 16 byte IV like these:</p>

<pre><code>  String key = ""Hh1s1f4T2mpN3yCh4ngeL8t3r\\.Thxpp"";

  int[] v = {11, 1, 555, 222, 241, 21, 11, 33, 35, 91, 45, 6, 14, 30, 22, 234};

  String IV = Arrays.toString( v );
</code></pre>

<p>I've been told the padding should be PKCS7 but when I init the cipher with <code>AES/CBC/PKCS7PADDING</code> it says: <code>Cannot find any provider supporting AES/CBC/PKCS7PADDING</code></p>

<p>If I use <code>AES/CBC/PKCS5PADDING</code> I get <code>Illegal key size</code> but I've checked that the key size is 32.</p>

<pre><code>  public static String decrypt(String key, String initVector, String encrypted) {
    try {
        System.out.println( ""Key size: "" + key.getBytes(""UTF-8"").length ); 

        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

        byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

        return new String(original);
    } catch (Exception ex) {
        ex.printStackTrace();
    }

    return null;
 }
</code></pre>
"	19:25.6	0	NULL	52:15.9	3	33:42.2	NULL	NULL	0	1049004	0	1	2	<java><encryption><cryptography><aes>	JAVA AES 256 Decrypt	4208	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
42738641	42739447	2	"<p>I have an issue with Chinese string gotten from a MySQL database. This database has a default setup:</p>

<ul>
<li>character_set_database: latin1</li>
<li>information_schema: utf8</li>
<li>collation: utf8_general_ci</li>
</ul>

<p>For the schema I am working with:</p>

<ul>
<li>charset: latin1</li>
<li>collation: latin1_swedish_ci</li>
</ul>

<p>I have imported this database using an SQL dump.</p>

<p>The tables contain both Latin data and Chinese data. This is a worldwide database.</p>

<p>I can read all of them in Java.</p>

<p>My issue arise when I want to encrypt the data. I am using AES with Java crypto, and return the bytes in a string using <code>Base64.encode</code></p>

<p>Encryption runs fine. My issue is that when I encrypt the Chinese characters the encrypted string I am getting back is far too big (like 300 chars), although the Chinese text is only few characters long.</p>

<hr>

<p>The encryption code is like this</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, aesKey);
byte[] encrypted = cipher.doFinal(value.getBytes(""UTF-8""));

String encoded = Base64.encodeBase64String(encrypted);
return new String(encoded.getBytes(""UTF-8""));
</code></pre>

<hr>

<p>Do you have any idea why the encrypted value is so long?
Should I handle the Chinese values differently before encrypting them?</p>

<p>Addendum:</p>

<p>When I debug:
If I encrypt this:
????????????????</p>

<p>I get the result String String value = ENCR({FDDabCcaDabp6YSLYCzg/1MuSzt8QPGEEk3ymeAOW5vERBk+oN3bMSUV5bEbocifr216yqUCObrqDjrrhVwGDqzafWVbELpTQ==}_AB_DCD_)</p>

<p>When I call value.length I get 115. And 115 is just too long for my DB.</p>

<p>I think the chinese characters are more than two bytes long?
Is it a correct assumption?</p>

<p>Do you see the reason why I get length = 115?</p>

<p>Thanks</p>

<p>===================================
ADDENDUM 2</p>

<p>The code is:</p>

<pre><code>    try {
        String english = ""Rastapopoulos"";
        String chinese = ""????????????????"";
        String transformationKey = ""asdewqayxswedcvf"";
        Key aesKey = new SecretKeySpec(transformationKey.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, aesKey);

        byte[] encrypted1 = cipher.doFinal(english.getBytes(""UTF-8""));
        String encoded1 = Base64.encodeBase64String(encrypted1);

        byte[] encrypted2 = cipher.doFinal(chinese.getBytes(""UTF-8""));
        String encoded2 = Base64.encodeBase64String(encrypted2);

        System.out.println(""Original length: "" + english.length() + ""\tEncrypted length: "" + encoded1.length() + ""\t"" + encoded1);
        System.out.println(""Original length: "" + chinese.length() + ""\tEncrypted length: "" + encoded2.length() + ""\t"" + encoded2);
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>

<p>And gives me the following output</p>

<p>Original length: 13 Encrypted length: 24    V4y9u3tNQaH81BAcqi1XZg==
Original length: 16 Encrypted length: 88    KTMAxhqALAlXfjaOLsBlbj7jbqz+8M4F0AlvvUU5OmrvT+D7MGQHseYKm32V46bqyNbHtu91JC4sQ+mVoWp/wQ==</p>

<p>Which is similar from what you got</p>

<p>My issue is that I can't write it back to the DB because it is larger than the max length of the field.
But what I don't understand is why my english strings of 13-15 characters give me 24 bytes lenght, all the time, and why my 16 bytes of chinese characters give me a 88 bytes long encrypted value.</p>

<p>Where does this difference comes from?</p>

<p>The value in the DB are pretty small, less than 20 chars, so I should not have any issue at encrypting it. The result will always be less than 24 chars long.
So why is it different for chinese characters?</p>

<p>Thanks</p>
"	NULL	5	NULL	56:59.3	3	20:13.5	03:20.9	NULL	3956189	3956189	0	1	3	<java><mysql><encryption><unicode>	AES encryption issue for text consisting of Chinese characters	2622	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
42750869	42751013	2	"<p>I'm using an Encryption class for some data transfers.
I keep getting this error:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:811)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:676)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:313)
at javax.crypto.Cipher.doFinal(Cipher.java:2131)
at com.casadelgato.util.Encryption.decrypt(Encryption.java:138)
at com.casadelgato.util.Encryption.decryptBase64(Encryption.java:124)
at com.casadelgato.util.Encryption.decryptBase64ToString(Encryption.java:109)
at com.casadelgato.util.Encryption.main(Encryption.java:156)
</code></pre>

<p>The weird thing is, I don't get it if I'm running the decrypt with the same Encryption object I encrypted with.  I only get the error when a new Encryption object tries to decrypt.
I've reproduced this with the main() in the code below.</p>

<p>The 2nd decrypt call fails.
Apparently the ciphers hold state between sessions???</p>

<p>How do I fix this so that another program can decrypt what was encrypted elsewhere?</p>

<pre><code>package com.casadelgato.util;

import java.io.UnsupportedEncodingException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Encryption {
    private final byte[]        SALT    = {
                                (byte) 0x26, (byte) 0xe4, (byte) 0x11, (byte) 0xa3,
                                (byte) 0x07, (byte) 0xc6, (byte) 0x55, (byte) 0x42
    };

    private Cipher          ecipher;
    private Cipher          dcipher;

    public Encryption( String password) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException,
                            InvalidAlgorithmParameterException {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

        KeySpec spec = new PBEKeySpec(password.toCharArray(), SALT, 65536, 128);
        SecretKey tmp = factory.generateSecret(spec);
        System.out.println(""Encryption: "" + Arrays.toString(tmp.getEncoded()));

        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        ecipher.init(Cipher.ENCRYPT_MODE, secret);

        AlgorithmParameters params = ecipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

        dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    }

    /**
     * Encrypt the string and return the data encoded in base64
     *
     * @param encrypt String to encrypt
     * @return base64 coded encrypted string
     * @throws UnsupportedEncodingException
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws Exception
     */
    public byte[] encryptStringToBase64( String encrypt) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
        byte[] bytes = encrypt.getBytes(""UTF8"");
        return encryptToBase64(bytes);
    }

    /**
     * Encrypt a block of data and encode to Base64
     *
     * @param bytes
     * @return base64 encoded encrypted data
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws Exception
     */
    public byte[] encryptToBase64( byte[] bytes) throws IllegalBlockSizeException, BadPaddingException {
        byte[] encrypted = encrypt(bytes);
        return Base64.encodeBase64(encrypted);
    }

    /**
     * Encrypt a block of data
     *
     * @param plain
     * @return encryped data
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws Exception
     */
    public byte[] encrypt( byte[] plain) throws IllegalBlockSizeException, BadPaddingException {
        return ecipher.doFinal(plain);
    }

    /**
     * Decrypt a string that was encrypted and coded in base64
     *
     * @param base64
     * @return
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws UnsupportedEncodingException
     * @throws Exception
     */
    public String decryptBase64ToString( byte[] base64) throws IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {
        byte[] decrypted = decryptBase64(base64);
        return new String(decrypted, ""UTF8"");
    }

    /**
     * Decrypt a Base64 encoded block
     *
     * @param base64
     * @return
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws Exception
     */
    public byte[] decryptBase64( byte[] base64) throws IllegalBlockSizeException, BadPaddingException {
        byte[] decodedData = Base64.decodeBase64(base64);
        byte[] decrypted = decrypt(decodedData);
        return decrypted;
    }

    /**
     * Decrypt a binary array.
     *
     * @param encrypt
     * @return
     * @throws BadPaddingException
     * @throws IllegalBlockSizeException
     * @throws Exception
     */
    public byte[] decrypt( byte[] encrypt) throws IllegalBlockSizeException, BadPaddingException {
        return dcipher.doFinal(encrypt);
    }

    public static void main( String[] args) throws Exception {
        String messages[] = { ""GETP"", ""Testing stuff that is longer"" };
        String password = ""SanityLost"";

        try {
            Encryption app = new Encryption(password);
            Encryption app1 = new Encryption(password);

            for (String message : messages) {
                byte[] encrypted = app.encryptStringToBase64(message);
                System.out.println(""Encrypted string is: "" + new String(encrypted, ""UTF-8"") + "", "" + encrypted.length);

                String decrypted = app.decryptBase64ToString(encrypted);
                System.out.println(""Decrypted string is: "" + decrypted);

                decrypted = app1.decryptBase64ToString(encrypted);
                System.out.println(""App1 Decrypted string is: "" + decrypted);
            }

        } catch (Exception e1) {
            e1.printStackTrace();
        }

        return;
    }
}
</code></pre>
"	NULL	0	NULL	41:25.7	3	10:53.0	32:28.9	NULL	1750913	1750913	0	1	1	<java><encryption><aes>	Encryption issue due to padding?	992	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
42856093	42856221	4	"<p>I am using this method to decrypt my incoming messages:</p>

<pre><code>private static String decrypt(String key, String initVector, String dataToDecrypt) {
    try {
        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

        String safeString = dataToDecrypt.replace('-', '+').replace('_', '/');
        byte[] decodedString = Base64.decodeBase64(safeString);

        byte[] original = cipher.doFinal(decodedString);

        return new String(original);
    } catch (Exception ex) {
        ex.printStackTrace();
    }

    return null;
}
</code></pre>

<p>However, my <code>Android</code> app crashes, showing the following exception:</p>

<blockquote>
  <p>java.lang.NoSuchMethodError: No static method
  decodeBase64(Ljava/lang/String;)[B in class
  Lorg/apache/commons/codec/binary/Base64; or its super classes
  (declaration of 'org.apache.commons.codec.binary.Base64' appears in
  /system/framework/ext.jar)</p>
</blockquote>

<p>accordingly, the method <code>decodeBase64</code> takes <code>base64string</code>, but I pass <code>string</code>. Here comes my question: </p>

<p>How to convert <code>String</code> to <code>base64string</code> ?!</p>

<p><strong>Please note that I am trying to DECODE not ENCODE. Almost all the solutions provided are for the encoding part which is not my worry.</strong></p>

<p>P.S.: I am developing an Android-app on Android-Studio                                          </p>
"	NULL	3	NULL	15:38.3	3	52:17.2	34:57.6	NULL	2135363	2135363	0	1	1	<java><android><string><decode>	Java: How to convert String to base64string?	5279	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
43890592	43890793	1	"<p>I have an ArrayList which contains some objects. Object is a container for login/pass. <br>
I try to decode them because i have to serialize them into local file for recreation after another launch.<br>
Problem is during encryption I recieve</p>

<pre><code>javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes
    at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1039)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:983)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:845)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
</code></pre>

<p>And I completely don't understand why. In my opinion Base64 should deal with this. But maybe I don't understand properly its meaning.<br>
I use to encrypt/deccode</p>

<pre><code>public class Move
{
    private static Move instance;

    String key = ""pT5IkWNR90gJo5YM"";
    String initVector = ""RandomInitVector"";
    Cipher cipher;


    private Move()
    {
//      try
//      {
//          cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
//      }
//      catch (NoSuchAlgorithmException | NoSuchPaddingException e)
//      {
//          e.printStackTrace();
//      }
    }


    public void saveData(ArrayList&lt;Account&gt; dataToSave)
    {
        try
        {
            FileOutputStream fileOut = new FileOutputStream(Config.SERIAL_FILE);
            ObjectOutputStream out = new ObjectOutputStream(fileOut);
            out.writeObject(encrypt(dataToSave));
            out.close();
            fileOut.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }


    @SuppressWarnings(""unchecked"")
    public ArrayList&lt;Account&gt; loadData()
    {
        ArrayList&lt;Account&gt; loadedData = new ArrayList&lt;Account&gt;();
        File f = new File(Config.SERIAL_FILE);
        if (f.exists())
        {
            try
            {
                FileInputStream fileIn = new FileInputStream(Config.SERIAL_FILE);
                ObjectInputStream in = new ObjectInputStream(fileIn);
                loadedData = (ArrayList&lt;Account&gt;) in.readObject();
                in.close();
                fileIn.close();
            }
            catch (IOException | ClassNotFoundException e)
            {
                e.printStackTrace();
            }
            loadedData = decrypt(loadedData);
        }
        else
        {
            loadedData = new ArrayList&lt;Account&gt;();
        }
        return loadedData;
    }


    private ArrayList&lt;Account&gt; encrypt(List&lt;Account&gt; decrypted)
    {
        ArrayList&lt;Account&gt; encrypted = new ArrayList&lt;Account&gt;();

        try
        {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
            for (int i = 0; i &lt; decrypted.size(); i++)
            {
                try
                {
                    byte[] login = cipher.doFinal(Base64.getDecoder().decode(decrypted.get(i).getLogin().getBytes()));
                    encrypted.add(new Account(login.toString(), ""pass""));
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            }
        }
        catch (InvalidKeyException | InvalidAlgorithmParameterException | UnsupportedEncodingException | NoSuchAlgorithmException | NoSuchPaddingException e)
        {
            e.printStackTrace();
        }
        return encrypted;
    }


    private ArrayList&lt;Account&gt; decrypt(List&lt;Account&gt; encrypted)
    {
        ArrayList&lt;Account&gt; decrypted = new ArrayList&lt;Account&gt;();

        try
        {
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            for (int i = 0; i &lt; encrypted.size(); i++)
            {
                byte[] login = cipher.doFinal(Base64.getDecoder().decode(encrypted.get(i).getLogin()));
                decrypted.add(new Account(new String(login), ""pass""));
            }
        }
        catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException | NoSuchAlgorithmException | NoSuchPaddingException e)
        {
            e.printStackTrace();
        }
        return decrypted;
    }


    public static Move getMove()
    {
        if (instance == null)
        {
            instance = new Move();
        }
        return instance;
    }
}
</code></pre>
"	NULL	2	NULL	02:01.6	4	23:27.6	NULL	NULL	0	2018059	0	1	5	<java><exception><aes><decode><encode>	javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes	18981	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
44202499	44209752	1	"<p>I have a code in VB.Net with a Rijndael encryption algorithm:</p>

<pre class=""lang-vb.net prettyprint-override""><code>Public Function DesencriptarCertificado(ByVal pCertificado As String, ByVal pClave As String) As Byte()
    Dim byteCertificadoDescencriptado As Byte() = Nothing
    Dim Algoritmo As SymmetricAlgorithm = New RijndaelManaged()
    Dim CertClaveDesencriptada As String = """"

    CertClaveDesencriptada = DesencriptarString(pClave, """")
    Transform(CertClaveDesencriptada, Algoritmo)


    Dim ICryptoTransform As ICryptoTransform = Algoritmo.CreateDecryptor()
        byteCertificadoDescencriptado = HexToByte(pCertificado)
        byteCertificadoDescencriptado = ICryptoTransform.TransformFinalBlock(byteCertificadoDescencriptado, 0, byteCertificadoDescencriptado.Length)
    Return byteCertificadoDescencriptado
End Function

Public Sub Transform(ByVal pClave As String, ByRef pAlgoritmo As SymmetricAlgorithm)

    Dim bytes As Byte() = New Byte(7) {}
    Dim BytesClave As Byte() = Encoding.ASCII.GetBytes(pClave)
    Dim length As Integer = Math.Min(BytesClave.Length, bytes.Length)

    For i As Integer = 0 To length - 1
        bytes(i) = BytesClave(i)
    Next

    Dim key As New Rfc2898DeriveBytes(pClave, bytes)
    //ASIGNO BYTES A KEY E IV
    pAlgoritmo.Key = key.GetBytes(pAlgoritmo.KeySize \ 8)
    pAlgoritmo.IV = key.GetBytes(pAlgoritmo.BlockSize \ 8)
End Sub
</code></pre>

<p>The problem is the IV and KEY in JAVA do not get the same bytes, so signature is not the same, it works perfectly if I initialize the KEY and IV manually with the same bytes that are generated in VB.Net, but it is not feasible of course because it would only work for a specific certificate, and the idea is that it works generically, after a search I tried some variants but without success, I could not get the KEY And IV, I would appreciate any help with the subject.</p>

<p>Java Code</p>

<pre class=""lang-java prettyprint-override""><code>public byte[] DesencriptarCertificado(String pCertificado, String pClave) throws NoSuchAlgorithmException, InvalidKeySpecException, UnsupportedEncodingException, NoSuchPaddingException, InvalidAlgorithmParameterException, NoSuchProviderException, ShortBufferException, IOException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    try {
        String CertClaveDesencriptada = DesencriptarString(pClave, """");

        ////////////Transform//////////////
        byte[] bytes = new byte[8];
        byte[] BytesClave = CertClaveDesencriptada.getBytes();
        int length = Math.min(BytesClave.length, bytes.length);

        for (int i = 0; i &lt; length; i++) {
            bytes[i] = BytesClave[i];
        }

        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec pbeKeySpec = new PBEKeySpec(CertClaveDesencriptada.toCharArray(), bytes, 12, 1000);
        Key secretKey = factory.generateSecret(pbeKeySpec);
        byte[] encoded = secretKey.getEncoded();

        byte[] KEY = new byte[32];
        byte[] IV = new byte[16];

        //ASIGNO BYTES A KEY E IV
        System.arraycopy(encoded, 0, KEY, 0, 32); 
        System.arraycopy(encoded, 32, IV, 0, 16);

        SecretKeySpec secret = new SecretKeySpec(key, ""Rijndael"");
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(IV);
        _cipherDecrypEncrypt = Cipher.getInstance(""AES/CBC/PKCS7Padding"", ""BC"");
        _cipherDecrypEncrypt.init(Cipher.DECRYPT_MODE, secret, ivSpec);


        ///////////////DESENCRIPTAR CERTIFICADO/////////////////////
        byte[] beforeEncrypt = HexToByte(pCertificado);
        byte[] byteCertificadoDescencriptado = _cipherDecrypEncrypt.doFinal(beforeEncrypt);

        return byteCertificadoDescencriptado;

    } catch (InvalidKeyException e) {
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    } catch (IllegalBlockSizeException e) {
        System.out.println(e);
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    } catch (BadPaddingException e) {
        System.out.println(e);
        throw new TAFACE2ApiEntidad.TAException(e.getMessage());
    }

}
</code></pre>
"	NULL	7	NULL	10:09.9	2	53:50.9	24:48.8	NULL	1816580	8070525	0	1	1	<java><vb.net><encryption><rijndael>	How to get the right KEY and IV in Rinjdael encryption equivalent in JAVA	365	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
44680760	0	1	"<p>So I think I have encrypted my secret key and String well but decryption is becoming the problem for me. Below is my code: </p>

<pre><code>package ReadFileExample;


import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

import java.security.KeyStore;



public class generatekey {


  static Cipher cipher;
  public static void main(String[] args) throws Exception {






    // generating a symmetric key using the AES algorithm
    KeyGenerator generator = KeyGenerator.getInstance(""AES"");
    // 128 bit key
    generator.init(256);
    //generates a secret key
    SecretKey secretkey = generator.generateKey();
    // returns an AES cipher
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    //print key
    System.out.println(""Key: "" + cipher);








    String plainText = ""Hello World"";
    // call to method encrypt 
    String hexEncryptedByteText  = encrypt(plainText, secretkey);
    // print orignial text and encrypted text
    System.out.println(""Plain Text: "" + plainText);
    System.out.println(""Encrypted Text: "" + hexEncryptedByteText);

    int plainTextlength = plainText.length();
    System.out.println(""length of text: "" + plainTextlength);


    // allows to write data to a file
    FileOutputStream fos = null;
    // write bytes to file
    BufferedOutputStream bos = null;
    // create file to which data needs to be written
    String fileName = ""C:/Users/******/newFile.txt"";

    try{
        // allows written data to go into the written path
        fos = new FileOutputStream(fileName);
        // converts written data into bytes
        bos = new BufferedOutputStream(fos);


        // writes the encrypted text into file
        bos.write(hexEncryptedByteText.length());                


        System.out.println(""encryptedText has been written successfully in ""
                     +fileName);

        // allows to catch bug in code
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try{
            // check for null exception
            if (bos != null){
                bos.close();

            }
            // check for null exception
            if (fos != null){
                fos.close();
            }
        } catch (IOException e){
            e.printStackTrace();

        }



    }






    // creates a file input stream by opening a path to the file needed
    FileInputStream fin = new FileInputStream(""C:/Users/*****/public.cert"");
    // implements the X509 certificate type
    CertificateFactory f = CertificateFactory.getInstance(""X.509"");
    // initalizes data found in the file
    X509Certificate certificate = (X509Certificate)f.generateCertificate(fin);
    // gets public key from this certificate 
    PublicKey pk = certificate.getPublicKey();
    System.out.println(pk);

    String hexEncryptedByteKey = encryptedKey(pk, secretkey);
    System.out.println(""Encrypted Key: "" + hexEncryptedByteKey);
    System.out.println(""Encrypted Key length: "" + hexEncryptedByteKey.length());

    // allows to write data to a file
    FileOutputStream newFos = null;
    // write bytes to file
    BufferedOutputStream newBos = null;
    // create file to which data needs to be written
    String fileNameKey = ""C:/Users/****/symmetric.txt"";

    try{
        // allows written data to go into the written path
        newFos = new FileOutputStream(fileNameKey);
        // converts written data into bytes
        newBos = new BufferedOutputStream(newFos);



        // writes the encrypted text into file
        newBos.write(hexEncryptedByteKey.length());                


        System.out.println(""encryptedKey has been written successfully in ""
                     +fileNameKey);






        // allows to catch bug in code
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try{
            // check for null exception
            if (newBos != null){
                newBos.close();

            }
            // check for null exception
            if (newFos != null){
                newFos.close();
            }
        } catch (IOException e){
            e.printStackTrace();

        }
    }

    // load keystore to get private key
    KeyStore ks = KeyStore.getInstance(""JKS"");
    String password = ""*****"";
    char[] passwordChar = password.toCharArray();
    System.out.println(""password: "" + passwordChar);
    // locate file
    try (FileInputStream fis = new FileInputStream(""C:/Users/*****/keystore.jks"")) {
        ks.load(fis, passwordChar);
    }

    // protect password for keystore
    KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(passwordChar);

    // get private key from keystore 
    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)
            ks.getEntry(""*****"", protParam);

    PrivateKey myPrivateKey = pkEntry.getPrivateKey();

    System.out.println(""private key: "" + myPrivateKey);
    //method declaration
    String decryptedKey = decryptedKey(myPrivateKey, hexEncryptedByteKey);

    System.out.println(""decrypted Key: "" + decryptedKey);

    String hexDecryptedByteText = decryptedTextHex(decryptedKey, hexEncryptedByteText);
    System.out.println(""key: "" + hexDecryptedByteText);

}




public static String encrypt(String plainText, SecretKey secretkey) throws Exception {
    //Encodes the string into a sequence of bytes
    byte[] plainTextByte = plainText.getBytes();
    //intialize cipher to encryption mode
    cipher.init(Cipher.ENCRYPT_MODE, secretkey);
    //data is encrypted 
    byte[] encryptedByte = cipher.doFinal(plainTextByte);
    //Base64.Encoder encoder = Base64.getEncoder();
    //encodes bytes into a string using Base64
    byte[] encryptedByteText = Base64.getEncoder().encode(plainTextByte);
    String hexEncryptedByteText = DatatypeConverter.printHexBinary(plainTextByte);
    // return the string encrypted text to the main method
    return hexEncryptedByteText;

}

public static String encryptedKey(PublicKey pk, SecretKey secretkey) throws Exception {
    // data written to byte array
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    // writes data types to the output stream
    ObjectOutputStream writter = new ObjectOutputStream(baos);
    //specific object of secretkey is written to the output stream
    writter.writeObject(secretkey);

    //creates a byte array  
    byte[] plainTextByteKey = baos.toByteArray();

    //creates a cipher using the RSA algorithm 
    Cipher cipher = Cipher.getInstance(""RSA"");
    // initalizes cipher for encryption using the public key 
    cipher.init(Cipher.ENCRYPT_MODE, pk);
    //encrypts data
    //byte[] encryptedByteKey = Base64.getEncoder().encode(plainTextByteKey);

    String hexEncryptedByteKey = DatatypeConverter.printHexBinary(plainTextByteKey);
    //Base64.Encoder encoderKey = Base64.getEncoder();
    // encodes the byte array into a string.
    //String encryptedTextKey = new String(encryptedByteKey);
    return hexEncryptedByteKey;

}

private static String decryptedKey(PrivateKey myPrivateKey, String hexEncryptedByteKey) throws Exception {

    //ByteArrayOutputStream baosDecrypt = new ByteArrayOutputStream();
    //ObjectOutputStream writterDecrypt = new ObjectOutputStream(baosDecrypt);
    //writterDecrypt.writeObject(hexEncryptedByteKey);
    //byte[] byteKeyDecrypt = baosDecrypt.toByteArray();


    Cipher cipher;
    cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, myPrivateKey);
    //cipher.doFinal();

    //byte [] decryptedKey = Base64.getDecoder().decode(byteKeyDecrypt);
    //String decryptedTextKey = new String(byteKeyDecrypt);

    byte[] decodedHex = DatatypeConverter.parseHexBinary(hexEncryptedByteKey);
    System.out.println(""decoded hex key: "" + decodedHex);
    String decryptedKey = new String(decodedHex, ""UTF-8"");
    return decryptedKey;





}

private static String decryptedTextHex(String decryptedKey, String hexEncryptedByteText) throws Exception {

    byte[] decryptedTextByte = decryptedKey.getBytes();
    byte[] textString = hexEncryptedByteText.getBytes();
    SecretKey key = new SecretKeySpec(decryptedTextByte, 0, decryptedTextByte.length, ""AES"");


    Cipher cipher;
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    //IvParameterSpec iv = new IvParameterSpec(cipher.getIV());
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] decodedTextHex = cipher.doFinal(textString);

    byte[] decoded = Base64.getDecoder().decode(decodedTextHex);

    String hexDecryptedByteText = DatatypeConverter.printHexBinary(decoded);


    return hexDecryptedByteText;



}
</code></pre>

<p>}</p>

<p>This is the error I am getting:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: Parameters missing
at com.sun.crypto.provider.CipherCore.init(CipherCore.java:469)
at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:313)
at javax.crypto.Cipher.implInit(Cipher.java:802)
at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
at javax.crypto.Cipher.init(Cipher.java:1249)
at javax.crypto.Cipher.init(Cipher.java:1186)
at ReadFileExample.generatekey.decryptedTextHex(generatekey.java:289)
at ReadFileExample.generatekey.main(generatekey.java:202)
</code></pre>

<p>I am not sure what is wrong. If my decryption of key is wrong or just the decryption of the String. I get no errors when it comes to the decryption of the key however. </p>

<p>For some more information: I generated a secret key, encrypted a String with the secret key and then encrypted the secret key with a generated public key. Then I decrypted the secret key with the private key and lastly I need to decrypt the String with the decrypted secret key. </p>

<p>Help is greatly appreciated. I have been working on this for so long and I just don't know what to do anymore. ]</p>

<p>EDIT: That other question has nothing to do with my question. I don't even have that same error message and I have already downloaded the JCE as that solution has stated. </p>
"	NULL	2	NULL	45:47.4	2	41:51.5	35:15.1	NULL	8172424	8172424	0	1	1	<java><security><encryption><cryptography>	Decryption of Encrypted Secret Key and Encrypted String	1629	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
44739109	44748161	2	"<p>I'm working on an encryption and decryption app on Android, that deals with video files. My app runs perfectly on some devices but crashes on some, while dealing with the same file size. My code for the InputStream and OutputStream is below</p>

<pre><code>package com.example.rama.beta;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

import android.app.Activity;
import android.os.Bundle;
import android.os.Environment;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button encryptButton = (Button) findViewById(R.id.button1);
        Button DecryptButton = (Button) findViewById(R.id.button2);
        encryptButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                try {
                    encrypt();
                } catch (InvalidKeyException e) {
                    e.printStackTrace();
                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (NoSuchPaddingException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });

        DecryptButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                try {
                    decrypt();
                } catch (InvalidKeyException e) {
                    e.printStackTrace();
                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (NoSuchPaddingException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });

    }
    static void encrypt() throws IOException, NoSuchAlgorithmException,
                NoSuchPaddingException, InvalidKeyException {
            File extStore = Environment.getExternalStorageDirectory();
            FileInputStream fis = new FileInputStream(extStore + ""/abc.m4v"");
            FileOutputStream fos = new FileOutputStream(extStore + ""/encabc.m4v"");

            SecretKeySpec sks = new SecretKeySpec(""xxxx"".getBytes(),
                    ""AES"");

            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, sks);

            CipherOutputStream cos = new CipherOutputStream(fos, cipher);

            int read;
            byte[] buffer = new byte[1024];
            while ((read = fis.read(buffer)) != -1) {
                cos.write(buffer, 0, read);
            }

            cos.flush();
            cos.close();
            fis.close();
        }

    static void decrypt() throws IOException, NoSuchAlgorithmException,
                NoSuchPaddingException, InvalidKeyException {

            File extStore = Environment.getExternalStorageDirectory();
            FileInputStream fis = new FileInputStream(extStore + ""/encabc.m4v"");

            FileOutputStream fos = new FileOutputStream(extStore + ""/decabc.m4v"");
            SecretKeySpec sks = new SecretKeySpec(""xxxx"".getBytes(),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.DECRYPT_MODE, sks);
            CipherInputStream cis = new CipherInputStream(fis, cipher);
            int read;
            byte[] buffer = new byte[1024];
            while ((read = cis.read(buffer)) != -1) {
                fos.write(buffer, 0, read);
            }
            fos.flush();
            fos.close();
            cis.close();

        }
    }
</code></pre>

<p>The noticeable difference between both android devices I'm using is the RAM, the app works perfectly while handling a 50mb video on a device with 2gb RAM, but crashes on a device with 1gb RAM. I'm not sure if it is a RAM problem or something else. Appreciate any inputs.</p>

<pre><code>06-24 18:21:08.179 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.179 I/ActivityManager(1760): START u0 \{act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10304000 cmp=com.example.rama.beta/.MainActivity\} from pid 1989\par
06-24 18:21:08.349 D/dalvikvm(20695): Late-enabling CheckJNI\par
06-24 18:21:08.349 I/ActivityManager(1760): Start proc com.example.rama.beta for activity com.example.rama.beta/.MainActivity: pid=20695 uid=10046 gids=\{50046, 1015, 1028\}\par
06-24 18:21:08.379 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.419 E/SurfaceFlinger(1238): ro.sf.lcd_density must be defined as a build property\par
06-24 18:21:08.439 I/qtaguid (1760): Failed write_ctrl(s 1 10046) res=-1 errno=1\par
06-24 18:21:08.439 W/NetworkManagementSocketTagger(1760): setKernelCountSet(10046, 1) failed with errno -1\par
06-24 18:21:08.439 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.449 E/SurfaceFlinger(1238): ro.sf.lcd_density must be defined as a build property\par
06-24 18:21:08.459 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.469 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.479 E/Trace   (20695): error opening trace file: No such file or directory (2)\par
06-24 18:21:08.649 D/PhoneWindowManager(1760): mFullScreenIsEnable = true, mAlwaysFullScreen = false\par
06-24 18:21:08.669 E/SurfaceFlinger(1238): ro.sf.lcd_density must be defined as a build property\par
06-24 18:21:08.679 D/libEGL  (20695): loaded /system/lib/egl/libEGL_mali.so\par
06-24 18:21:08.679 D/libEGL  (20695): loaded /system/lib/egl/libGLESv1_CM_mali.so\par
06-24 18:21:08.679 D/libEGL  (20695): loaded /system/lib/egl/libGLESv2_mali.so\par
06-24 18:21:08.719 W/BufferQueue(1238): freeAllBuffersLocked called but mQueue is not empty\par
06-24 18:21:08.749 D/OpenGLRenderer(20695): Enabling debug mode 0\par
06-24 18:21:08.929 I/ActivityManager(1760): Displayed com.example.rama.beta/.MainActivity: +599ms\par
06-24 18:21:11.089 I/dalvikvm(20695): Total arena pages for JIT: 11\par
06-24 18:21:11.089 I/dalvikvm(20695): Total arena pages for JIT: 12\par
06-24 18:21:11.099 I/dalvikvm(20695): Total arena pages for JIT: 13\par
06-24 18:21:11.099 I/dalvikvm(20695): Total arena pages for JIT: 14\par
06-24 18:21:11.099 I/dalvikvm(20695): Total arena pages for JIT: 15\par
06-24 18:21:11.099 I/dalvikvm(20695): Total arena pages for JIT: 16\par
06-24 18:21:11.099 I/dalvikvm(20695): Total arena pages for JIT: 17\par
06-24 18:21:11.129 I/dalvikvm(20695): Total arena pages for JIT: 18\par
06-24 18:21:11.999 D/dalvikvm(20695): GC_CONCURRENT freed 1832K, 40% free 4175K/6880K, paused 3ms+2ms, total 35ms\par
06-24 18:21:12.729 D/dalvikvm(20695): GC_CONCURRENT freed 1947K, 41% free 4175K/7028K, paused 3ms+3ms, total 19ms\par
06-24 18:21:13.649 D/dalvikvm(20695): GC_CONCURRENT freed 1952K, 41% free 4172K/7036K, paused 3ms+2ms, total 34ms\par
06-24 18:21:14.419 D/dalvikvm(20695): GC_CONCURRENT freed 1925K, 41% free 4197K/7036K, paused 2ms+1ms, total 26ms\par
06-24 18:21:15.159 D/dalvikvm(20695): GC_CONCURRENT freed 1985K, 41% free 4172K/7068K, paused 2ms+2ms, total 37ms\par
06-24 18:21:16.019 D/dalvikvm(20695): GC_CONCURRENT freed 1950K, 41% free 4194K/7068K, paused 3ms+52ms, total 77ms\par
06-24 18:21:16.049 D/dalvikvm(1760): GC_CONCURRENT freed 2590K, 30% free 12059K/17108K, paused 3ms+37ms, total 223ms\par
06-24 18:21:17.489 D/dalvikvm(20695): GC_CONCURRENT freed 1969K, 41% free 4175K/7068K, paused 3ms+3ms, total 18ms\par
06-24 18:21:17.869 I/InputDispatcher(1760): Application is not responding: Window\{41b2f780 u0 com.example.rama.beta/com.example.rama.beta.MainActivity\}.  It has been 5006.0ms since event, 5005.6ms since wait started.  Reason: Waiting because the touched window has not finished processing the input events that were previously delivered to it.\par
06-24 18:21:17.879 D/InputManager-JNI(1760): notifyANR\par
06-24 18:21:17.879 I/WindowManager(1760): Input event dispatching timed out sending to com.example.rama.beta/com.example.rama.beta.MainActivity\par
06-24 18:21:17.929 I/Process (1760): Sending signal. PID: 20695 SIG: 3\par
06-24 18:21:17.929 I/dalvikvm(20695): threadid=3: reacting to signal 3\par
06-24 18:21:17.949 I/dalvikvm(20695): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:17.949 I/Process (1760): Sending signal. PID: 1760 SIG: 3\par
06-24 18:21:17.949 I/dalvikvm(1760): threadid=3: reacting to signal 3\par
06-24 18:21:17.979 D/dalvikvm(20695): GC_CONCURRENT freed 1208K, 41% free 4171K/7068K, paused 1ms+4ms, total 29ms\par
06-24 18:21:18.189 I/Process (1760): Sending signal. PID: 1989 SIG: 3\par
06-24 18:21:18.189 I/dalvikvm(1989): threadid=3: reacting to signal 3\par
06-24 18:21:18.189 I/dalvikvm(1760): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:18.199 I/Process (1760): Sending signal. PID: 2171 SIG: 3\par
06-24 18:21:18.199 I/dalvikvm(2171): threadid=3: reacting to signal 3\par
06-24 18:21:18.259 I/dalvikvm(2171): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:18.259 I/Process (1760): Sending signal. PID: 2180 SIG: 3\par
06-24 18:21:18.259 I/dalvikvm(2180): threadid=3: reacting to signal 3\par
06-24 18:21:18.259 D/ConnectivityService(1760): special network not available ni=mobile_hipri\par
06-24 18:21:18.279 I/dalvikvm(1989): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:18.349 I/dalvikvm(2180): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:18.439 D/dalvikvm(1760): GC_CONCURRENT freed 890K, 30% free 12146K/17108K, paused 17ms+15ms, total 252ms\par
06-24 18:21:18.669 D/dalvikvm(1760): GC_EXPLICIT freed 464K, 29% free 12316K/17108K, paused 5ms+10ms, total 98ms\par
06-24 18:21:18.919 D/dalvikvm(20695): GC_CONCURRENT freed 1944K, 41% free 4173K/7068K, paused 3ms+3ms, total 18ms\par
06-24 18:21:19.209 I/Process (1760): Sending signal. PID: 18063 SIG: 3\par
06-24 18:21:19.209 I/dalvikvm(18063): threadid=3: reacting to signal 3\par
06-24 18:21:19.239 I/dalvikvm(18063): Wrote stack traces to '/data/anr/traces.txt'\par
06-24 18:21:19.249 E/ActivityManager(1760): ANR in com.example.rama.beta (com.example.rama.beta/.MainActivity)\par
06-24 18:21:19.249 E/ActivityManager(1760): Reason: keyDispatchingTimedOut\par
06-24 18:21:19.249 E/ActivityManager(1760): Load: 1.09 / 1.36 / 1.55\par
06-24 18:21:19.249 E/ActivityManager(1760): CPU usage from 6504ms to 0ms ago:\par
06-24 18:21:19.249 E/ActivityManager(1760):   83% 20695/com.example.rama.beta: 74% user + 8.7% kernel / faults: 1365 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):   2.9% 1760/system_server: 2.1% user + 0.7% kernel / faults: 154 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):   0% 1168/nand10: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   1.3% 1238/surfaceflinger: 0% user + 1.3% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0% 19796/flush-93:80: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.9% 1241/mediaserver: 0.3% user + 0.6% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.6% 12373/kworker/u:4: 0% user + 0.6% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.1% 1167/nftld: 0% user + 0.1% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.3% 10516/kworker/0:0: 0% user + 0.3% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0% 785/hdmi proc: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.1% 11380/logcat: 0.1% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.1% 13429/kworker/u:2: 0% user + 0.1% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   0.1% 18063/com.nolanlawson.logcat: 0.1% user + 0% kernel / faults: 5 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):  +0% 20829/migration/1: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):  +0% 20830/kworker/1:0: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):  +0% 20831/ksoftirqd/1: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):  +0% 20832/kworker/1:1: 0% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760): 0.-4% TOTAL: 0.-5% user + 0.-1% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760): CPU usage from 763ms to 1283ms later:\par
06-24 18:21:19.249 E/ActivityManager(1760):   101% 20695/com.example.rama.beta: 98% user + 3.8% kernel / faults: 38 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):     98% 20695/mple.rama.beta: 94% user + 3.8% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):     3.8% 20698/GC: 3.8% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   3.8% 1760/system_server: 0% user + 3.8% kernel / faults: 1 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):     3.8% 1924/InputDispatcher: 0% user + 3.8% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):     1.9% 1781/ActivityManager: 0% user + 1.9% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760):   1.4% 18063/com.nolanlawson.logcat: 1.4% user + 0% kernel / faults: 1 minor\par
06-24 18:21:19.249 E/ActivityManager(1760):     1.4% 18063/anlawson.logcat: 1.4% user + 0% kernel\par
06-24 18:21:19.249 E/ActivityManager(1760): 54% TOTAL: 48% user + 5.7% kernel\par
06-24 18:21:19.259 W/ActivityManager(1760):   Force finishing activity com.example.rama.beta/.MainActivity\par
06-24 18:21:19.309 I/ActivityManager(1760): Killing ProcessRecord\{41ac6640 20695:com.example.rama.beta/u0a10046\}: user's request\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/InputDispatcher(1760): Dropping event because there is no touched window.\par
06-24 18:21:19.329 I/qtaguid (1760): Failed write_ctrl(s 0 10046) res=-1 errno=1\par
06-24 18:21:19.329 W/NetworkManagementSocketTagger(1760): setKernelCountSet(10046, 0) failed with errno -1\par
06-24 18:21:19.329 I/ActivityManager(1760): Process com.example.rama.beta (pid 20695) has died.\par
06-24 18:21:19.329 I/WindowState(1760): WIN DEATH: Window\{41b2f780 u0 com.example.rama.beta/com.example.rama.beta.MainActivity\}\par
</code></pre>
"	NULL	8	NULL	30:22.7	0	07:34.5	38:55.4	NULL	8209831	8209831	0	1	3	<java><android>	Android app crashing on certain devices when handling large files	645	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
45020037	0	0	"<p>Please read full question before mark it as duplicate or down vote.
I need to add AES 256 encryption in my project. so according <a href=""https://stackoverflow.com/questions/6481627/java-security-illegal-key-size-or-default-parameters"">here</a> have added security jars in my jre and jdk's lib security folder. now if I run code using main method it is working but if I deploy it in tomcat. it is throwing me error</p>

<pre><code>java.security.InvalidKeyException: Illegal key size or default parameters
        at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1026)
        at javax.crypto.Cipher.implInit(Cipher.java:801)
        at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
        at javax.crypto.Cipher.init(Cipher.java:1249)
        at javax.crypto.Cipher.init(Cipher.java:1186)
        at com.infy.encrypt.Encryption.encrypt(Encryption.java:36)
        at com.infy.service.UserServiceImpl.addUser(UserServiceImpl.java:24)
        at com.infy.controller.UserController.addUser(UserController.java:44)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
        at java.lang.reflect.Method.invoke(Unknown Source)
        at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)
        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)
        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)
</code></pre>

<p>I think my tomcat is not reading updated policy files. aI tried by killing jvm proccesses but no luck.</p>

<p>below is my encryption code</p>

<pre><code> public String encrypt(String word) throws Exception {

        byte[] ivBytes;
        String password=""Hello""; 
    /*you can give whatever you want for password. This is for testing purpose*/

        SecureRandom random = new SecureRandom();
        byte bytes[] = new byte[20];
        random.nextBytes(bytes);
        byte[] saltBytes = bytes;

        // Derive the key
       SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(),saltBytes,65556,256);

         SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

         //encrypting the word

         Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
         cipher.init(Cipher.ENCRYPT_MODE, secret);
         AlgorithmParameters params = cipher.getParameters();
         ivBytes =   params.getParameterSpec(IvParameterSpec.class).getIV();

         byte[] encryptedTextBytes =  cipher.doFinal(word.getBytes(""UTF-8""));

         //prepend salt and vi

          byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];

          System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);
          System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);

           System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length, encryptedTextBytes.length);

           return new Base64().encodeToString(buffer);

        }
</code></pre>

<p>below is the result for Test method</p>

<pre><code>public static void main(String[] args) throws Exception {

        Encryption en=new Encryption();
        String encryptedWord=en.encrypt(""Test""); 
        System.out.println(""Encrypted word is : "" + encryptedWord);
        Decryption de =new Decryption();
        System.out.println(""Decrypted word is : "" +    de.decrypt(encryptedWord));  
    }
</code></pre>

<p>output</p>

<pre><code>Encrypted word is : o73KvJpuI/QdJlswEsBqf/Cz0PDdUdX0emADyTMxqVeHDP1QSkH+YR0HlWAMb+dNGDjy3w==
</code></pre>

<p>But if I hit same thing by deploying in tomcat it is not working
below is my controller class</p>

<pre><code>@RequestMapping(value = ""/register/add"", method = RequestMethod.POST,produces=MediaType.APPLICATION_JSON_VALUE,consumes=MediaType.APPLICATION_JSON_VALUE)       
        public @ResponseBody UserMVC addUser(@RequestBody UserMVC p) {
System.out.println(""inside controller"");
/*          if (p.getId() == 0) {
                // new user, add it
                this.userService.addUser(p);
            } else {
                // existing user, call update
                this.userService.updateUser(p);
            }*/
            User user=new User();
            user.setFirstname(p.getFirstName());
            user.setLastname(p.getLastName());
            user.setPassword(p.getPassword());
            user.setUsername(p.getUserName());
            this.userService.addUser(user);
            return p;

        }
</code></pre>

<p>and adduser metthod of dao</p>

<pre><code>public void addUser(User p) {
        try {
            Encryption en=new Encryption();
            p.setPassword(en.encrypt(p.getPassword()));
            System.out.println(""password:""+p.getPassword());
            this.userDao.addUser(p);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
</code></pre>
"	NULL	6	NULL	19:27.0	3	19:27.0	NULL	NULL	0	8061267	0	1	0	<java><security><tomcat><encryption><aes>	java.security.invalidkeyexception illegal key size or default parameters	4557	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
45078929	45079272	1	"<p>I have a Json String </p>

<pre><code>            String message = ""{\""version\"":\""1.0\"",\""rccCubeType\"":\""TCR_CASE_D\"",\""timeZone\"":\""Asia/Kolkata\"",\""timeOffset\"":\""+05:30\"",\""tenant\"":\""0001\"",\""extractionTime\"":\""20170713162718117\""}"";
</code></pre>

<p>I am encrypting this string using </p>

<pre><code> import org.apache.commons.codec.binary.Base64;
 import org.apache.log4j.Logger;
 import javax.crypto.*;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.PBEKeySpec;
 import javax.crypto.spec.SecretKeySpec;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
 import java.security.spec.InvalidKeySpecException;
 import java.security.spec.InvalidParameterSpecException;
 import java.security.spec.KeySpec;

 public class AESEncrypter {

private static final Logger LOGGER = Logger.getLogger(AESEncrypter.class);
private static final byte[] SALT = {
    (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,
    (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03
};
private static final int ITERATION_COUNT = 65536;
private static final int KEY_LENGTH = 256;
private Cipher ecipher;
private Cipher dcipher;

public AESEncrypter(String passPhrase)  {
    SecretKeyFactory factory = null;
    Field field = null;
    try {
        // hack for JCE unlimited strength policy jar installations
        field = Class.forName(""javax.crypto.JceSecurity"").getDeclaredField(""isRestricted"");
        field.setAccessible(true);

        Field modifiersField = Field.class.getDeclaredField(""modifiers"");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);

        field.set(null, false);


        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT, KEY_LENGTH);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        ecipher.init(Cipher.ENCRYPT_MODE, secret);

        dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] iv = ecipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
        dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        LOGGER.error(""Invalid Key Exception"",e);
    } catch (InvalidAlgorithmParameterException e) {
        LOGGER.error(""Invalid Algorithm Parameter Exception"",e);
    } catch (NoSuchPaddingException e) {
        LOGGER.error(""No Such Padding Exception"",e);
    } catch (InvalidParameterSpecException e) {
        LOGGER.error(""Invalid Parameter Exception"",e);
    } catch (InvalidKeySpecException e) {
        LOGGER.error(""Invalid Key Spec Exception"",e);
    } catch (NoSuchFieldException e) {
        LOGGER.error(""No Such field Exception"",e);
    } catch (ClassNotFoundException e) {
        LOGGER.error(""Class Not Found Exception"",e);
    } catch (IllegalAccessException e) {
        LOGGER.error(""Illegal Argument Exception"",e);
    }


}

public String encrypt(String encrypt) {
    byte[] bytes = new byte[0];
    byte[] encrypted = new byte[0];
    try {
        bytes = encrypt.getBytes(""UTF-8"");
        encrypted = encrypt(bytes);
    } catch (Exception e) {
        LOGGER.error(""Exception"",e);
    }
    return Base64.encodeBase64String(encrypted);
}

private byte[] encrypt(byte[] plain)  {
    try {
        return ecipher.doFinal(plain);
    } catch (IllegalBlockSizeException e) {
        LOGGER.error(""Illegal Block Size Exception"",e);
    } catch (BadPaddingException e) {
        LOGGER.error(""Bad Padding Exception"",e);
    }
    return null;
}

public String decrypt(String encrypt) throws UnsupportedEncodingException {
    byte[] bytes = Base64.decodeBase64(encrypt.getBytes(""UTF-8""));
        byte[] decrypted = decrypt(bytes);
        return new String(decrypted);
}

public byte[] decrypt(byte[] encrypt)  {
    try {
        return dcipher.doFinal(encrypt);
    } catch (IllegalBlockSizeException e) {
        LOGGER.error(""Illegal Block Size Exception"",e);
    } catch (BadPaddingException e) {
        LOGGER.error(""Bad Padding Exception"",e);
    }
    return null;
}




public static void main(String[] args) throws UnsupportedEncodingException {
        String password = ""F1C0T0N83LL34"";
        String message = ""{\""version\"":\""1.0\"",\""rccCubeType\"":\""TCR_CASE_D\"",\""timeZone\"":\""Asia/Kolkata\"",\""timeOffset\"":\""+05:30\"",\""tenant\"":\""0001\"",\""extractionTime\"":\""20170713162718117\""}"";
        AESEncrypter encrypter = new AESEncrypter(password);
        String cipher = encrypter.encrypt(message);
        System.out.println(cipher);
        System.out.println(new String(encrypter.decrypt(""I8YbMaRvAw+rzPQu//uXnDDFrk/EtscXpcxBzqonVOpJ1VjvpwtRGwrsEz9R1rroC95Vj9bzPDbkX2qdLXK4jLKlzaoINXOxF+dHslnBVl3xG61qh9QdCuMTBzEEw18K51JJu+13bjuUO20+0uZiY5q6Wg1sQ60C0QEeO/7K9F/TSUN1r5l02Q9NSDQJpkvlglHZEfPJ7ST4179oqlQUjQ=="").getBytes(""UTF-8"")));
     }
 }
</code></pre>

<p>I am decrypting the encrypted string using dcipher object, but when i copy the value of the encrypted string and do a dcipher of the copied string i get some junk values like </p>

<pre><code>e_N???&lt;?E?=&gt;?,""rccCubeType"":""TCR_CASE_D"",""timeZone"":""Asia/Kolkata"",""timeOffset"":""+05:30"",""tenant"":""0001"",""extractionTime"":""20170713162718117""}
</code></pre>

<p>where am i going wrong? when i process these things in memory that is within a single run, the decryption is going through correctly.</p>

<p>EDIT 1: adding the complete class</p>
"	NULL	4	NULL	11:37.8	3	32:00.9	32:00.9	NULL	3506300	3506300	0	1	0	<java><encryption>	Decrypting a json string using java cryto package resulting in wrong json string	1289	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
45103983	45106335	1	"<p>I have an application which may require a password for authentification.<br>
This application does not handle any sensitive data, because this ""password"" is chosen by the host and told the ""clients"" via another channel (WhatsApp or whatever).
So when a client wants to authenticate, the host generates a random String which is sent to the client.<br>
The client then encrypts this Random String with the password the user enters.<br>
The encrypted random String is the sent back t the host.<br>
The host decrypts this encrypted String with the key generated by the same password.<br>
If the unencrypted and original String match, the user is logged in.<br>
This is what I came up with so far:</p>

<pre><code>String base64;
char[] password = ""password"".toCharArray();
String randomString = new BigInteger(130, new SecureRandom()).toString(32);
try {
    //Encrypt Client Side
    SecretKey key = new SecretKeySpec(SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA512"").generateSecret(new PBEKeySpec(password)).getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key);
    base64 = Base64.getEncoder().encodeToString(cipher.doFinal(randomString.getBytes(StandardCharsets.UTF_8)));
} catch (GeneralSecurityException e) {
    throw new IllegalStateException(e);
}
try {
    //Decrypt Server Side
    SecretKey key = new SecretKeySpec(SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA512"").generateSecret(new PBEKeySpec(password)).getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key);
    //Check if both strings match
    System.out.println(Arrays.equals(cipher.doFinal(Base64.getDecoder().decode(base64)), randomString.getBytes(StandardCharsets.UTF_8)));
} catch (GeneralSecurityException e) {
    throw new IllegalStateException(e);
}
</code></pre>

<p>Unfortunately this code throws an exception: <code>java.security.spec.InvalidKeySpecException: Salt not found</code><br>
Should I use a different algorithm, or should I generate a salt by hashing the password itself, or a completely different approach?
I'd like to avoid having to send a generated salt along with the random String</p>
"	NULL	0	NULL	14:58.3	2	10:52.9	NULL	NULL	0	5769952	0	1	0	<java><security><encryption><encryption-symmetric>	Generate AES key based on password only	2095	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
46190058	0	1	"<p>C# Code</p>

<pre><code>namespace MWS.DAL
{
   public class StringHelpers
    {
        #region Constants

        private const char QUERY_STRING_DELIMITER = '&amp;';

        #endregion Constants

        #region Members

        private static RijndaelManaged _cryptoProvider;
        //128 bit encyption: DO NOT CHANGE    
        private static readonly byte[] Key = { some byte value };
        private static readonly byte[] IV = { some byte value  };

        #endregion Members

        #region Constructor

        static StringHelpers()
        {
            _cryptoProvider = new RijndaelManaged();
            _cryptoProvider.Mode = CipherMode.CBC;
            _cryptoProvider.Padding = PaddingMode.PKCS7;
        }

        #endregion Constructor

        #region Methods

        /// &lt;summary&gt;
        /// Encrypts a given string.
        /// &lt;/summary&gt;
        /// &lt;param name=""unencryptedString""&gt;Unencrypted string&lt;/param&gt;
        /// &lt;returns&gt;Returns an encrypted string&lt;/returns&gt;
        public static string Encrypt(string unencryptedString)
        {
            byte[] bytIn = ASCIIEncoding.ASCII.GetBytes(unencryptedString);

            // Create a MemoryStream
            MemoryStream ms = new MemoryStream();

            // Create Crypto Stream that encrypts a stream
            CryptoStream cs = new CryptoStream(ms,
                _cryptoProvider.CreateEncryptor(Key, IV),
                CryptoStreamMode.Write);

            // Write content into MemoryStream
            cs.Write(bytIn, 0, bytIn.Length);
            cs.FlushFinalBlock();

            byte[] bytOut = ms.ToArray();
            return Convert.ToBase64String(bytOut);
        }

        /// &lt;summary&gt;
        /// Decrypts a given string.
        /// &lt;/summary&gt;
        /// &lt;param name=""encryptedString""&gt;Encrypted string&lt;/param&gt;
        /// &lt;returns&gt;Returns a decrypted string&lt;/returns&gt;
        public static string Decrypt(string encryptedString)
        {
            if (encryptedString.Trim().Length != 0)
            {
                // Convert from Base64 to binary
                byte[] bytIn = Convert.FromBase64String(encryptedString);

                // Create a MemoryStream
                MemoryStream ms = new MemoryStream(bytIn, 0, bytIn.Length);

                // Create a CryptoStream that decrypts the data
                CryptoStream cs = new CryptoStream(ms,
                    _cryptoProvider.CreateDecryptor(Key, IV),
                    CryptoStreamMode.Read);

                // Read the Crypto Stream
                StreamReader sr = new StreamReader(cs);

                return sr.ReadToEnd();
            }
            else
            {
                return """";
            }
        }

        public static NameValueCollection DecryptQueryString(string queryString)
        {
            if (queryString.Length != 0)
            {
                //Decode the string
                string decodedQueryString = HttpUtility.UrlDecode(queryString);

                //Decrypt the string
                string decryptedQueryString = StringHelpers.Decrypt(decodedQueryString);

                //Now split the string based on each parameter
                string[] actionQueryString = decryptedQueryString.Split(new char[] { QUERY_STRING_DELIMITER });

                NameValueCollection newQueryString = new NameValueCollection();

                //loop around for each name value pair.
                for (int index = 0; index &lt; actionQueryString.Length; index++)
                {
                    string[] queryStringItem = actionQueryString[index].Split(new char[] { '=' });
                    newQueryString.Add(queryStringItem[0], queryStringItem[1]);
                }

                return newQueryString;
            }
            else
            {
                //No query string was passed in.
                return null;
            }
        }

        public static string EncryptQueryString(NameValueCollection queryString)
        {
            //create a string for each value in the query string passed in.
            string tempQueryString = """";

            for (int index = 0; index &lt; queryString.Count; index++)
            {
                tempQueryString += queryString.GetKey(index) + ""="" + queryString[index];
                if (index != queryString.Count - 1)
                {
                    tempQueryString += QUERY_STRING_DELIMITER;
                }
            }

            return EncryptQueryString(tempQueryString);
        }

        /// &lt;summary&gt;
        /// You must pass in a string that uses the QueryStringHelper.DELIMITER as the delimiter.
        /// This will also append the ""?"" to the beginning of the query string.
        /// &lt;/summary&gt;
        /// &lt;param name=""queryString""&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string EncryptQueryString(string queryString)
        {
            return ""?"" + HttpUtility.UrlEncode(StringHelpers.Encrypt(queryString));
        }

        #endregion Methods
    }
}
</code></pre>

<p>Java Code</p>

<pre><code> public String decrypt(String text) throws Exception{

    //    byte[] keyBytess={some byte values};
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] keyBytes= new byte[16];
        byte[] b= { some byte values };
        byte[] iv = { some byte values };


        int len= b.length;
        if (len &gt; keyBytes.length) len = keyBytes.length;
        System.arraycopy(b, 0, keyBytes, 0, len);
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);

        BASE64Decoder decoder = new BASE64Decoder();
        byte [] results = cipher.doFinal(decoder.decodeBuffer(text));
        return new String(results,""UTF-8"");
    }

    public String encrypt(String text)
            throws Exception {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] keyBytes= new byte[16];
        byte[] b= { some byte values };
        byte[] iv = { some byte values };
        int len= b.length;
        if (len &gt; keyBytes.length) len = keyBytes.length;
        System.arraycopy(b, 0, keyBytes, 0, len);
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);
        byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
        BASE64Encoder encoder = new BASE64Encoder();
        return encoder.encode(results);
    }
</code></pre>

<p>In Case of C#
value= just4fun
and
ecncrypted value=  j/Rph4d/Op6sugBxZ/kJbA==</p>

<p>In Case of Java
value= just4fun 
and 
encrypted value= 8BfD/Jr0Hk35qn8DXwFHmA==</p>

<p>and when I am trying to decrypt C# encrypted value in java it giving javax.crypto.BadPaddingException: Given final block not properly padded</p>

<p>I have some restriction, I can't update C# code it is in use</p>
"	NULL	5	NULL	12:18.6	3	20:15.2	56:43.0	NULL	982149	8546927	0	1	0	<java><c#><encryption><rijndaelmanaged>	C# equivalent encryption decryption for Java	2953	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
46452354	46452499	1	"<p>I have an app on Google Play that updated yesterday and I have started getting numerous reports from Crashlytics where my app crashes only on Samsung devices with Android 4.x (4.1.2 - 4.4.4).</p>

<p>The trace of the exception is as follows:</p>

<pre><code>Fatal Exception: java.lang.RuntimeException: An error occured while executing doInBackground()
       at android.os.AsyncTask$3.done(AsyncTask.java:300)
       at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:355)
       at java.util.concurrent.FutureTask.setException(FutureTask.java:222)
       at java.util.concurrent.FutureTask.run(FutureTask.java:242)
       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:841)
Caused by java.lang.OutOfMemoryError
       at java.util.Arrays.copyOfRange(Arrays.java:2684)
       at com.android.org.conscrypt.OpenSSLCipher.engineDoFinal(OpenSSLCipher.java:467)
       at javax.crypto.Cipher.doFinal(Cipher.java:1204)
       at com.ijsoft.cpul.Util.DbMainFunctions.com.ijsoft.cpul.Util.AES256Cipher.decrypt(DbMainFunctions.java:2059)
       at com.ijsoft.cpul.Util.DbMainFunctions.initializeDb(DbMainFunctions.java:94)
       at com.ijsoft.cpul.SplashActivity$InitializeDb.doInBackground$9ecd34e(SplashActivity.java:2095)
       at android.os.AsyncTask$2.call(AsyncTask.java:288)
       at java.util.concurrent.FutureTask.run(FutureTask.java:237)
       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
       at java.lang.Thread.run(Thread.java:841)
</code></pre>

<p>In other cases I received the following trace:</p>

<pre><code>Fatal Exception: java.lang.RuntimeException: An error occured while executing doInBackground()
       at android.os.AsyncTask$3.done(AsyncTask.java:299)
       at java.util.concurrent.FutureTask$Sync.innerSetException(FutureTask.java:273)
       at java.util.concurrent.FutureTask.setException(FutureTask.java:124)
       at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:307)
       at java.util.concurrent.FutureTask.run(FutureTask.java:137)
       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:230)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1076)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:569)
       at java.lang.Thread.run(Thread.java:856)
Caused by java.lang.OutOfMemoryError
       at java.io.ByteArrayOutputStream.expand(ByteArrayOutputStream.java:91)
       at java.io.ByteArrayOutputStream.write(ByteArrayOutputStream.java:201)
       at com.ijsoft.cpul.Util.DbMainFunctions.initializeDb(DbMainFunctions.java:90)
       at com.ijsoft.cpul.SplashActivity$InitializeDb.doInBackground$9ecd34e(SplashActivity.java:2095)
       at android.os.AsyncTask$2.call(AsyncTask.java:287)
       at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:305)
       at java.util.concurrent.FutureTask.run(FutureTask.java:137)
       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:230)
       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1076)
       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:569)
       at java.lang.Thread.run(Thread.java:856)
</code></pre>

<p>I leave part of the code where the error occurs:</p>

<p><strong>AES256Cipher.java</strong></p>

<pre><code>public class AES256Cipher {
    public byte[] decrypt(byte[] textBytes, Context context)
            throws java.io.UnsupportedEncodingException,
            NoSuchAlgorithmException,
            NoSuchPaddingException,
            InvalidKeyException,
            InvalidAlgorithmParameterException,
            IllegalBlockSizeException,
            BadPaddingException {

        byte[] keyBytes = CommonFunctions.md5Package(context).getBytes();
        byte[] ivBytes = new byte[16];
        for (int j = 0; j &lt; keyBytes.length; j+=2) {
            ivBytes[j/2]=keyBytes[31-j];
        }

        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
        return cipher.doFinal(textBytes);
    }
}
</code></pre>

<p><strong>DbMainFunctions.java</strong></p>

<pre><code>public synchronized static int initializeDb(int release, Context context) {
        int resultCode = 0;
        try {
            // Get the encrypted json file (database) from Assets
            AssetManager am = context.getAssets();
            InputStream is = am.open(""assets"");
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buff = new byte[4096];
            int i;
            while ((i = is.read(buff, 0, buff.length)) &gt; 0) {
                baos.write(buff, 0, i);
            }
            is.close();
            baos.close();
            resultCode = updateDb(baos.toByteArray(), release, context);
            //baos.close();
        } catch (Exception e) {
            Log.e(""DbMainFunctions"", e.getMessage());
            //e.printStackTrace();
            resultCode = -1;
        }
        return resultCode;
    }

public synchronized static int updateDb(byte[] cipherJson, int release, Context context) {
        int resultCode = 0;
        AES256Cipher aes256;
        try {
            aes256 = new AES256Cipher();
            cipherJson = aes256.decrypt(cipherJson, context);
        } catch (UnsupportedEncodingException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {
            Log.e(""DbMainFuctions"", e.getMessage());
            return -2;
        }

     ...
}
</code></pre>

<p>My application does at that point is to get an encrypted file (filename: assets) with AES256 from the Assets directory included in the APK. The file is then decrypted and saved in a Byte Array. The file is approximately 4.4 MB in size. The initializeDb() method is called from an AsyncTask during doInBackground(), that is, all the previous code is executed in an AsyncTask</p>
"	NULL	0	NULL	58:56.3	3	05:39.1	NULL	NULL	0	4250422	0	1	2	<java><android><arrays><aes><samsung-mobile>	Android java.lang.OutOfMemoryError only on Samsung devices	484	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
46686358	46689184	1	"<pre><code>Cipher cipher = Cipher.getInstance(""AES256/CTR/NoPadding"")
</code></pre>

<p>The above code throws the following exception:</p>

<blockquote>
  <p>Stack trace: java.security.NoSuchAlgorithmException:
  AES256/CTR/NoPadding   at
  javax.crypto.Cipher.getCipher(Cipher.java:296)   at
  javax.crypto.Cipher.getInstance(Cipher.java:174)</p>
</blockquote>

<p>Does Android support ""AES256/CTR/NoPadding""?  Is this device dependent?  The Android device I am testing has the following providers:</p>

<ul>
<li>AndroidOpenSSL version 1.0 </li>
<li>DRLCertFactory version 1.0</li>
<li>BC version 1.47</li>
<li>Crypto version 1.0</li>
<li>HarmonyJSSE version 1.0</li>
</ul>
"	NULL	0	NULL	50:37.3	3	04:45.3	NULL	NULL	0	355456	0	1	3	<android><security><encryption>	Does Android support AES256/CTR/NoPadding?	1084	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
47243228	47243396	1	"<p>I wanted to try my hand at encrypting a file and utilized the following stack overflow <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption?rq=1"">response</a>.  However, while testing out the initialization vector, I found it only effected the first 16 bytes.</p>

<p>When I pass an empty iv to the decrypt cipher (other than the first 16 bytes) the data was unexpectedly decrypted.  <em>[I assume the library isn't broke and that I'm doing something improperly; but it's a scary thought that others may be in the same boat and not realize it.]</em></p>

<p>Example:<pre>
<code>    Initial bytes ..... 2222222222222222222222222222222222222222222222222222
    Encrypted bytes ... b35b3945cdcd08e2f8a65b353ff754c32a48d9624e16b616d432
    Decrypted bytes ... 3c4154f7f33a2edbded5e5af5d3d39b422222222222222222222
</code></pre>
Q: Why isn't the entire decryption failing?</p>

<p><em>Speculation: I suppose I could do the encryption by iterating over the data 16 bytes at a time and updating the iv each round by hashing the prior encrypted 16 byte block.  However, that seems to be busy work that I would have expected the library to do.  And I would have expected it to have been mentioned by the experts that present implementation guidelines.  But I'm just grasping at straws here.  For all I know, maybe the security community is only worried about a hack on the first block.</em></p>

<p>Note: Just now I found a 5.5 year old stack overflow <a href=""https://stackoverflow.com/questions/10557784/initialization-vector-length-in-aes"">post</a> that identified this same issue; and unfortunately it still does not have a response.</p>

<p><pre><code></p>

<code>package test;

import java.security.AlgorithmParameters;
import java.security.spec.KeySpec;
import java.util.Formatter;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/*
 * Issue: Using ""AES/CBC/PKCS5Padding"" encryption, the Initialization Vector
 *        appears to only affect the first block?!? 
 * 
 * Example Output
 *    iv 1e6376d5d1180cf9fcf7c78d7f1f1b96
 *    bv 00000000000000000000000000000000
 *    I: 222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
 *    E: b35b3945cdcd08e2f8a65b353ff754c32a48d9624e16b616d432ee5f78a26aa295d83625634d1048bf2dbb51fc657b7f796b60066129da5e1e7d3c7b51a30c1d962db75ac6666d4b32513c154b47f18eb66f62d7417cfd77f07f81f27f08d7d818e6910ca5849da3e6cff852bc06317e2d51907879598c8d3ae74074f4c27f7b8e2f74ca04d3ed6ac839b819a0f4cb462d0a4d9497cd917b8bd0aafb590ddd593b5b652cf8f642d3b2cd9dc0981dc1c913d52d065a844ea65e72cd7738eee3b488c4304e884109320dc54668ac4659d6014de9cf19422f7f68157d4330478589533571434d07b1939e56259fb8828823361bc912b84dc6ccdd5878b1d05801e0a6ce099bc86f1356fd145338163d59a07f2efdb1a6f91f4a35e6304f2d15d9972b0dda3c2275b5942a7f032ab6f90138
 *    D: 3c4154f7f33a2edbded5e5af5d3d39b42222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
 */
public class IvBug {

    public static void main(String[] args) throws Exception {
        // Initialize.
        final char[] password = ""foo"".toCharArray();
        final byte[] salt = ""bar"".getBytes();

        byte[] iData = new byte[300];
        java.util.Arrays.fill(iData, (byte)0x22);               // Make the issue easy to see.
//      for (int i=0; i&lt;msg.length; i++) msg[i] = (byte) i;     // Alternate fill.

        // Perform the test.
        SecretKey sKey = generateKey(password,salt);
        byte[] iv = generateIv(sKey);
        byte[] eData = encrypt(sKey, iData, iv);
        byte[] badIv = new byte[iv.length];             // Discard initialization vector.
        byte[] dData = decrypt(sKey, eData, badIv);

        // Display the results.
        System.out.println(""iv "" + hexStr(iv));
        System.out.println(""bv "" + hexStr(badIv));
        System.out.println(""I: "" + hexStr(iData));      // Initial
        System.out.println(""E: "" + hexStr(eData));      // Encrypted
        System.out.println(""D: "" + hexStr(dData));      // Decrypted
    }

    static SecretKey generateKey(char[] password, byte[] salt) throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
        KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);
        SecretKey tmp = factory.generateSecret(spec);
        return new SecretKeySpec(tmp.getEncoded(), ""AES"");
    }

    static byte[] generateIv(SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        AlgorithmParameters params = cipher.getParameters();
        return params.getParameterSpec(IvParameterSpec.class).getIV();
    }

    static byte[] encrypt(SecretKey key, byte[] data, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        return cipher.doFinal(data);
    }

    static byte[] decrypt(SecretKey key, byte[] data, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        return cipher.doFinal(data);
    }

    static String hexStr(byte[] bytes) {
        try (Formatter formatter = new Formatter()) {
            for (byte b : bytes) formatter.format(""%02x"", b);
            return formatter.toString();
        }
    }
}
</code></pre>

<p></code></p>
"	NULL	0	NULL	00:55.7	3	22:06.2	15:03.4	NULL	8925652	8925652	0	1	5	<java><encryption><cryptography><initialization-vector>	Cryptography: Why does my encryption initialization vector only effect the first 16 bytes?	1289	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
47302221	0	0	"<p>I am trying to write a code which will do a AES 256 encryption and decryption.I have installed the JCE jars in the security folder under jre/lib. But then also i am getting  Illegal key size or default parameters , I have tried all solution but i can not make it working.Please excuse me if this question is a silly one, i am very new to this cryptography. </p>

<p>I am giving my code </p>

<p>This is my Cipher</p>

<pre><code>public  Cipher getCipher(int mode) throws Exception {

      Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"", new SunJCE());
      //a random Init. Vector. just for testing
      byte[] iv = listOfDecodedkeys.get(0).getBytes(AbstractSecurity.UTF_ENCODING);
      c.init(mode, generateKey(), new IvParameterSpec(iv));
      return c;
  }
</code></pre>

<p>This is the key generation method</p>

<pre><code> private   Key generateKey() throws Exception {
      //PBKDF2WithHmacSHA256
      //SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
      SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA512"");
      char[] password = listOfDecodedkeys.get(1).toCharArray();
      byte[] salt = listOfDecodedkeys.get(2).getBytes(AbstractSecurity.UTF_ENCODING);
      KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
      SecretKey tmp = factory.generateSecret(spec);
      byte[] encoded = tmp.getEncoded();
      return new SecretKeySpec(encoded, ""AES"");

  }
</code></pre>

<p>This is my encrypter </p>

<pre><code>@Override
public String encrypt(String strToDecrypt) throws Exception{
    Cipher c = getCipher(Cipher.ENCRYPT_MODE);
    byte[] encryptedVal = c.doFinal(strToDecrypt.getBytes(AbstractSecurity.UTF_ENCODING));
    return new sun.misc.BASE64Encoder().encode(encryptedVal);
}
</code></pre>

<p>This is my decrypter </p>

<pre><code> public  String decrypt(String encrypted) throws Exception {
      Cipher c = super.getCipher(Cipher.DECRYPT_MODE);
      byte[] decodedValue = new sun.misc.BASE64Decoder().decodeBuffer(encrypted);
      byte[] decValue = c.doFinal(decodedValue);
      return new String(decValue);
  }
</code></pre>

<p>Now i am getting below exception</p>

<pre><code>Exception in thread ""main"" java.security.NoSuchAlgorithmException: PBKDF2WithHmacSHA512 SecretKeyFactory not available
at javax.crypto.SecretKeyFactory.&lt;init&gt;(Unknown Source)
at javax.crypto.SecretKeyFactory.getInstance(Unknown Source)
at com.aes.security.AbstractSecurity.generateKey(AbstractSecurity.java:198)
at com.aes.security.AbstractSecurity.getCipher(AbstractSecurity.java:187)
at com.aes.security.SecurityService.encrypt(SecurityService.java:76)
at com.aes.security.SecurityService.main(SecurityService.java:165)
</code></pre>

<p>If i change the SecretKeyFactory to PBKDF2WithHmacSHA1 i am getting </p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size
at javax.crypto.Cipher.a(Unknown Source)
at javax.crypto.Cipher.init(Unknown Source)
at javax.crypto.Cipher.init(Unknown Source)
at com.aes.security.AbstractSecurity.getCipher(AbstractSecurity.java:184)
at com.aes.security.SecurityService.encrypt(SecurityService.java:76)
at com.aes.security.SecurityService.main(SecurityService.java:165)
</code></pre>

<p>How to solve this </p>
"	NULL	6	NULL	04:52.0	4	16:24.2	16:24.2	NULL	2427078	2427078	0	1	1	<java><encryption><cryptography>	How to solve Illegal key size or default parameters in AES - 256 || JCE files installed	1186	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
48158528	48159293	1	"<p>I have created the following python code
    import base64</p>

<pre><code>from django.conf import settings
from Crypto.Cipher import AES

BS = 16


def pad(s):
    return s + (BS - len(s) % BS) * chr(BS - len(s) % BS)

def unpad(s):
    return s[0:-s[-1]]

class AESCipher:
    def __init__(self):
         self.key = settings.SECRET_KEY

    def encrypt(self, raw):
        raw = pad(raw)
        iv = settings.SECRET_IV.encode('utf-8')
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return base64.b64encode(cipher.encrypt(raw))

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = settings.SECRET_IV.encode('utf-8')
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return unpad(cipher.decrypt(enc))

    def encryptstring(self, raw):
        raw = self.encrypt(raw)
        raw = raw.decode('utf-8')
        return raw

    def decryptstring(self, raw):
        raw = raw.encode('utf-8')
        raw = self.decrypt(raw)
        raw = raw.decode('utf-8')
        return raw
</code></pre>

<p>This code returns a base64 encrypted string (i.e. <code>VgRaS+J3MSmguabaf+9fJw==</code>).</p>

<p>I have also created a java function, that should create the same thing, but it doesn't match. </p>

<pre><code>    public void login() {
    SecretKeySpec keySpec;
    IvParameterSpec ivSpec;
    Cipher cipher;

    String key = """";
    String iv = """";

    try {
        keySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        ivSpec = new IvParameterSpec(iv.getBytes());
        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");

        String test = ""Test"";
        String newString = """";
        char paddingChar = ' ';
        int size = 16;
        int x = test.length() % size;
        int padLength = size - x;
        for (int i = 0; i &lt; padLength; i++) {
            newString += paddingChar;
//                test += paddingChar;
        }
        newString += test;

        byte[] res;

        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
        res = cipher.doFinal(newString.getBytes());
        for(int i = 0; i &lt; res.length; i++) {
            System.out.print(res[i] + "", "");
        }

        System.out.println("""");
        System.out.println(bytesToHex(res));
        String base = Base64.encodeToString(res, Base64.DEFAULT);
        System.out.println(base);

//          TODO: VgRaS+J3MSmguabaf+9fJw==
        //    OyuUHNsBQ3Zuy4UGY4fUdQ==
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>The result I get there is <code>2mdRXydTCAYG+Tp0kE/NoQ==</code>. It looks similar, but it isn't. I have checked the keys, they are the same. I have swapped them around, to make sure that wasn't the problem either. I have tried different cipher modes (<code>AES/CBC/ISO10126Padding</code> and <code>AES/CBC/PKCS5Padding</code>) both without result. I have tried to do it with plain AES, no success either. I tried to get <code>AES_128/CBC/NoPadding</code> and <code>AES_256/CBC/NoPadding</code> to work, but for some reason it tells me <code>java.security.NoSuchAlgorithmException: No provider found for AES_256/CBC/NoPadding</code>.</p>

<p>I am lost, I hope someone can help! Thanks in advance!</p>
"	NULL	9	NULL	46:40.6	0	04:06.9	NULL	NULL	0	5530076	0	1	-1	<java><python><encryption>	Android AES encryption with python AES encryption	435	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
48306345	48337720	1	"<p>I want users to select images/videos from gallery and secure their images within my app. for that, I encrypt those images. Encryption over images works correctly(I think so !). It takes 1.5 to 2 seconds for 8MB image. but what about videos ? videos might be in GBs. So it would take a lot time. And even in encryption/decryption I have to perform action on every single image, that can cause memory issue. <a href=""https://stackoverflow.com/questions/28015194/android-aes-128-encryption-decryption-of-file-is-very-slow-how-can-i-increase-t"">This</a> link helped me to achieve this.</p>

<p>If you see, ES file explorer also provides encryption and decryption on images/videos. and it completes operation of GBs within just few seconds. So can I know which technique/algorithm these guys use ?</p>

<p>or even if I use my own way, is there any trick to make it faster ? or is there any other way to make file inaccessible to user ? Changing MIME type will work ? </p>

<p>Even if I change extension or make it hidden by adding . before the file name, user can still view images in some file explorer.</p>

<p>Actually for <code>xamarin</code>, I didn't find any post/blog related to encrypting decrypting file. All they provide is solution on string.</p>

<p>i would really appreciate if someone guides me for this issue.</p>

<p><strong>EDIT</strong></p>

<p>Hello, @Joe Lv, As I said I tried your method in which encryption was slow but decryption was very fast. So I implemented the same decryption technique you used to encrypt things. And It works !! but I want to know if this is valid or not.</p>

<p>Now my encrypt method looks like this :</p>

<pre><code>public void encrypt(string filename)
    {

        // Here you read the cleartext.
        try
        {
            File extStore = Environment.GetExternalStoragePublicDirectory(Environment.DirectoryMovies);
            startTime = System.DateTime.Now.Millisecond;
            Android.Util.Log.Error(""Encryption Started"", extStore + ""/"" + filename);

            // This stream write the encrypted text. This stream will be wrapped by
            // another stream.
        //    createFile(filename, extStore);
        //    System.IO.FileStream fs=System.IO.File.OpenRead(extStore + ""/"" + filename);
      //      FileOutputStream fos = new FileOutputStream(extStore + ""/"" + filename + "".aes"", false);

            FileInputStream fis = new FileInputStream(filepath);


            FileOutputStream fos = new FileOutputStream(filepath, false);
            System.IO.FileStream fs = System.IO.File.OpenWrite(filepath + filename);
            // Create cipher

            // Length is 16 byte
            Cipher cipher = Cipher.GetInstance(""AES/CBC/PKCS5Padding"");
            byte[] raw = System.Text.Encoding.Default.GetBytes(sKey);
            SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
            IvParameterSpec iv = new IvParameterSpec(System.Text.Encoding.Default.GetBytes(ivParameter));//
            cipher.Init(CipherMode.EncryptMode, skeySpec, iv);

            // Wrap the output stream
           // CipherInputStream cis = new CipherInputStream(fs, cipher);
            CipherOutputStream cos = new CipherOutputStream(fs, cipher);

            // Write bytes
            int b;
            byte[] d = new byte[512 * 1024];
            while ((b = fis.Read(d)) != -1)
            {
                cos.Write(d, 0, b);
            }
            // Flush and close streams.
            fos.Flush();
            fos.Close();
            cos.Close();
   fis.Close();

            stopTime = System.DateTime.Now.Millisecond;
            Android.Util.Log.Error(""Encryption Ended"", extStore + ""/5mbtest/"" + filename + "".aes"");
            Android.Util.Log.Error(""Time Elapsed"", ((stopTime - startTime) / 1000.0) + """");
        }
        catch (Exception e)
        {
            Android.Util.Log.Error(""lv"",e.Message);
        }

    }
</code></pre>
"	NULL	4	NULL	00:49.4	0	54:20.0	54:20.0	NULL	4540799	4540799	0	1	1	<c#><android><encryption><xamarin.android>	Xamarin.android- how to make encryption/decryption of images faster	2193	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
48463515	0	1	"<p>I am using below code for encryption &amp; decryption in Spring boot project with conveter annotation on attributes which I want to encrypt &amp; decrypt</p>

<pre><code>import org.apache.commons.codec.binary.Base64;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.persistence.AttributeConverter;
import javax.persistence.Converter;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;

@Converter
public class CryptoConverter implements AttributeConverter&lt;String, String&gt; {

    @Override
    public String convertToDatabaseColumn(String attribute) {
        if(attribute == null){
            return null;
        }
        try {
        byte[] ivBytes;
        //String password=""Hello"";
        String password = EncryptionUtil.key.get();
        SecureRandom random = new SecureRandom();
        byte bytes[] = new byte[20];
        random.nextBytes(bytes);
        byte[] saltBytes = bytes;
// Derive the key
        SecretKeyFactory factory = null;

            factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(),saltBytes,65556,256);
        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

            //encrypting the word
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secret);
            AlgorithmParameters params = cipher.getParameters();
            ivBytes =   params.getParameterSpec(IvParameterSpec.class).getIV();
            byte[] encryptedTextBytes =  cipher.doFinal(attribute.getBytes(""UTF-8""));
            //prepend salt and vi
            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];
            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);
            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);
            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length, encryptedTextBytes.length);
            return new Base64().encodeToString(buffer);

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (InvalidParameterSpecException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public String convertToEntityAttribute(String dbData) {

        if(dbData == null){
            return null;
        }

        try {
            String password = EncryptionUtil.key.get();
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        //strip off the salt and iv
        ByteBuffer buffer = ByteBuffer.wrap(new Base64().decode(dbData));
        byte[] saltBytes = new byte[20];
        buffer.get(saltBytes, 0, saltBytes.length);
        byte[] ivBytes1 = new byte[cipher.getBlockSize()];
        buffer.get(ivBytes1, 0, ivBytes1.length);
        byte[] encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes1.length];

        buffer.get(encryptedTextBytes);
        // Deriving the key
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes, 65556, 256);
        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes1));
        byte[] decryptedTextBytes = null;

            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);


        return new String(decryptedTextBytes);

        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>The issue is this code takes a lot of time to encrypt &amp; decrypt.</p>

<p>With this I am getting a serious performance hit.</p>
"	NULL	3	NULL	36:47.8	0	01:00.6	01:00.6	NULL	1033581	2477215	0	1	0	<java><encryption><cryptography>	AES Encryption Decryption takes longer time	891	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
48886992	48900403	1	"<p>I'm trying to generate AES key of size 256 bit and I downloaded the JCE security policy of version 8 and I placed the US_export_policy.jar and the local_policy.jar in the jre/lib/security folder. Is there anything I've left out in the code and what could be the cause for the exception?</p>

<p>This is what I've coded and it gives me an illegal key size exception.</p>

<p>Here's the code : </p>

<pre><code>            kgen = KeyGenerator.getInstance(""AES"");
            kgen.init(256);
            SecretKey skey = kgen.generateKey();
            byte[] iv = new byte[16];
            SecureRandom srandom = new SecureRandom();
            srandom.nextBytes(iv);
            IvParameterSpec ivspec = new IvParameterSpec(iv);
            System.out.println(iv);
</code></pre>

<p>Here, iv is the initialization vector that I'm using further in the code. </p>

<p>Would greatly appreciate your help and thanks in advance.</p>

<p>This is exception I'm getting : </p>

<pre><code>java.security.InvalidKeyException: Illegal key size
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1039)
    at javax.crypto.Cipher.implInit(Cipher.java:805)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1396)
    at javax.crypto.Cipher.init(Cipher.java:1327)
    at com.global.DocMananger.Crypto.main(Crypto.java:145)
</code></pre>

<p>This is the line that's throwing the error :</p>

<pre><code>Cipher cipherAES = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipherAES.init(Cipher.ENCRYPT_MODE, skey, ivspec);
</code></pre>
"	NULL	12	NULL	00:05.5	0	36:02.5	30:44.2	NULL	9184839	9184839	0	1	0	<java><encryption><aes>	java : invalid key size while using aes encryption after using JCE security policy version 8	476	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
49527460	0	1	"<p>I need to encrypt the ACCESS_TOKEN. While decrypting, getting error:
 ** error:0407806d:RSA routines:decrypt:DATA_LEN_NOT_EQUAL_TO_MOD_LEN**</p>

<blockquote>
  <p>private String ACCESS_TOKEN = ""bearer
  nG25Uokr3eF0WAisEcoS4hb1isLwR2qbOGu3UnwARGfeBNlP7RToSf3DCmowl99-TX0nrwL1qElIRZALFNbBXQPL6weVhJk9LRjJAoD9oBlTPtfDNMAZXlLqBqWnYZoxNyfQoPUE_Y0iMBcj_j6RqOfJc4Npid7Wo1AoipXOPYt1JLMfdHN9TZvtn6SxNP9UFipDANkcnHsurDwjPV_X0PdzyqsgXuoIjfAQLd7IonVYGZYmB_SYO68q5CorhH7hA01iIm7TDeUrOAM1p2C9W84rV6nMzMZS-7LPoweMWPxaLHcj15ex3TR16PGNGwbfiRPMLxNjmpqQEi3Mfqax2mk9qHL6LNb-OQK_5y9Zo9w1nC55iQhM-PbF96kgYa5zM2o94yI1IhcWAs-fJEe5tPsT3Dj_QfLWeNVblzDysfNwNajCGnauuPLzG-5qrGgNRtw0Dou8eNhk1lplDXxqu-G9kRyK1KKnPtuyCawzEJ_-4aEHdeA3-QSEqWCphu6w"";</p>
</blockquote>

<p>Please refer the code:</p>

<pre><code>import android.util.Base64;

import com.itc.classmate.application.MyApplication;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * 
 */

public enum EncryptMoreThn256Byte {
    INSTANCE;
    private SecretKey secKey;
   // private String ACCESS_TOKEN = ""bearer nG25Uokr3eF0WAisEcoS4hb1isLwR2qbOGu3UnwARGfeBNlP7RToSf3DCmowl99-TX0nrwL1qElIRZALFNbBXQPL6weVhJk9LRjJAoD9oBlTPtfDNMAZXlLqBqWnYZoxNyfQoPUE_Y0iMBcj_j6RqOfJc4Npid7Wo1AoipXOPYt1JLMfdHN9TZvtn6SxNP9UFipDANkcnHsurDwjPV_X0PdzyqsgXuoIjfAQLd7IonVYGZYmB_SYO68q5CorhH7hA01iIm7TDeUrOAM1p2C9W84rV6nMzMZS-7LPoweMWPxaLHcj15ex3TR16PGNGwbfiRPMLxNjmpqQEi3Mfqax2mk9qHL6LNb-OQK_5y9Zo9w1nC55iQhM-PbF96kgYa5zM2o94yI1IhcWAs-fJEe5tPsT3Dj_QfLWeNVblzDysfNwNajCGnauuPLzG-5qrGgNRtw0Dou8eNhk1lplDXxqu-G9kRyK1KKnPtuyCawzEJ_-4aEHdeA3-QSEqWCphu6w"";
  //  private String initialText = ""this is working"";

    private EncryptMoreThn256Byte() {
        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""called constructor of EncryptMoreThn256Byte"");
        KeyGenerator generator = null;
        try {
            generator = KeyGenerator.getInstance(""AES"");
            generator.init(128); // The AES key size in number of bits
            secKey = generator.generateKey();
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""EncryptMoreThn256Byte: secKey+++ "" + secKey.getEncoded());

//            SecureRandom random = new SecureRandom();
//            byte[] salt = new byte[(256/8)];
//            random.nextBytes(salt);
//            KeySpec keySpec = new PBEKeySpec(initialText.toCharArray(), salt, 1000, 256);
//            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
//            byte[] decrptedSecrateKey = keyFactory.generateSecret(keySpec).getEncoded();
//           // secKey = new SecretKeySpec(decrptedSecrateKey, ""AES"");
//            secKey = new SecretKeySpec(decrptedSecrateKey, 0, decrptedSecrateKey.length, ""AES"");
        } catch (Exception e) {
            AppLog.errLog(EncryptMoreThn256Byte.class.getSimpleName(), e.getMessage());
        }
    }


    public String encryptAccessTokenUsingAES(String plainText) {
        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptAccessTokenUsingAES: plainText "" + plainText);

        if (plainText != null || !plainText.isEmpty()) {
            String encrytedSecretKey = SharedPreferences.getInstance(MyApplication.getInstance().getApplicationContext()).getEncrytedSecretKey();
            if (encrytedSecretKey != null) {
                AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptAccessTokenUsingAES: encrytedSecretKey &gt;+++ "" + encrytedSecretKey);
                byte[] decrptedSecrateKey = decryptSecretKeyUsingRSA(encrytedSecretKey);
                if (decrptedSecrateKey != null) {
                    secKey = new SecretKeySpec(decrptedSecrateKey, 0, decrptedSecrateKey.length, ""AES"");
                }
            } else {
                encryptSecretKeyUsingRSA(secKey);
            }

            String str = new String(encryptText(secKey, plainText));
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""final encryptAccessTokenUsingAES is: "" + str);
            return str;
        }

        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptAccessTokenUsingAES: value "" + null);
        return null;
    }


    public String decryptAccessTokenUsingAES(String encrptedAssessToken) {
        String encrpted_secretkey = SharedPreferences.getInstance(MyApplication.getInstance().getApplicationContext()).getEncrytedSecretKey();
        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptAccessTokenUsingAES encrpted_secretkey:: "" + encrpted_secretkey);
        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptAccessTokenUsingAES accesstoken:: "" + encrptedAssessToken);
        if (encrpted_secretkey != null) {
            byte[] decrptedSecrateKey = decryptSecretKeyUsingRSA(encrpted_secretkey);
            if (decrptedSecrateKey != null) {
                SecretKey secKey = new SecretKeySpec(decrptedSecrateKey, 0, decrptedSecrateKey.length, ""AES"");
                AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptAccessTokenUsingAES secKey.getEncoded():: "" + secKey.getEncoded());
                String str = decryptText(secKey, encrptedAssessToken);
                AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""final decryptAccessTokenUsingAES is: "" + str);
                return str;
            }
        }
        return null;
    }

    private byte[] encryptSecretKeyUsingRSA(SecretKey secKey) {
        AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA SecretKey:: "" + secKey);
        KeyPairGenerator kpg = null;
        byte[] encryptedSecrteKey = null;
        try {
            kpg = KeyPairGenerator.getInstance(""RSA"");
            kpg.initialize(2048);
            KeyPair keyPair = kpg.generateKeyPair();
            PublicKey puKey = keyPair.getPublic();
            Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            cipher.init(Cipher.PUBLIC_KEY, puKey);
            //AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA secKey.getEncoded():: "" + secKey.getEncoded());
            //AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA secKey.getEncoded().length:: "" + secKey.getEncoded().length);
            //byte[] encryptedSecrteKey = cipher.doFinal(secKey.getEncoded());
            //byte[] encryptedSecrteKey=cipher.doFinal(initialText.getBytes(""UTF-8""));
            encryptedSecrteKey = cipher.doFinal(secKey.getEncoded());
            // String str =  Base64.encodeToString(encryptedSecrteKey, Base64.DEFAULT);
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA encryptedSecrteKey[]:: "" + encryptedSecrteKey.length);
            //AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA encrytionSecretKey:: "" + str);
            //AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA encrytionSecretKey length:: "" + str.length());
            SharedPreferences.getInstance(MyApplication.getInstance().getApplicationContext()).setEncrytedSecretKey(encryptedSecrteKey.toString());
        } catch (Exception e) {
            AppLog.errLog(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptSecretKeyUsingRSA::+"" + e.getMessage());
        } finally {
            return encryptedSecrteKey;
        }
    }


    private byte[] decryptSecretKeyUsingRSA(String encryptSecretKey) {
        KeyPairGenerator kpg = null;
        byte[] bytes = null;
        try {
            kpg = KeyPairGenerator.getInstance(""RSA"");
            kpg.initialize(2048);
            KeyPair keyPair = kpg.generateKeyPair();
            PrivateKey prKey = keyPair.getPrivate();
            Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
            cipher.init(Cipher.PRIVATE_KEY, prKey);
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptSecretKeyUsingRSA encryptSecretKey.getBytes():: "" + encryptSecretKey.getBytes());
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptSecretKeyUsingRSA encryptSecretKey.getBytes().length:: "" + encryptSecretKey.getBytes().length);
           // bytes = cipher.doFinal(Base64.decode(encryptSecretKey, Base64.DEFAULT));
            bytes = cipher.doFinal(encryptSecretKey.getBytes());
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptSecretKeyUsingRSA cipher.doFinal(encryptSecretKey.getBytes():: "" + bytes.toString());
        } catch (Exception e) {
            AppLog.errLog(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptSecretKeyUsingRSA++++ "" + e.getMessage());
        }
        return bytes;
    }


    private byte[] encryptText(SecretKey pSecKey, String plainText) {
        byte[] encryptAccessToken = null;
        try {
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptText::secKey: "" + pSecKey.getEncoded());
            Cipher aesCipher = Cipher.getInstance(""AES"");
            aesCipher.init(Cipher.ENCRYPT_MODE, pSecKey);
            encryptAccessToken = aesCipher.doFinal(plainText.getBytes());
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptText:::: "" + encryptAccessToken.toString());
        } catch (Exception e) {
            AppLog.errLog(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptTextUsingAES "" + e.getMessage());
        }
        return encryptAccessToken;
    }

    /**
     * Convert bytes to AES SecertKey so we can decrypt access token
     *
     * @return
     */
    private String decryptText(SecretKey originalKey, String decryptedAccessToken) {
        byte[] bytePlainText = null;
        try {
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptText::originalKey: "" + originalKey.getEncoded());
            //SecretKey originalKey = new SecretKeySpec(decryptedKey, 0, decryptedKey.length, ""AES"");
            Cipher aesCipher = null;
            aesCipher = Cipher.getInstance(""AES"");
            aesCipher.init(Cipher.DECRYPT_MODE, originalKey);
            bytePlainText = aesCipher.doFinal(decryptedAccessToken.getBytes());
            AppLog.log(EncryptMoreThn256Byte.class.getSimpleName(), ""decryptText bytePlainText:: "" + bytePlainText.toString());
        } catch (Exception e) {
            AppLog.errLog(EncryptMoreThn256Byte.class.getSimpleName(), ""encryptTextUsingAES "" + e.getMessage());
        }
        return new String(bytePlainText);
    }


    private byte[] encrytAT(String plaintext, String password) throws InvalidAlgorithmParameterException, InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[(256 / 8)];
        random.nextBytes(salt);
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, 1000, 256);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();
        SecretKey key = new SecretKeySpec(keyBytes, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        byte[] iv = new byte[cipher.getBlockSize()];
        random.nextBytes(iv);
        IvParameterSpec ivParams = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
        return cipher.doFinal(plaintext.getBytes(""UTF-8""));
    }

}
</code></pre>

<p>Also find the log for the same code:</p>

<pre class=""lang-none prettyprint-override""><code>03-28 11:47:59.536 12795-12795/? D/debug_log: EncryptMoreThn256Byte :encryptAccessTokenUsingAES: encrytedSecretKey &gt;+++ [B@b56ec6b 03-2811:48:00.803 12795-12795/? D/debug_log: EncryptMoreThn256Byte :decryptSecretKeyUsingRSA encryptSecretKey.getBytes():: [B@43f8244
03-28 11:48:00.804 12795-12795/? D/debug_log: EncryptMoreThn256Byte :decryptSecretKeyUsingRSA encryptSecretKey.getBytes().length:: 10 03-2811:48:00.804 12795-12795/? E/error_log: Exception from:EncryptMoreThn256Byte : decryptSecretKeyUsingRSA++++error:0407806d:RSA routines:decrypt:DATA_LEN_NOT_EQUAL_TO_MOD_LEN
03-28 11:48:00.805 12795-12795/? D/debug_log: EncryptMoreThn256Byte :encryptText::secKey: [B@d535f2d 
03-28 11:48:00.808 12795-12795/? D/debug_log: EncryptMoreThn256Byte : encryptText:::: [B@d4d6c62 03-2811:48:00.808 12795-12795/? D/debug_log: EncryptMoreThn256Byte : finalencryptAccessTokenUsingAES is: (???(z??RW?D 
03-28 11:48:00.808 12795-12795/? D/debug_log: MyApplication : EncryptMoreThn256Byte +++str (???(z??RW?D 
03-28 11:48:00.808 12795-12795/? D/debug_log:EncryptMoreThn256Byte : decryptAccessTokenUsingAESencrpted_secretkey:: [B@b56ec6b 
03-28 11:48:00.808 12795-12795/? D/debug_log: EncryptMoreThn256Byte : decryptAccessTokenUsingAESaccesstoken:: (???(z??RW?D 
03-28 11:48:03.539 12795-12795/? D/debug_log: EncryptMoreThn256Byte : decryptSecretKeyUsingRSAencryptSecretKey.getBytes():: [B@6c931f3 
03-28 11:48:03.540 12795-12795/? D/debug_log: EncryptMoreThn256Byte :decryptSecretKeyUsingRSA encryptSecretKey.getBytes().length:: 10 03-2811:48:03.540 12795-12795/? E/error_log: Exception from:EncryptMoreThn256Byte : decryptSecretKeyUsingRSA++++error:0407806d:RSA routines:decrypt:DATA_LEN_NOT_EQUAL_TO_MOD_LEN
03-28 11:48:03.540 12795-12795/? D/debug_log: MyApplication :EncryptMoreThn256Byte +++ dep null
</code></pre>
"	NULL	5	NULL	22:38.8	0	46:04.8	51:24.9	NULL	238704	9520307	0	1	2	<android><rsa><android-keystore><android-security>	Error: RSA routines:decrypt:DATA_LEN_NOT_EQUAL_TO_MOD_LEN	1982	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
49975231	0	1	"<p>I am attempting to encrypt a string using below method. this method worked successfully before. After Windows OS security patch now i am getting ""java.security.InvalidKeyException: Illegal key size""</p>

<p>Also i have added local_policy &amp; US_export_policy jar files under C:\Program Files (x86)\Java\jdk1.7.0_67\jre\lib\security. My OS is Windows7 64 bit.</p>

<p>Its working when i run through Java main method, but when i run through tomcat application i get below exception.</p>

<pre><code>public static String encryptData() throws Exception{
        byte[] saltBytes = ""myegaes256encryption"".getBytes(""UTF-8"");
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec keySpec = new PBEKeySpec(""myeg@1234"".toCharArray(), saltBytes, 65536, 256);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(""myegaes256ivspec"".getBytes(""UTF-8""));
        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        //Encryption starts here
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);

        byte[] encryptedBytes = cipher.doFinal(""DD3E5B7BB7D3036FE7CB557B4FEEB05F"".getBytes(""UTF-8""));
        return new Base64().encodeAsString(encryptedBytes);
    }
</code></pre>

<p><strong>Exception:</strong></p>

<blockquote>
  <p>java.security.InvalidKeyException: Illegal key size   at
  javax.crypto.Cipher.a(Unknown Source)     at
  javax.crypto.Cipher.a(Unknown Source)     at
  javax.crypto.Cipher.a(Unknown Source)     at
  javax.crypto.Cipher.init(Unknown Source)  at
  javax.crypto.Cipher.init(Unknown Source)</p>
</blockquote>
"	NULL	0	NULL	07:09.5	0	01:51.1	01:51.1	NULL	7333386	7333386	0	1	0	<java><encryption><cryptography>	java.security.InvalidKeyException: Illegal key size - After Windows OS security patch	210	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
50199158	50199875	1	"<p>I am trying to reuse an AES implementation with Initialization Vector. So far I am only implementing the part where data is being encrypted on the android application and being decrypted on the php server. However, the algorithm has a major loophole, that the Initialization Vector is constant, which I just recently found out is a major security flaw. Unfortunately I have already implemented it on every single activity of my application and all scripts on the server side. 
I wanted to know if there was a way to modify this code so that the initialization vector is randomized, and some way to send that vector to the server (or vice versa), so that every time the message is encrypted the pattern keeps changing. Here are my codes for Android and PHP:</p>

<p>Android:</p>

<pre><code>package com.fyp.merchantapp;

// This file and its contents have been taken from http://www.androidsnippets.com/encrypt-decrypt-between-android-and-php.html 
//Ownership has been acknowledged

import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {
static char[] HEX_CHARS = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};

private String iv = ""MyNameIsHamza100"";//(IV)
private IvParameterSpec ivspec;
private SecretKeySpec keyspec;
private Cipher cipher;

private String SecretKey = ""MyNameIsBilal100"";//(SECRETKEY)

public MCrypt()
{
    ivspec = new IvParameterSpec(iv.getBytes());

    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
    try {
        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

public byte[] encrypt(String text) throws Exception
{
    if(text == null || text.length() == 0)
        throw new Exception(""Empty string"");

    byte[] encrypted = null;

    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e)
    {
        throw new Exception(""[encrypt] "" + e.getMessage());
    }

    return encrypted;
}

public byte[] decrypt(String code) throws Exception
{
    if(code == null || code.length() == 0)
        throw new Exception(""Empty string"");

    byte[] decrypted = null;

    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

        decrypted = cipher.doFinal(hexToBytes(code));
        //Remove trailing zeroes
        if( decrypted.length &gt; 0)
        {
            int trim = 0;
            for( int i = decrypted.length - 1; i &gt;= 0; i-- ) if( decrypted[i] == 0 ) trim++;

            if( trim &gt; 0 )
            {
                byte[] newArray = new byte[decrypted.length - trim];
                System.arraycopy(decrypted, 0, newArray, 0, decrypted.length - trim);
                decrypted = newArray;
            }
        }
    } catch (Exception e)
    {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}


public static String bytesToHex(byte[] buf)
{
    char[] chars = new char[2 * buf.length];
    for (int i = 0; i &lt; buf.length; ++i)
    {
        chars[2 * i] = HEX_CHARS[(buf[i] &amp; 0xF0) &gt;&gt;&gt; 4];
        chars[2 * i + 1] = HEX_CHARS[buf[i] &amp; 0x0F];
    }
    return new String(chars);
}


public static byte[] hexToBytes(String str) {
    if (str==null) {
        return null;
    } else if (str.length() &lt; 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i=0; i&lt;len; i++) {
            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
        }
        return buffer;
    }
}



private static String padString(String source)
{
    char paddingChar = 0;
    int size = 16;
    int x = source.length() % size;
    int padLength = size - x;

    for (int i = 0; i &lt; padLength; i++)
    {
        source += paddingChar;
    }

    return source;
}
}
</code></pre>

<p>PHP:</p>

<pre><code>&lt;?php
class MCrypt
{
    private $iv = 'MyNameIsHamza100'; #Same as in JAVA
    private $key = 'MyNameIsBilal100'; #Same as in JAVA
    function __construct()
    {
    }
    /**
     * @param string $str
     * @param bool $isBinary whether to encrypt as binary or not. Default is: false
     * @return string Encrypted data
     */
    function encrypt($str, $isBinary = false)
    {
        $iv = $this-&gt;iv;
        $str = $isBinary ? $str : utf8_decode($str);
        $td = mcrypt_module_open('rijndael-128', ' ', 'cbc', $iv);
        mcrypt_generic_init($td, $this-&gt;key, $iv);
        $encrypted = mcrypt_generic($td, $str);
        mcrypt_generic_deinit($td);
        mcrypt_module_close($td);
        return $isBinary ? $encrypted : bin2hex($encrypted);
    }
    /**
     * @param string $code
     * @param bool $isBinary whether to decrypt as binary or not. Default is: false
     * @return string Decrypted data
     */
    function decrypt($code, $isBinary = false)
    {
        $code = $isBinary ? $code : $this-&gt;hex2bin($code);
        $iv = $this-&gt;iv;
        $td = mcrypt_module_open('rijndael-128', ' ', 'cbc', $iv);
        mcrypt_generic_init($td, $this-&gt;key, $iv);
        $decrypted = mdecrypt_generic($td, $code);
        mcrypt_generic_deinit($td);
        mcrypt_module_close($td);
        return $isBinary ? trim($decrypted) : utf8_encode(trim($decrypted));
    }
    protected function hex2bin($hexdata)
    {
        $bindata = '';
        for ($i = 0; $i &lt; strlen($hexdata); $i += 2) {
            $bindata .= chr(hexdec(substr($hexdata, $i, 2)));
        }
        return $bindata;
    }
}
?&gt;
</code></pre>
"	NULL	3	NULL	28:23.1	0	48:01.0	NULL	NULL	0	9718267	0	1	-2	<java><php><android><encryption><aes>	AES Initialization Vector randomization	1027	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
50228123	50231480	1	"<p>I was trying encryption in android and decryption in nodejs server. I generated an AES 128bit key and encrypt it using AES algorithm and then encrypt this generated key using RSA algorithm. Then send both to the server. But while decrypting on the server side, I think the RSA decryption works fine but have a problem in AES decryption. 
I'm not getting the string in server side that I encrypted on the client side. </p>

<p>This is the code for the encryption on android side: </p>

<pre><code>String encryptedSecretKey;
String cipherTextString;

// 1. generate secret key using AES
KeyGenerator keyGenerator = null;
keyGenerator = KeyGenerator.getInstance(""AES"");
keyGenerator.init(128);

// 2. get string which needs to be encrypted
String text = ""This is the message to be encrypted"";

// 3. encrypt string using secret key
byte[] raw = secretKey.getEncoded();
SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
cipherTextString = Base64.encodeToString(cipher.doFinal(text.getBytes(Charset.forName(""UTF-8""))), Base64.DEFAULT);

// 4. get public key
X509EncodedKeySpec publicSpec = new X509EncodedKeySpec(Base64.decode(publicKeyString, Base64.DEFAULT));
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey publicKey = keyFactory.generatePublic(publicSpec);

// 5. encrypt secret key using public key
Cipher cipher2 = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"");
cipher2.init(Cipher.ENCRYPT_MODE, publicKey);
encryptedSecretKey = Base64.encodeToString(cipher2.doFinal(secretKey.getEncoded()), Base64.DEFAULT);
</code></pre>

<p>Then send this to the server side. </p>

<p>The code for server side is given below:</p>

<pre><code>var encryptedMessage = req.body.cipherText;
var encryptedAesKey = req.body.secretKey;

//printing those values
console.log(""\nEncryptedMessage: \n"" + encryptedMessage);
console.log(""\nEncrypted key: \n"" + encryptedAesKey);

var privateKey = fs.readFileSync('././Keys/privkey_server.pem', ""utf8"");
var bufferForAesKey = new Buffer(encryptedAesKey, ""base64"");
var obj = {
        key: privateKey
        // , padding: constants.RSA_PKCS1_PADDING
        // , padding: constants.RSA/ECB/OAEPWithSHA-1
};
var decryptedAes = crypto.privateDecrypt(obj, bufferForAesKey);

console.log(""Decrypted AES: "" + decryptedAes);

var decryptedAesKeyString = decryptedAes.toString(""base64"");
console.log(""Decrypted AES Key: "" + decryptedAesKeyString);
var bufferForAES = new Buffer(decryptedAes, ""base64"");

//decrypting using AES
var bufferForEncryptedMsg = new Buffer(encryptedMessage, ""base64"");

var decipher = crypto.createDecipher('aes-128-cbc',bufferForAES);
decipher.setAutoPadding(false);
var dec = decipher.update(bufferForEncryptedMsg,""base64"", ""utf8"");
dec += decipher.final(""utf8"");
console.log(dec);
</code></pre>

<p>Here the final result 'dec' is not giving the correct result but the intermediate results are same in client and server. That means, RSA works fine but have problem in AES. </p>

<p>The output is given below: </p>

<pre><code>EncryptedMessage: 
SfosHg+cTrQXYUdF0FuqCJMHgfcP13ckp2L0B9QqOcl8UtWnnl8fLi5lxgR2SKOj


Encrypted key: 
C/pa52PZda3xShrPXkHZx8OL6sW4JBEhG/ggNAoHhSVXIGt+iDq/B1ByG5yStBGF3GFJRQT0aGsG
+bZJydP7j9gTivmt99H/bxiZan4CHZnqfGKG1dJCI7ILAYZMCw7JhIcRC8qHMM4LMdF+rxRhENDe
alUfnsLWpcrX9J6fKejJ7EWnWQ1VadKqCDmrJ5xw0lBbsOpwN/vY09+VhF4WkOz8Y3cQGk+FVdz5
tr4L9/jgXlTZdOC2KVBLSH+9pvtHwMWFKKoDSAzvkil4htBjbWTqlBuEINC4I/J/4P3RX2riT5Pv
xHQi/Dv7vdBlo9AEdvWe3Ek8oBleIpmIQHXwQWknPOYghhBAVmACG/tbEQcAtbcmRLruT/XzjPJt
HNBt2HeG9JHYKNoHC3kOuJdnlGe8mv8k0Nzwj04RhEGKSmPIiu/oDgYwS0l96KIlS2ELqBlS5O0L
AJ+RBG7m0WwC9dfrufsuwu0+SPUmg5/ElXRmA3T81lXtQqQbGg8G6r/bAVFGduy4a49s/VWoylx+
/sI079IwyY0IOfwQTVGZRyDC5O1ZBjoYv2+TRo3bjG8GXNQoybkmWkhgotcqVD9mXO67D2NBsFPT
EJnw+1ApSqR7ggIAF+qsMxejFKBICBL/4J8FP4+obA07J1pWiciTRKX+G130qzIBKM08Zdaf/50=

Decrypted AES: %Kp[?S?/?W l??9????~??
B?A?
Decrypted AES Key: JUtwW8+qU6Mv/FcgbMbkOdOKy72pun4B490KQrRB4QQ=
T????u??q?
          ???w?p???u`??r[`H0[tW??=??~i-?W
</code></pre>

<p>Here the Decrypted AES key is same as the key that we generate in android. But the final output is not giving the desired result. Is there any error in my code?? </p>
"	NULL	3	NULL	25:37.1	0	31:38.7	NULL	NULL	0	4082114	0	1	2	<java><node.js><encryption><aes><rsa>	AES Encryption in android and decryption in nodejs	2296	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
50252516	50253124	1	"<p>I am trying to understand the working of this simple AES encryption code and the vulnerabilities that it might face.</p>

<pre><code>public static void main(String ... args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        1) String key = ""/AbCd17%%/gvg8("";
        2) byte[] keyBytes = key.getBytes();
        3) SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
        4) Cipher cipher = Cipher.getInstance(""AES"");
        5) cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        6) byte[] ciphertext = cipher.doFinal(""Message"".getBytes());
        7) System.out.println(ciphertext);
    }
</code></pre>

<p>So far i think the problems lie in the following:<br/><br/>
-> Lines 2 &amp; 6 using getBytes() instead of encoding the key/plaintext first with getBytes(""UTF8""), but how exactly does this pose a threat?<br/><br/>
-> In line 4 we are using ECB mode(default mode) which is insecure, so instead we should use other modes like OCB,CTR etc.<br/><br/>
-> Can the exceptions listed cause any vulnerabilities?  and what more am I missing?<br/></p>

<p>I am new to this stuff and would appreciate any help.</p>
"	NULL	1	NULL	40:27.6	0	12:58.8	NULL	NULL	0	7409332	0	1	0	<java><cryptography>	AES Encryption vulnerabilities in JAVA	1293	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
50318355	50322964	1	"<p>I need to wrap private value with <code>AESWrap</code>. I have a problem with this operation because of length of my private value string (key to be wrapped). </p>

<p>This is my implementation:</p>

<pre><code>final byte[] kek = // ... generate SHA-256 key via `PBKDF2WithHmacSHA256`        
SecretKey sKey = new SecretKeySpec(kek, ""AES"");

Cipher c = Cipher.getInstance(""AESWrap"", ""SunJCE"");
c.init(Cipher.WRAP_MODE, sKey);

byte[] bytes = privateValue.getBytes();
SecretKeySpec wk = new SecretKeySpec(bytes, ""AES"");
byte[] result = c.wrap(wk);
</code></pre>

<p>Since <code>SunJCE</code> provider doesn't support any padding for key wrapping so private value should be multiples of 8 bytes and this is my problem I need to solve.</p>

<p><strong>Question:</strong> How to solve this situation when private value has not sufficient length. Is there some recommended way how to do padding on my own?</p>

<p>P.S. I would like to avoid external libraries like BC etc.</p>

<hr>

<p>With respect to @Maarten's answer I created this implementation. It works (it wraps and unwraps my private value successfully), but is this implementation <strong>secure</strong>? </p>

<p><strong>Wrapping</strong></p>

<pre><code>byte[] salt = .... // 32 random bytes...
byte[] kek = ... // PBKDF2WithHmacSHA256 hash from private value and salt

SecretKey sKey = new SecretKeySpec(kek, ""AES"");
Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");

SecureRandom rng = new SecureRandom();
byte[] ivBytes = new byte[c.getBlockSize()];
rng.nextBytes(ivBytes);
IvParameterSpec iv = new IvParameterSpec(ivBytes);

c.init(Cipher.WRAP_MODE, sKey, iv);
SecretKeySpec wk = new SecretKeySpec(privateValue.getBytes(), ""AES"");
byte[] result = c.wrap(wk); // wrapped private value
</code></pre>

<p><strong>Unwrapping</strong></p>

<pre><code>byte[] kek = ... // PBKDF2WithHmacSHA256 hash from private value and previous salt

SecretKey sKey = new SecretKeySpec(kek, ""AES"");
Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");

IvParameterSpec iv = new IvParameterSpec(parsed.getIv()); // previously created iv
c.init(Cipher.UNWRAP_MODE, sKey, iv);

SecretKeySpec wk = new SecretKeySpec(privateValue.getBytes(), ""AES"");
Key result = c.unwrap(parsed.getKey(), ""AES"", Cipher.SECRET_KEY);

byte[] pv = result.getEncoded(); // unwrapped private value
</code></pre>
"	NULL	1	NULL	38:15.7	0	03:04.4	03:04.4	NULL	1315357	1315357	0	1	2	<java><encryption><aes>	AESWrap and to-wrap-key length length / padding issue	1208	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
50765275	0	2	"<p>I'm currently using DES as a practice method for encrypting/decrypting data (I know it isn't industry practice!) and I'm running into an error when decrypting(here is the output):</p>

<pre><code>java.security.InvalidKeyException: Parameters missing
at com.sun.crypto.provider.CipherCore.init(CipherCore.java:469)
    at com.sun.crypto.provider.DESCipher.engineInit(DESCipher.java:186)
    at javax.crypto.Cipher.implInit(Cipher.java:802)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1249)
    at javax.crypto.Cipher.init(Cipher.java:1186)
    at CryptoPrac.Encrypt_Decrypt.Decrypt(Encrypt_Decrypt.java:68)
    at CryptoPrac.Crypto_Main.main(Crypto_Main.java:35)
</code></pre>

<p>This is my code:</p>

<pre><code>public byte[] Decrypt(byte[] encrypted)
{
    try
    {
        KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
        keyStore.load(new FileInputStream(""output.jceks""), ""password"".toCharArray());
        SecretKey key = (SecretKey) keyStore.getKey(""key"", ""password"".toCharArray());
        System.out.println(key.toString());
        Cipher deCipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
        deCipher.init(Cipher.DECRYPT_MODE, key);

        return deCipher.doFinal(encrypted);
    }
    catch (Exception e)
    {
        System.out.println(e.getMessage());
    }
    return null;
}
</code></pre>

<p>I think it might be a problem with me trying to cast getKey as a secret key but I'm not sure how to do it otherwise (the key is stored as a secretkey in the keystore but it returns an error when i don't have it there).</p>

<p>edit: I have the policy .jars in my referenced libraries because I think it may be a problem with them not being recognized.</p>
"	NULL	0	NULL	54:12.1	0	44:33.4	10:10.0	NULL	7793268	7793268	0	1	1	<java><algorithm><encryption><keystore>	Errors returned when trying to decrypt data using Secretkey	136	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
51090380	51090620	1	"<p>I've been reading up on AES for the past 2 hours, and this is what I've got to show for it so far:</p>

<pre><code>static String decrypt(byte[] encrypted){
    try{
        Key aesKey = new SecretKeySpec(System.getenv(""CRYPTO_KEY"").getBytes(), ""AES"");
        // The key is 32 bytes long.
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, aesKey);
        return new String(cipher.doFinal(encrypted));
    } catch(Exception e){
        System.out.println(""decrypt() failed."");
        e.printStackTrace();
        return null;
    }
}

static byte[] encrypt(String plaintext){
    try{
        Key aesKey = new SecretKeySpec(System.getenv(""CRYPTO_KEY"").getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, aesKey);
        return cipher.doFinal(plaintext.getBytes());
    } catch(Exception e){
        System.out.println(""encrypt() failed."");
        e.printStackTrace();
        return null;
    }
}
</code></pre>

<p>I know that AES operates on blocks of 16 bytes each, but I don't think I can guarantee that my input strings will be 16 bytes or less. Is there an easy way to get this cipher to work on arbitrary-length strings? Or do I just have to break up the input into 16-byte blocks and run each one through manually?</p>
"	NULL	3	NULL	54:41.5	0	23:14.7	NULL	NULL	0	6137410	0	1	1	<java><aes>	How should I get AES to work on strings of arbitrary length in Java?	240	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
51356504	51357226	1	"<p>Unable to decrypt the cipher text in Java which is ecrypted in GoLang using Blowfish.</p>

<p><strong>Encryption</strong></p>

<pre><code>import (
    ""testing""
    ""golang.org/x/crypto/blowfish""
    ""github.com/andreburgaud/crypt2go/ecb""
    ""github.com/andreburgaud/crypt2go/padding""
    ""fmt""
    ""encoding/base64""
)

func TestEncrypt(t *testing.T) {

    bytes := []byte(""cap"")
    key := []byte(""1c157d26e2db9a96a556e7614e1fbe36"")

    encByte := encrypt(bytes, key)
    enc := base64.StdEncoding.EncodeToString(encByte)
    fmt.Printf(""ENC - %s\n"", enc)
}

func encrypt(pt, key []byte) []byte {
    block, err := blowfish.NewCipher(key)
    if err != nil {
        panic(err.Error())
    }
    mode := ecb.NewECBEncrypter(block)
    padder := padding.NewPkcs5Padding()
    pt, err = padder.Pad(pt) // padd last block of plaintext if block size less than block cipher size
    if err != nil {
        panic(err.Error())
    }
    ct := make([]byte, len(pt))
    mode.CryptBlocks(ct, pt)
    return ct
}

// Output
// ENC - AP9atM49v8o=
</code></pre>

<p><strong>Decryption</strong></p>

<pre><code>import lombok.SneakyThrows;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import static java.util.Base64.getDecoder;
import static java.util.Base64.getEncoder;

public class UserAuthenticationFilter {

    public static void main(String[] args) throws Exception {
        String key = ""1c157d26e2db9a96a556e7614e1fbe36"";
        System.out.println(decrypt(getDecoder().decode(""AP9atM49v8o=""), key));

        // encryption and decryption verification
        // String plainText = ""cap"";
        // String cipher = encrypt(plainText, key);
        // String decrypted = decrypt(getDecoder().decode(enc), key);
        // assert decrypted.equals(plainText);
    }

    @SneakyThrows
    public static String encrypt(String plainText, String key) {
        byte[] myKeyByte = hexToBytes(key);
        SecretKeySpec skeySpec = new SecretKeySpec(myKeyByte, ""Blowfish"");
        Cipher ecipher = Cipher.getInstance(""Blowfish/ECB/PKCS5Padding"");
        ecipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] src = ecipher.doFinal(plainText.getBytes(""ISO-8859-1""));
        return getEncoder().encodeToString(src);
    }

    @SneakyThrows
    public static String decrypt(byte[] cipherContent, String key) {
        byte[] myKeyByte = hexToBytes(key);
        SecretKeySpec skeySpec = new SecretKeySpec(myKeyByte, ""Blowfish"");
        Cipher dcipher = Cipher.getInstance(""Blowfish/ECB/NoPadding"");
        dcipher.init(2, skeySpec);
        byte[] dcontent = dcipher.doFinal(cipherContent);
        return (new String(dcontent, ""ISO-8859-1"")).trim();
    }

    private static byte[] hexToBytes(String str) {
        if (str == null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];

            for(int i = 0; i &lt; len; ++i) {
                buffer[i] = (byte)Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);
            }

            return buffer;
        }
    }

}

// Output
// BY x³
</code></pre>

<p>As per the outputs, encryption in GoLang and decryption in Java doesn't produce the same plain text. Initially, thought the problem might be related to golang's byte (0 to 255) and java's byte (-128 to 127) involved in base64 encoding and decoding. But poking in Java's decryption code, it's handled correctly with <code>value &amp; 255</code>.</p>

<p>Decryption of the same cipher text in golang works perfectly. Also encryption and decryption in Java works perfectly. But not the encryption in one and decryption in other.</p>

<p>I think the encryption and decryption logic were correct. Only guess might be there's some language specific ??? is missing when the cipher text is ported to other language for decryption.</p>
"	NULL	5	NULL	19:43.6	0	32:48.1	48:29.8	NULL	4362675	4362675	0	1	1	<java><go><encryption><cryptography><blowfish>	Blowfish GoLang Encryption and Java Decryption	1338	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
52076885	0	0	"<p>I'm using Conscrypt on Android (BTW, I have set minSdkVersion to 23). I have written some code to wrap and unwrap an ECC Public Key. An AES Key is used for this wrap/unwrap:</p>

<pre><code>private void testWrapFunctions(Key eccKey) {

    try {
        byte[] randomAesKey = generateSecureRandomBytes(AES_KEY_SIZE/8);
        SecretKeySpec aesKey = generateAESKey(randomAesKey);

        Cipher myCipher = Cipher.getInstance(""AES/GCM/NoPadding"");

        myCipher.init(Cipher.WRAP_MODE, aesKey);
        byte[] wrappedData = myCipher.wrap(eccKey);

        myCipher.init(Cipher.UNWRAP_MODE, aesKey);
        Key unWrappedKey = myCipher.unwrap(wrappedData, ""AES/GCM/NoPadding"", Cipher.PUBLIC_KEY);

    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>When I run this code, I've got the following exception:</p>

<pre><code>java.lang.RuntimeException: error:0f00007b:elliptic curve routines:OPENSSL_internal:UNKNOWN_GROUP
</code></pre>

<p>Here is the backtrace:</p>

<pre><code>System.err:     at org.conscrypt.NativeCrypto.EVP_marshal_public_key(Native Method)
System.err:     at org.conscrypt.OpenSSLECPublicKey.getEncoded(OpenSSLECPublicKey.java:91)
System.err:     at org.conscrypt.OpenSSLCipher.engineWrap(OpenSSLCipher.java:404)
System.err:     at javax.crypto.Cipher.wrap(Cipher.java:1677)
System.err:     at com.st.st25dvcryptodemo.MyApplication.testWrapFunctions(MyApplication.java:187)
</code></pre>

<p>Do you know what I could have done wrong?
Thanks</p>
"	NULL	3	NULL	57:48.1	0	57:48.1	NULL	NULL	0	4331391	0	1	1	<java><android><cryptography>	ECC Key Wrapping with Conscrypt on Android	244	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
52120150	52120395	1	"<p>I have made an app with javafx that I can write something and save it to database. my database is sqlite. it's a very simple app. although I've added login app to my writing app, still the sqlite can be opened by any software.
instead of encrypting the sqlite db(which i didn't know and i found really confusing to do :) ) I decided to encrypt the text in java and later when i want to read it i would turn it back to normal and show it.</p>

<p>I learned how to do it from <a href=""https://stackoverflow.com/questions/20796042/aes-encryption-and-decryption-with-java/20796446#20796446"">this link</a> and i changed it to print the string instead of writing to a file
so my final code looks like this:</p>

<pre><code>public static void main(String[] args) throws Exception {

    String textA = """";
    String textB="""";

    byte[] thisismykey = ""Hello How manyBytes are in@hts A"".getBytes();
    SecretKey secKey = new SecretKeySpec(thisismykey, ""AES"");


    Cipher aesCipher = Cipher.getInstance(""AES"");

    //turn your original text to byte
    byte[] myoriginaltexttobyte = ""Your Plain Text Here"".getBytes();
    //activate the encrypt method
    aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
    //encrypt the text and assign the encrypted text to a byte array
    byte[] bytecipheredoforgtext = aesCipher.doFinal(myoriginaltexttobyte);
    //change it to string with new string
    textA = new String(bytecipheredoforgtext);
    System.out.println(textA);

    //get the bytes of encrypted text and assign it to a byte array
    byte[] byteofencryptedtext = textA.getBytes();
    //activate the decrypt mode of the cipher
    aesCipher.init(Cipher.DECRYPT_MODE, secKey);
    //decrypt the encrypted text and assign it to a byte array
    byte[] byteofencryptedbacktonormaltext = aesCipher.doFinal(byteofencryptedtext);
    //change it to string with new string
    textB = new String(byteofencryptedbacktonormaltext);
    System.out.println(textB);
}
</code></pre>

<p>now that encrypt and decrypt are at the same method it works perfectly but I want to change it to a class with different methods so i could encrypt a text with one method and decrypt it with another. but when i separate things decrypt doesn't work well. Encrypt work well. this is the code now:</p>

<pre><code>public class CipherFinalB {

//from https://stackoverflow.com/questions/20796042/aes-encryption-and-decryption-with-java/20796446#20796446
private final byte[] thisismykey;
private final SecretKey secKey;
private final Cipher aesCipher;
public CipherFinalB() throws NoSuchPaddingException, NoSuchAlgorithmException {
    thisismykey = ""HellodHowfmanyBytesgarehin@htseA"".getBytes();
    secKey = new SecretKeySpec(thisismykey, ""AES"");

    aesCipher = Cipher.getInstance(""AES"");

}public String encrypt (String originaltext) throws InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    byte[] myoriginaltexttobyte =originaltext.getBytes();
    aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
    byte[] bytecipheredoforgtext = aesCipher.doFinal(myoriginaltexttobyte);
    String textA = new String(bytecipheredoforgtext);
    System.out.println(textA);
    return new String(bytecipheredoforgtext);
}

public String decrypt (String encryptedtext) throws InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    byte[] byteofencryptedtext = encryptedtext.getBytes();
    aesCipher.init(Cipher.DECRYPT_MODE, secKey);
    byte[] byteofencryptedbacktonormaltext = aesCipher.doFinal(byteofencryptedtext);
    return new String(byteofencryptedbacktonormaltext);
}

}
</code></pre>

<p>when i use the encrypt method it gives me back a string. and when i send the same string to decrypt method it doesn't work and gives me the following error:</p>

<pre><code>Exception in thread ""main"" javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:936)
    at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:847)
    at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2191)
    at main.CipherFinalB.decrypt(CipherFinalB.java:66)
    at main.CipherTest.main(CipherTest.java:16)
</code></pre>

<p>What should i do?</p>

<p><strong>UPDATE ANSWER:</strong></p>

<p>as @Juan said the problem was ""when data is ciphered you may have any byte in the array, not only printable characters."" So I changed the method to return byte for encrypt method and decrypt method. decrypt method now gets byte as parameter instead of string and now everything works fine.</p>

<p>the updated code looks like this:</p>

<pre><code> public byte[] encrypt (String originaltext) throws InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    byte[] myoriginaltexttobyte =originaltext.getBytes();
    aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
    byte[] bytecipheredoforgtext = aesCipher.doFinal(myoriginaltexttobyte);
    String textA = new String(bytecipheredoforgtext);
    System.out.println(textA);
    return bytecipheredoforgtext;
}

public byte[] decrypt (byte[] encryptedtext) throws InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
    byte[] byteofencryptedtext = encryptedtext;
    aesCipher.init(Cipher.DECRYPT_MODE, secKey);
    byte[] byteofencryptedbacktonormaltext = aesCipher.doFinal(byteofencryptedtext);
    return byteofencryptedbacktonormaltext;
}
</code></pre>
"	NULL	0	NULL	21:02.3	0	30:22.8	30:22.8	NULL	9564000	9564000	0	1	0	<java><encryption><aes>	Problem with java Cipher when i want to decipher it	417	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
52846003	0	0	"<p>I just switched from using a custom DES to the builtin DES using the following:</p>

<pre><code>    SecretKey sk = new SecretKeySpec(key8, ""DES"");
    des = Cipher.getInstance(""DES/ECB/NoPadding"");
    des.init(opmode, sk);
</code></pre>

<p>and now I find that getInstance, implInit, chooseProvider and so on together literally talks <em>6 times</em> as long as doFinal.</p>

<p>100000 cycles of creating an instance and doing one encrypt is now much slower.</p>

<p>Is there a way to bypass all of the javax.crypto setup? Can I clone what's returned by getInstance or something?</p>
"	NULL	8	NULL	16:13.0	0	16:13.0	NULL	NULL	0	1023009	0	1	2	<java><performance><cryptography>	"Java Cipher.{getInstance,implInit} Too Slow"	399	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
52969975	52972040	1	"<p>Totally security noob here.</p>

<p>I have to decrypt a String I receive, encoded in Base64. All I have is the String I need to decrypt, and a String, which the service that sents me the String to decode calls it a seed.</p>

<p>Based on what I have read here and in other places, I have this:</p>

<pre><code>public String decrypt(String message) throws Exception
{
    String salt = ""PRUEBA"";
    Cipher c = Cipher.getInstance(""AES"");
    SecretKeySpec key = new SecretKeySpec(salt.getBytes(), ""AES"");
    c.init(Cipher.DECRYPT_MODE, key);
    byte[] decordedValue = Base64.decode(message.getBytes(), Base64.DEFAULT);
    byte[] decValue = c.doFinal(decordedValue);
    String decryptedValue = new String(decValue);
    String decoded=new String(Base64.decode(decryptedValue,Base64.DEFAULT));
    return decoded;
}
</code></pre>

<p>This returns java.security.InvalidKeyException: Key length not 128/192/256 bits.</p>

<p>I tried also <a href=""https://github.com/scottyab/AESCrypt-Android"" rel=""nofollow noreferrer"">this</a> library, but it returns IllegalBlockSizeException: last block incomplete in decryption</p>

<p>Don't know if I need something else from the server side, as I said I have little to no knowledge of encryption.</p>

<p>I am completely lost at this issue. Can you help me?</p>

<p>Thank you.</p>
"	NULL	2	NULL	14:39.2	0	58:27.6	NULL	NULL	0	1254512	0	1	0	<android><encryption><aes>	Decrypt a String encoded using AES 256	1051	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
53051754	53052392	2	"<p>Hello dear people of stackoverflow,</p>

<p>I'm currently developing/implementing security measures within my application and somewhat experiencing issues with encryption and decryption of certain data.</p>

<p>Yesterday in fact i was able to encrypt a message and then decrypt the encrypted message with the very same instance of the class - yet could not do vice versa. That's what I wanted to post today (about the issue) - </p>

<p>After pushing the latest changes from the linux system I've worked and trying to continue working on the windows pc, the following error was thrown:</p>

<pre><code>    java.security.InvalidKeyException: Illegal key size or default parameters
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1026)
    at javax.crypto.Cipher.implInit(Cipher.java:801)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1249)
    at javax.crypto.Cipher.init(Cipher.java:1186)
    at com.x.backend.security.Decrypter.encrypt(Decrypter.java:43)
    at crypto.CryptoTest.main(CryptoTest.java:11)
java.lang.NullPointerException
    at javax.crypto.spec.IvParameterSpec.&lt;init&gt;(IvParameterSpec.java:53)
    at com.x.backend.security.Decrypter.decrypt(Decrypter.java:54)
    at crypto.CryptoTest.main(CryptoTest.java:12)
</code></pre>

<p>So I tried finding a solution but did not find any, so here's what I tried so far: </p>

<ul>
<li><p>Updating to JDK 9/10/11 is not an option for me, I tried it, I failed miserably and there'd be too much to adapt if I'd to the move up (it's not worth the effort as of this moment)</p></li>
<li><p>I've read something about Java Cryptography Extension (JCE), yet that does not apply to me since I am running the JDK version <strong>1.8.66</strong> (and since 1.8.55 it no longer requires any kind of file installed within the java directory)</p></li>
<li><p>Invalidated cache (IntelliJ) + Restarted my PC </p></li>
<li><p>Resetted the project state to the initial commit (git hard reset)</p></li>
</ul>

<p>My class:</p>

<pre><code>public class Decrypter {

    private static Decrypter instance;

    private Cipher cipher;

    private byte[] IV;

    private SecretKeySpec secretKeySpec;

    private Decrypter() {
        initialize();
    }

    private void initialize() {
        try {
            final byte[] salt = ""@1jq3#-o1_uHvaL:"".getBytes();
            final String key = ""hehexd"";
            final int iterationCount = 12;
            final int keyStrength = 256;
            this.cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            this.secretKeySpec = new SecretKeySpec(SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"").generateSecret(new PBEKeySpec(key.toCharArray(), salt, iterationCount, keyStrength)).getEncoded(), ""AES"");
        } catch (InvalidKeySpecException | NoSuchAlgorithmException | NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public final String encrypt(String data) {
        try {
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            IV = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return """";
    }

    public final String decrypt(String base64EncryptedData) {
        try {
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(IV));
            byte[] decryptedData = Base64.getDecoder().decode(base64EncryptedData);
            byte[] utf8 = cipher.doFinal(decryptedData);
            return new String(utf8, StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return """";
    }

    public static Decrypter getInstance() {
        return instance == null ? instance = new Decrypter() : instance;
    }
}
</code></pre>

<p>My test class:</p>

<pre><code>    public class CryptoTest {

    public static void main(String[] args) {
        String encrypted = Decrypter.getInstance().encrypt(""lol"");
        String decrypted = Decrypter.getInstance().decrypt(encrypted);
        System.out.println(""Verification: PLAINTEXT -&gt; ENCRYPT: "" + encrypted);
        System.out.println(""Verification: ENCRYPT -&gt; DECRYPT: "" + decrypted);
    }
}
</code></pre>

<p>Please don't mind any conventional mistake/bad practice, I'm a newcomer when it comes to cryptography (reading my way into it as of this moment)</p>

<p>Any help or input would be appreciated!</p>

<p>Edit:</p>

<p>Thank you for your immediate replies!</p>

<p>Unfortunately I'm having another error thrown.
Full output:</p>

<pre><code>    Verification: PLAINTEXT -&gt; ENCRYPT: 
java.security.InvalidKeyException: Illegal key size
Verification: PLAINTEXT -&gt; DECRYPT: 
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1039)
    at javax.crypto.Cipher.implInit(Cipher.java:805)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1396)
    at javax.crypto.Cipher.init(Cipher.java:1327)
    at com.x.backend.security.Decrypter.encrypt(Decrypter.java:48)
    at crypto.CryptoTest.main(CryptoTest.java:11)
java.security.InvalidKeyException: No installed provider supports this key: javax.crypto.spec.SecretKeySpec
    at javax.crypto.Cipher.chooseProvider(Cipher.java:893)
    at javax.crypto.Cipher.init(Cipher.java:1396)
    at javax.crypto.Cipher.init(Cipher.java:1327)
    at com.x.backend.security.Decrypter.decrypt(Decrypter.java:58)
    at crypto.CryptoTest.main(CryptoTest.java:12)
</code></pre>

<p>changed code:</p>

<pre><code> public final String encrypt(String data) {
        try {
            IV = new IvParameterSpec(""testtesttesttest"".getBytes());
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, IV);
            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return """";
    }
</code></pre>
"	NULL	0	NULL	32:41.2	0	50:46.3	06:23.3	NULL	3650092	3650092	0	1	1	<java><encryption>	Local encryption and decryption of data	450	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
53254779	0	1	"<p>I have a client/server application that encrypts or decrypts a message both on the client-side and server-side. However on decryption I keep getting the following error from the StackTrace</p>

<blockquote>
  <p>Input length must be multiple of 8 when decrypting with padded cipher</p>
</blockquote>

<p>Following is the code from both the Server and Client classes.
The thing is I have tried using <strong>(""DES/CBC/PKCS5Padding"")</strong> and <strong>(""UTF-8"")</strong> but still haven't been able to fix said issue.
Any help would be appreciated thanks? </p>

<pre><code>public class ServerApp   {

    public static byte[] encrypt(String input, Key k) {
        try {

            Cipher cipher = Cipher.getInstance(""DES"");
            cipher.init(Cipher.ENCRYPT_MODE, k);
            byte[] data = input.getBytes();
            byte[] result = cipher.doFinal(data);

            return result;
        } catch (Exception ex) {
            return null;
        }
    }

    public static String decrypt(byte[] cipher, Key k) {
        try {

            Cipher cipher1 = Cipher.getInstance(""DES"");
            cipher1.init(Cipher.DECRYPT_MODE, k);
            byte[] original = cipher1.doFinal(cipher);
            return new String(original);

        } catch (Exception ex) {
            return null;
            //Logger.getLogger(DES.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public static void main(String[] args) throws NoSuchAlgorithmException {
        try {

              Key key=KeyGen.getSecretKey();
            ServerSocket ser = new ServerSocket(3333);
            System.out.println(""Server Started"");
            Socket client = ser.accept();
            DataInputStream in = new DataInputStream(client.getInputStream());
            DataOutputStream out = new DataOutputStream(client.getOutputStream());
            Scanner scan = new Scanner(System.in);
           // SecretSocket sc = new SecretSocket(client, KeyGen.getSecretKey());
            String serMsg, cliMsg, plain;
           // OutputStream sout = sc.getOutputStream();
          //  InputStream sin = sc.getInputStream();
            do {
                System.out.print(""You say: "");
                serMsg = scan.nextLine();

             //   sout.write(serMsg.getBytes());
            //    System.out.println(""cli server ""+sin.read());

                byte[] ci = encrypt(serMsg, KeyGen.getSecretKey());
            System.out.println(""encrypt "" +ci.toString());
             out.writeUTF(ci.toString());
              plain = decrypt(ci, KeyGen.getSecretKey() );
              System.out.println(""decrypt "" + plain);
            } while (!serMsg.equals(""end""));
            client.close();
            ser.close();
        } catch (IOException ex) {
            Logger.getLogger(ServerApp.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}

public class ClientApp  {

        public static byte[] encrypt(String input, Key k) {
        try {

            Cipher cipher = Cipher.getInstance(""DES"");
            cipher.init(Cipher.ENCRYPT_MODE, k);
            byte[] data = input.getBytes();
            byte[] result = cipher.doFinal(data);

            return result;
        } catch (Exception ex) {
            return null;
        }
    }

    public static String decrypt(byte[] cipher, Key k) {
        try {

            Cipher cipher1 = Cipher.getInstance(""DES/CBC/PKCS5Padding"");
            cipher1.init(Cipher.DECRYPT_MODE, k);
            byte[] original = cipher1.doFinal(cipher);
            return new String(original);

        } catch (Exception ex) {
            return null;
            //Logger.getLogger(DES.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        try {
            Socket s = new Socket(""localhost"", 3333);
            DataInputStream in = new DataInputStream(s.getInputStream());
            DataOutputStream out = new DataOutputStream(s.getOutputStream());
            Scanner scan = new Scanner(System.in);
            String serMsg, cliMsg, plain;

            do {

                System.out.println(""server server ""+in.readUTF());

                serMsg = in.readUTF();
                System.out.println(""enc: "" + serMsg);
                plain = decrypt(serMsg.getBytes(""UTF-8""), KeyGen.getSecretKey());
                System.out.println(""Server says: "" + plain);

            } while (!serMsg.equals(""end""));
            s.close();
        } catch (IOException ex) {
            Logger.getLogger(ClientApp.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
</code></pre>
"	NULL	0	NULL	57:16.7	0	44:29.2	44:29.2	NULL	8371844	10637977	0	1	0	<java><encryption><utf-8><data-security>	Input length must be multiple of 8 when decrypting with padded cipher	4401	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
53320551	53325590	1	"<p>I wrote a simple Encryption and Decryption helper class for my android app to encrypt and store Strings securely. </p>

<p>It consists of a single static public method to encrypt, then it calls a private static method to decrypt the encrypted message and returns it. I wrote the method this way to check if the message is intact after encryption/decryption.</p>

<p>I wrote a simple JUnit test with a String and called AssertEquals on the String before and after sending it to the Crypto encryption method.</p>

<p>I get this following errors from running the test:</p>

<pre><code>javax.crypto.AEADBadTagException: Tag mismatch!
</code></pre>

<p>The error stack:</p>

<pre><code>at com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:571)
at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1046)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:983)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:845)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
at javax.crypto.Cipher.doFinal(Cipher.java:2165)
at util.Crypto.decrypt(Crypto.java:94)
at util.Crypto.encrypt(Crypto.java:64)
at com.example.ali.meappley.CryptoTest.encryptAndDecryptTest(CryptoTest.java:29)
</code></pre>

<p>I'm new to cryptography, but I read different stackoverflow replies and couldn't find anything of help. Some users suggested calling <code>cipher.update(someByteArray)</code> before calling <code>cipher.doFinal(someByteArray)</code> but I couldnt manage to get it working. Any suggestions?</p>

<p>This is my helper class</p>

<pre><code>public class Crypto {

//public methods

//public static encrypt method
public static String encrypt(String messageToEncrypt, @Nullable byte[] associatedData) throws NoSuchPaddingException,
        NoSuchAlgorithmException,
        InvalidAlgorithmParameterException,
        InvalidKeyException,
        BadPaddingException,
        IllegalBlockSizeException {

    byte[] plainBytes = messageToEncrypt.getBytes();
/////////////////////////////////////////////////////////////////
    SecureRandom secureRandom = new SecureRandom();
    byte[] key = new byte[16];
    secureRandom.nextBytes(key);
    SecretKey secretKey = new SecretKeySpec(key, ""AES"");

    byte[] iv = new byte[12]; //NEVER REUSE THIS IV WITH SAME KEY
    secureRandom.nextBytes(iv);

    final Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    GCMParameterSpec parameterSpec = new GCMParameterSpec(128, iv); //128 bit auth tag length
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);

    if (associatedData != null) {
        cipher.updateAAD(associatedData);
    }

    byte[] cipherText = cipher.doFinal(plainBytes);

    ByteBuffer byteBuffer = ByteBuffer.allocate(4 + iv.length + cipherText.length);
    byteBuffer.putInt(iv.length);
    byteBuffer.put(iv);
    byteBuffer.put(cipherText);
    byte[] cipherMessage = byteBuffer.array();

    Arrays.fill(key,(byte) 0); //overwrite the content of key with zeros
    ///////////////////////////////////////////////////////////////////

    byte[] decrypted = decrypt(cipherMessage, null, key);

    return decrypted.toString();
}

//public static decrypt method
private static byte[] decrypt(byte[] cipherMessage, @Nullable byte[] associatedData, byte[] key) throws NoSuchPaddingException,
        NoSuchAlgorithmException,
        InvalidAlgorithmParameterException,
        InvalidKeyException,
        BadPaddingException,
        IllegalBlockSizeException {

    ByteBuffer byteBuffer = ByteBuffer.wrap(cipherMessage);
    int ivLength = byteBuffer.getInt();
    if(ivLength &lt; 12 || ivLength &gt;= 16) { // check input parameter
        throw new IllegalArgumentException(""invalid iv length"");
    }
    byte[] iv = new byte[ivLength];
    byteBuffer.get(iv);
    byte[] cipherText = new byte[byteBuffer.remaining()];
    byteBuffer.get(cipherText);

    final Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), new GCMParameterSpec(128, iv));
    if (associatedData != null) {
        cipher.updateAAD(associatedData);
    }

    cipher.update(cipherText);
    byte[] plainText= cipher.doFinal(cipherText);

    return plainText;
}
</code></pre>
"	NULL	0	NULL	27:24.3	0	15:28.0	NULL	NULL	0	3940445	0	1	13	<java><encryption><cryptography>	javax.crypto.AEADBadTagException: Tag mismatch! Error when encrypting String	37315	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
53939137	53946906	1	"<pre><code>package test;

/**
 * Created by
 * newbme on 12/25/2018.
 */
    import javax.crypto.Cipher;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.UnsupportedEncodingException;
    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;

    public class MyJava {



        /**
         * IT IS THIS CLASS THAT WILL ENCRYPT OR DECRYPT
         * ANY  FILE
         */

        private static final String SECRET_KEY_1 = ""ssdkF$HUy2A#D%kd"";
        private static final String SECRET_KEY_2 = ""weJiSEvR5yAC5ftB"";
        private IvParameterSpec ivParameterSpec;
        private SecretKeySpec secretKeySpec;
        private Cipher cipher;
        private File from,to;
        private static boolean trouble =false;





        /**
         * CBC MODE
         */
        public MyJava(File from,File to) throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException {
            ivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(""UTF-8""));
            secretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(""UTF-8""), ""AES"");
            cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            //INITIALIZE THE PLACE TO READ AND SAVE FILE
             this.from =from;
             this.to =to;

            //if the desination doesnt exists create it
            if(! this.to .exists()){
                try {
                    this.to.getParentFile().mkdirs();
                    this.to.createNewFile();
                }catch (Exception ex){
                    ex.printStackTrace();
                }
            }
            }




        /**
         *
         * USE THIS METHOD TO ENCRYPT ANYTHING
         */
        public boolean encrypt()throws Exception{
            FileInputStream fis =null;
            FileOutputStream fos=null;
            boolean success =false;
                try {
                    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
                    //read the file into memory
                     fis = new FileInputStream(from);
                     fos = new FileOutputStream(to);
                    byte [] inBytes = new byte[50*1024];
                    int count;
                    while( ( count = fis.read(inBytes)) &gt; 0){
                            byte encrypted[]  = cipher.doFinal(inBytes);
                            fos.write(encrypted,0,count);
                            fos.flush();
                    }
                    success =true;
                }catch(InvalidKeyException ivke){
                    ivke.printStackTrace();
                    trouble = true;
                }finally{
                    if(fis!=null)fis.close();
                    if(fos!=null)fos.close();
                }
            //return Base64.encodeBase64String(encrypted);
            return success;
        }






        /**
         *
         * USE THIS METHOD TO DECRYPT ANYTHING
         */
        public boolean decrypt() throws Exception{
         FileInputStream fis =null;
         FileOutputStream fos=null;
         boolean success =false;
         try {
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
            //read the file into memory
            fis = new FileInputStream(from);
            fos = new FileOutputStream(to);
            byte [] inBytes = new byte[50*1024];
            int count;
            while( ( count = fis.read(inBytes)) &gt; 0){
                byte decrypted[]  = cipher.doFinal(inBytes);//this line fails
                fos.write(decrypted,0,count);
                fos.flush();
            }
            success =true;
        }catch(InvalidKeyException ivke){
             trouble = true;
            ivke.printStackTrace();
        }finally{
            if(fis!=null)fis.close();
            if(fos!=null)fos.close();
        }
        //return Base64.encodeBase64String(encrypted);
        return success;
    }

        private static boolean isInvalidKeyException(){
            return trouble;
        }

    public static void main(String [] R){
         File f = new File(PATH);
        //encrypt
         new MyJava(f,new File(""c:/logs1/""+f.getName())).encrypt();
                         //Toast.makeText(context,""to decrypt"",Toast.LENGTH_LONG).show();
        //decrypt
                            new MyJava(f,new File(""c:/logs2/""+f.getName())).decrypt();
        }
    }
</code></pre>

<p><strong>Error:</strong></p>

<pre><code>D/OpenSSLLib: OpensslErr:Module:30(101:); file:external/boringssl/src/crypto/cipher/cipher.c ;Line:460;Function:EVP_DecryptFinal_ex
W/System.err: javax.crypto.BadPaddingException: error:1e000065:Cipher functions:OPENSSL_internal:BAD_DECRYPT
W/System.err:     at com.android.org.conscrypt.NativeCrypto.EVP_CipherFinal_ex(Native Method)
W/System.err:     at com.android.org.conscrypt.OpenSSLCipher$EVP_CIPHER.doFinalInternal(OpenSSLCipher.java:568)
W/System.err:     at com.android.org.conscrypt.OpenSSLCipher.engineDoFinal(OpenSSLCipher.java:350)
W/System.err:     at javax.crypto.Cipher.doFinal(Cipher.java:2056)
W/System.err:     at com.presentapps.aiapp.utility.AISCipher.decrypt(AISCipher.java:122)
W/System.err:     at com.presentapps.aiapp.popups.ActionPop$1.onClick(ActionPop.java:65)
</code></pre>

<p>Hello, I tried to encrypt a file which could be a text file or a music file etc. The program kinda encrypts it without  any exception, however when I try to decrypt, it throws an exception.
I've been trying to use CBC mode to get it working for days now, could someone help point out my errors? </p>

<p>And uhm, I am actually running it on Android device so I changed the root part with ""c:"" while posting on SO the error posted was same gotten from debugger console on A.S.</p>

<p>I'm a newb to java, just improving on my learning, so any help is appreciated. Thanks.</p>
"	NULL	3	NULL	33:20.5	0	57:22.9	51:09.9	NULL	6395627	6910819	0	1	0	<java><encryption>	Getting errors when trying to decrypt a file	304	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
54141277	54152334	2	"<p>I don't know why an error is coming up.</p>

<p><strong>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.</strong></p>

<p>I understand that this error occurs when the incorrect key is used during the decryption. However, if you look at the test results result below, you can see that both C# and Java are the same (Key, IV, Salt is Base64 encoded).</p>

<ol>
<li>C# Test Result </li>
</ol>

<p><a href=""https://i.stack.imgur.com/wr0pg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wr0pg.png"" alt=""C# Test Result""></a></p>

<ol start=""2"">
<li>Java Test Result</li>
</ol>

<p><a href=""https://i.stack.imgur.com/kkoM0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kkoM0.png"" alt=""Java Test Result""></a></p>

<p><strong>It's the same!(Key, IV, Salt)</strong></p>

<p>But the current BadpaddingException error is generated. What could be the problem?
I am attaching my source file.</p>

<ol>
<li>C# (Encryption)</li>
</ol>

<pre><code>
    class AES {
            private readonly static string keyStr = ""This is Key"";
            private readonly static string vector = ""This is Vector"";

            public static Rfc2898DeriveBytes MakeKey(string password){

                byte[] keyBytes = System.Text.Encoding.UTF8.GetBytes(password);
                byte[] saltBytes = SHA512.Create().ComputeHash(keyBytes);
                Rfc2898DeriveBytes result = new Rfc2898DeriveBytes(keyBytes, saltBytes, 65536);

                return result;
            }

            public static Rfc2898DeriveBytes MakeVector(string vector){

                byte[] vectorBytes = System.Text.Encoding.UTF8.GetBytes(vector);
                byte[] saltBytes = SHA512.Create().ComputeHash(vectorBytes);
                Rfc2898DeriveBytes result = new Rfc2898DeriveBytes(vectorBytes, saltBytes, 65536);

                return result;
            }

            public static void Encrypt(String inputFile, String outputFile) {
                using (RijndaelManaged aes = new RijndaelManaged()){
                    //Create Key and Vector
                    Rfc2898DeriveBytes key = AES.MakeKey(AES.keyStr);
                    Rfc2898DeriveBytes vector = AES.MakeVector(AES.vector);

                    //AES256
                    aes.BlockSize = 128;
                    aes.KeySize = 256;

                    // It is equal in java 
                    // Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");    
                    aes.Mode = CipherMode.CBC; 
                    aes.Padding = PaddingMode.PKCS7; 
                    aes.Key = key.GetBytes(32); //256bit key
                    aes.IV  = vector.GetBytes(16); //128bit block size


                    //processing Encrypt
                    ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
                    byte[] encrypted;

                    using (MemoryStream msEncrypt = new MemoryStream()) { 
                            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) {
                                byte[] inputBytes = File.ReadAllBytes(inputFile);
                                csEncrypt.Write(inputBytes, 0, inputBytes.Length);
                            }
                            encrypted = msEncrypt.ToArray();     
                        }
                        string encodedString = Convert.ToBase64String(encrypted);
                        File.WriteAllText(outputFile, encodedString);
                    }
                }
            }

</code></pre>

<ol start=""2"">
<li>Java (Decryption)</li>
</ol>

<pre><code>
    public class AES256File {
        private static final String algorithm = ""AES"";
        private static final String blockNPadding = algorithm+""/CBC/PKCS5Padding"";
        private static final String password = ""This is Key"";
        private static final String IV = ""This is Vector"";

        private static IvParameterSpec ivSpec;
        private static Key keySpec;

        public static void MakeKey(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException{
            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
            byte[] keyBytes = password.getBytes(""UTF-8"");

            // C# : byte[] saltBytes = SHA512.Create().ComputeHash(keyBytes);
            byte[] saltBytes = digest.digest(keyBytes);

            //256bit
            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 65536, 256);
            Key secretKey = factory.generateSecret(pbeKeySpec);

            byte[] key = new byte[32];
            System.arraycopy(secretKey.getEncoded(), 0, key, 0, 32);

            SecretKeySpec secret = new SecretKeySpec(key, ""AES"");
            setKeySpec(secret);
        }

        public static void MakeVector(String IV) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException{
            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
            byte[] vectorBytes = IV.getBytes(""UTF-8"");
            byte[] saltBytes = digest.digest(vectorBytes);

            // 128bit
            PBEKeySpec pbeKeySpec = new PBEKeySpec(IV.toCharArray(), saltBytes, 65536, 128);
            Key secretIV = factory.generateSecret(pbeKeySpec);

            byte[] iv = new byte[16];
            System.arraycopy(secretIV.getEncoded(), 0, iv, 0, 16);

            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            setIvSpec(ivSpec);
        }

        public void decrypt(File source, File dest) throws Exception {
            Cipher c = Cipher.getInstance(blockNPadding);
            c.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            fileProcessing(source, dest, c);
        }

        public  void fileProcessing(File source, File dest, Cipher c) throws Exception{
            InputStream input = null;
            OutputStream output = null;

            try{
                input = new BufferedInputStream(new FileInputStream(source));
                output = new BufferedOutputStream(new FileOutputStream(dest));
                byte[] buffer = new byte[input.available()];
                int read = -1;
                while((read = input.read(buffer)) != -1){
                    output.write(c.update(buffer, 0, read));
                }
                byte[] deryptedBytes = c.doFinal(buffer); // -----------------------&gt; Error!! Showing! 
                byte[] decodedBytes = Base64.getDecoder().decode(deryptedBytes);
                String decodeString = new String(decodedBytes, ""UTF-8"");
                decodedBytes = decodeString.getBytes(StandardCharsets.UTF_8);
                output.write(decodedBytes);

            }finally{
                if(output != null){
                    try{output.close();}catch(IOException e){}
                }
                if(input != null){
                    try{input.close();}catch(IOException e){}
                }
            }
        }

</code></pre>

<p><strong>I have verified as below.</strong></p>

<ol>
<li>Verification Key and IV in <strong>C#</strong></li>
</ol>

<pre><code>
    //Key Verification
        var salt = Convert.ToBase64String(saltBytes);
                Console.Write(""Salt Result : "");
                Console.WriteLine(salt);

        var result_test = Convert.ToBase64String(result.GetBytes(32));
                Console.Write(""Key Test Result: "");
                Console.WriteLine(result_test);
    //IV Verification (Salt is Using same code)
        var result_test = Convert.ToBase64String(result.GetBytes(16));
                Console.Write(""IV Test Result: "");
                Console.WriteLine(result_test);
</code></pre>

<ol start=""2"">
<li>Verification Key and IV in <strong>Java</strong></li>
</ol>

<pre><code>
    //Key Verification
        /* print Salt */
        String base64 = Base64.getEncoder().encodeToString(saltBytes);
        System.out.println(""Salt Result : "" + base64);

        /* print Key */
        String result_test = Base64.getEncoder().encodeToString(key);
        System.out.println(""Key Test Result : "" + result_test);

        /* print generated Key */
        System.out.println(""Secret Key Result : "" + Base64.getEncoder().encodeToString(secret.getEncoded()));

    //IV Verification (Salt is Using same code)
        /* print IV */
        String result_test = Base64.getEncoder().encodeToString(iv);
        System.out.println(""IV Test Result : "" + result_test);

        /* print generated IV */
        System.out.println(""IV Result : "" + Base64.getEncoder().encodeToString(ivSpec.getIV()));

</code></pre>

<p><strong>Updated</strong></p>

<p><strong>c# .netframework 4.5 / Java8</strong> modified what @Topaco said and confirmed that it worked well.</p>

<p>I want to say thank you very much to @Topaco and @Gusto2, and I'm going to make changes to the parts that have been modified in security, just as @Gusto2 said!</p>
"	NULL	0	NULL	16:00.6	0	11:36.6	11:36.6	NULL	7250379	7250379	0	1	3	<java><c#><security><encryption><aes>	How to handle BadPaddingException During AES256 encryption in C# and decryption in Java	1101	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
54597331	54607147	1	"<p>javax.crypto.BadPaddingException: Given final block not properly padded - This is the error which I've got. I do not know why. My code seems to be alright. The key is the same during encrypting and decrypting. What I can say is that none of the already answered questions contain solution for my problem. Here is my code:</p>

<pre><code>public String decrypt(String text) throws Exception {

    String key = ""SiadajerSiadajer""; // 128 bit key
    // Create key and cipher
    Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    // encrypt the text
    byte[]encrypted = text.getBytes();
    cipher.init(Cipher.DECRYPT_MODE, aesKey);
    String decrypted = new String(cipher.doFinal(encrypted)); //Here is the error

    return decrypted;


}
</code></pre>

<p>And the encryption mechanism in php</p>

<pre><code>function encrypt($data, $size)
{
    $length = $size - strlen($data) % $size;
    return $data . str_repeat(chr($length), $length);
}

function decrypt($data)
{
    return substr($data, 0, -ord($data[strlen($data) - 1]));
}
$key = ""SiadajerSiadajer"";
$iv_size = 16; // 128 bits
$iv = openssl_random_pseudo_bytes($iv_size, $strong);
$name = openssl_encrypt(encrypt($name, 16), 'AES-256-CBC', $key, 0, $iv);
</code></pre>

<p>EDIT </p>

<p>Now in the php part my code is:</p>

<pre><code>$key = ""SiadajerSiadajer"";
$iv_size = 16; // 128 bits
$iv = openssl_random_pseudo_bytes($iv_size, $strong);
$EIV = base64_encode($iv);
$name = openssl_encrypt(encrypt($name, 16), 'AES-256-CBC', $key, 0, $EIV);
</code></pre>

<p>And it gives me warning:Warning: openssl_encrypt(): IV passed is 24 bytes long which is longer than the 16 expected by selected cipher, truncating in C:\xampp2\htdocs\standardfinalinserting.php on line 68</p>

<p>And in Java part my decryption method is exactly like in the answer for my question but after running it gives me an error: java.security.InvalidKeyException: Illegal key size on the line:               </p>

<p>cipher.init(Cipher.DECRYPT_MODE, aesKey, ivParameterSpec);</p>

<p>EDIT 2:</p>

<p>So this is my whole Main class. It contains your whole Java code example</p>

<pre><code>public class Main {

    private byte[] padKey(byte[] key) {
        byte[] paddedKey = new byte[32];
        System.arraycopy(key, 0, paddedKey, 0, key.length);
        return paddedKey;
    }

    private byte[] unpad(byte[] data) {     
        byte[] unpaddedData = new byte[data.length - data[data.length - 1]];
        System.arraycopy(data, 0, unpaddedData, 0, unpaddedData.length);
        return unpaddedData;
    }

    public String decrypt(String encodedJoinedData) throws Exception {

        // Base64-decode the joined data
        byte[] joinedData = Base64.decode(encodedJoinedData); 

        // Get IV and encrypted data
        byte[] iv = new byte[16];
        System.arraycopy(joinedData, 0, iv, 0, iv.length);
        byte[] encryptedData = new byte[joinedData.length - iv.length];
        System.arraycopy(joinedData, iv.length, encryptedData, 0, encryptedData.length);

        // Pad key
        byte[] key = padKey(""SiadajerSiadajer"".getBytes()); 
        Key aesKey = new SecretKeySpec(key, ""AES"");

        // Specify CBC-mode
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); 
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); 
        cipher.init(Cipher.DECRYPT_MODE, aesKey, ivParameterSpec); //HERE IS THE ERROR

        // Decrypt data
        byte[] decryptedData = cipher.doFinal(encryptedData);

        // Remove custom padding
        byte[] unpaddedData = unpad(decryptedData);         

        return new String(unpaddedData);
    }

    public static void main(String[] args) throws Exception {
        // TODO Auto-generated method stub
         String encodedJoinedData = ""RB6Au33KGOF1/z3BQKqievUmh81Y8q4uw7s4vEs9xurQmNZAKwmhRQtS9wGYKQj8cJaPpK2xaDzx3RppQ8PsM/rQ9/p0Lme+x75dozBEbmFn6Q9eCXOCiCivVsKzZ8Vz"";
            String decryptedData = new Main().decrypt(encodedJoinedData);
            System.out.println(decryptedData + "" - "" + decryptedData.length());



     }



}
</code></pre>

<p>Running the code results in error:</p>

<pre><code>Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1039)
    at javax.crypto.Cipher.implInit(Cipher.java:805)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1396)
    at javax.crypto.Cipher.init(Cipher.java:1327)
    at com.dd.escuel.Main.decrypt(Main.java:43)
    at com.dd.escuel.Main.main(Main.java:57)
</code></pre>
"	NULL	10	NULL	14:59.8	0	15:42.2	14:51.6	NULL	9836694	9836694	0	1	0	<java><security><encryption><cryptography><aes>	javax.crypto.BadPaddingException: Given final block not properly padded - Strange error	849	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
54604508	0	1	"<p>I'm willing to encrypt/decrypt data by using an AES Key stored in a softHSM2 software.</p>

<p>I'm creating my key with the following code:</p>

<pre><code>    String configName = ""C:\\SoftHSM2\\etc\\pkcs11.cfg"";

    cipher = Cipher.getInstance(""AES"");

    Provider p = new SunPKCS11(configName);
    if (-1 == Security.addProvider(p)) {
        throw new RuntimeException(""could not add security provider"");
    }

    // Load the key store
    char[] pin = ""123456789"".toCharArray();
    keyStore = KeyStore.getInstance(""PKCS11"", p);
    keyStore.load(null, pin);

    SecretKeySpec secretKeySpec = new 
    SecretKeySpec(""0123456789ABCDEF"".getBytes(), ""AES"");
    Key key = new SecretKeySpec(secretKeySpec.getEncoded(), ""AES"");
    keyStore.setKeyEntry(""AESKey1"", key, ""123456789"".toCharArray(), null);
    keyStore.store(null);
</code></pre>

<p>here is the pkcs11.cfg</p>

<pre><code>name = SoftHSM2
library = c:\SoftHSM2\lib\softhsm2-x64.dll 
slotListIndex = 1
</code></pre>

<p>My Key is correctly added, here is the output:</p>

<pre><code>AESKey1: SunPKCS11-SoftHSM2 AES secret key, 16 bits (id 4, token object, not sensitive, unextractable)
</code></pre>

<p>Now I would like to encrypt / decrypt by using this key. Here is the code to encrypt:</p>

<pre><code>        myKey = keyStore.getKey(""AESKey1"", ""123456789"".toCharArray()); 
        System.out.println(""Using key: ""+myKey.toString());        
        byte[] plainTextByte = text.getBytes();                 
        cipher.init(Cipher.ENCRYPT_MODE, myKey);
        byte[] encryptedByte = cipher.doFinal(plainTextByte);
        Base64.Encoder encoder = Base64.getEncoder();
        encryptedText = encoder.encodeToString(encryptedByte);
</code></pre>

<p>and the Decrypt function:</p>

<pre><code>        Base64.Decoder decoder = Base64.getDecoder();
        byte[] encryptedTextByte = decoder.decode(text);
        cipher.init(Cipher.DECRYPT_MODE, keyStore.getKey(""AESKey1"", ""1234"".toCharArray())); 
        byte[] decryptedByte = cipher.doFinal(encryptedTextByte);
        decryptedText = new String(decryptedByte);
</code></pre>

<p>but I have the following Exception Raised:</p>

<pre><code>Using key: SunPKCS11-SoftHSM2 AES secret key, 16 bits (id 10, token object, not sensitive, unextractable)
java.security.InvalidKeyException: No installed provider supports this key: 
sun.security.pkcs11.P11Key$P11SecretKey
    at javax.crypto.Cipher.chooseProvider(Cipher.java:888)
    at javax.crypto.Cipher.init(Cipher.java:1229)
    at javax.crypto.Cipher.init(Cipher.java:1166)

 Encrypted Text After Encryption: 
java.security.InvalidKeyException: No installed provider supports this key: sun.security.pkcs11.P11Key$P11SecretKey
at javax.crypto.Cipher.chooseProvider(Cipher.java:888)
at javax.crypto.Cipher.init(Cipher.java:1229)
</code></pre>

<p>both cipher.init calls are raising an Exception, note that this code is working perfectly if I'm creating the AES key like this (out of the softHSM2):</p>

<pre><code>        KeyGenerator keyGenerator = KeyGenerator.getInstance(""AES"");
        keyGenerator.init(128); // block size is 128bits
        SecretKey secretKey = keyGenerator.generateKey();
</code></pre>

<p>May be I'm missing something ?</p>
"	NULL	2	NULL	24:05.8	0	07:01.3	NULL	NULL	0	3529526	0	1	1	<java><encryption><aes><softhsm>	No installed provider supports this key: sun.security.pkcs11.P11Key$P11SecretKey while using SoftHSM2 AES Key	1281	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
54926263	54928673	1	"<p>I need to port some code from <code>java</code> to <code>javascript</code> which handles encryption. I am unable to reproduce same cipher text as per the existing code, given the same key. </p>

<p>I am suspecting that I am not able to figure out the correct mode. Attaching the code snippet- <br></p>

<pre><code>public String encrypt(String message, String enc_key) throws Exception {
    try {
        initEncrypt(enc_key);

        byte[] encstr = cipher.doFinal(message.getBytes());
        return HexUtil.HextoString(encstr);
    } catch (BadPaddingException nse) {
        throw new Exception(""Invalid input String"");
    }
}

public void initEncrypt(String key) throws Exception {
    try {
        skeySpec = new SecretKeySpec(HexUtil.HexfromString(key), ""AES"");
        cipher = Cipher.getInstance(""AES"");
        // cipher.
        cipher.init(1, skeySpec);
        System.out.println(cipher.getAlgorithm());
    } catch (NoSuchAlgorithmException nsae) {
        throw new Exception(""Invalid Java Version"");
    } catch (NoSuchPaddingException nse) {
        throw new Exception(""Invalid Key"");
    }
}
</code></pre>

<p>HexToString function just converts the hex string key in byte array.</p>

<p>Providing the key - <code>10663d0b39d73d614116f0b3cbebd666</code> (hex)
Plain text-  <code>hello</code> , I get -
Cipher text - <code>57C758B2B3A8580658A11DBD95109EC4</code></p>

<p>According to this <a href=""https://stackoverflow.com/questions/6258047/java-default-crypto-aes-behavior"">so</a> answer, default mode should be <code>AES/ECB/PKCS5Padding</code></p>

<p>But when I try to encrypt using same values <a href=""https://8gwifi.org/CipherFunctions.jsp"" rel=""nofollow noreferrer"">here</a> I get cipher text- <br></p>

<pre><code>3874350661ABB0B452A4960FE3953C18
</code></pre>

<p>I have tried various other modes but I am unable to match the cipher text.
Any help will be appreciated.</p>
"	NULL	3	NULL	54:51.7	0	07:00.6	11:35.5	NULL	843943	2594446	0	1	1	<javascript><java><encryption>	AES encryption in Java - what mode?	1134	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
55066289	55067257	NULL	"<p>I'm doing an independent project by myself about encryption/decryption message using JCA-JCE and WindowBuilder as GUI.</p>

<p>My problem is when the cipher has to encrypt the message and convert that in a ciphertext this Exception came out every time </p>

<p>javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes </p>

<p>I try it without GUI first and everything went ok</p>

<p>now I will show you the code but please don't be rude on me for the confusion of the code lol it's just a ""prototype"" </p>

<p>Thanks to everyone who can help me </p>

<pre><code>    import java.awt.EventQueue;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.swing.JButton;
import javax.swing.JComboBox;
import java.awt.event.ActionListener;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.awt.event.ActionEvent;

import java.awt.EventQueue;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.swing.JButton;
import javax.swing.JComboBox;
import java.awt.event.ActionListener;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.awt.event.ActionEvent;

public class GUI2 extends JFrame {

    private JPanel contentPane;
    private JTextField txtInsert;


    static Cipher ecipher;
    static SecretKey key;
    static byte[] mex;
    static String alg;
    int index;
    static byte[] ciphertext;
    String uno=new String(""k"");
    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    GUI2 frame = new GUI2();
                    frame.setVisible(true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    /**
     * Create the frame.
     * @throws UnsupportedEncodingException 
     */
    public GUI2() throws UnsupportedEncodingException {
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 602, 408);
        contentPane = new JPanel();
        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
        setContentPane(contentPane);
        contentPane.setLayout(null);

        JLabel lblInserisciTesto = new JLabel(""Inserisci Testo"");
        lblInserisciTesto.setBounds(29, 33, 190, 14);
        contentPane.add(lblInserisciTesto);

        /////////////////TEXTFIELD////////////////
        txtInsert = new JTextField();
        mex=uno.getBytes(""UTF-8"");
        txtInsert.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
            try {
                mex=txtInsert.getText().getBytes(""UTF-8"");
            } catch (UnsupportedEncodingException e1) {
                // TODO Auto-generated catch block
                e1.printStackTrace();
            }
            }
        });{
        txtInsert.setText(""INSERT"");
        txtInsert.setBounds(276, 30, 284, 20);
        contentPane.add(txtInsert);
        txtInsert.setColumns(10);


        }


        ///////////////LABEL SELEZIONA ALGORITMO/////////////
        JLabel lblSelezionaAlgoritmo = new JLabel(""Seleziona Algoritmo"");
        lblSelezionaAlgoritmo.setBounds(29, 109, 104, 14);
        contentPane.add(lblSelezionaAlgoritmo); 





        ///////////////BUTTON//////////////////////////////
        JButton btnCrypt = new JButton(""CRYPT"");{
        btnCrypt.setBounds(223, 316, 89, 23);
        contentPane.add(btnCrypt);


        btnCrypt.addActionListener(new ActionListener() {     /////ACTION
            public void actionPerformed(ActionEvent e) {
                if((index&gt;=0)&amp;&amp;(index&lt;4)) {
                try {
                    SecureRandom random=new SecureRandom();
                    KeyGenerator keygen=KeyGenerator.getInstance(""AES"");
                    keygen.init(256,random);
                    key=keygen.generateKey();
                    ecipher=Cipher.getInstance(alg);
                    ecipher.init(Cipher.ENCRYPT_MODE,key);
                    ciphertext = ecipher.doFinal(mex);
                    System.out.println(ciphertext);

                } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException  e1) {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
                }

                }else if((index&gt;=4)&amp;&amp;(index&lt;7)) {

                }

            }
        });
        }
        //////////////COMBOBOX//////////////////
        JComboBox comboBox = new JComboBox();
        comboBox.setBounds(276, 105, 284, 22);

        String a=new String(""AES/CBC/NoPadding"");
        String b=new String(""AES/CBC/PKCS5Padding"");
        String c=new String(""AES/ECB/NoPadding"");
        String d=new String(""AES/ECB/PKCS5Padding"");
        String f=new String(""DES/CBC/PKCS5Padding"");
        String g=new String(""DES/ECB/NoPadding"");
        String h=new String(""DES/ECB/PKCS5Padding"");

        comboBox.addItem(a);
        comboBox.addItem(b);
        comboBox.addItem(c);
        comboBox.addItem(d);
        comboBox.addItem(f);
        comboBox.addItem(g);
        comboBox.addItem(h);
        contentPane.add(comboBox);

        comboBox.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                alg=(String) comboBox.getSelectedItem();
                index=comboBox.getSelectedIndex();
            }
        });{


        }




        JLabel lblCiphertext = new JLabel(""CipherText"");
        lblCiphertext.setBounds(29, 204, 104, 14);
        contentPane.add(lblCiphertext);

        JLabel lblNewLabel = new JLabel(""New label"");
        lblNewLabel.setBounds(276, 195, 284, 23);
        contentPane.add(lblNewLabel);
    }
}
</code></pre>
"	NULL	NULL	NULL	27:00.1	NULL	NULL	NULL	NULL	NULL	11085772	0	1	0	<java><encryption><windowbuilder>	Problem using eclipse WindowBuilder and JCA-JCE methods	48	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
55099746	55100103	NULL	"<p>I wrote this code, my key is: ""ooWqEPcw7KR/h/JIbrFCRHiEVaybvnB2"".</p>

<pre><code>    try
    {
        Base64Decoder base64Decoder=new Base64Decoder();

        String encryptType=""DESede/ECB/PKCS5Padding"";
        String workingKey=""ooWqEPcw7KR/h/JIbrFCRHiEVaybvnB2"";
        SecretKey secretKey=new SecretKeySpec(base64Decoder.decode(workingKey), encryptType);

        Cipher cipher=Cipher.getInstance(encryptType);
        cipher.init(1, secretKey);
    }
    catch(NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e)
    {
        e.printStackTrace();
    }
</code></pre>

<p>But I get this error!!!</p>

<pre><code>java.security.InvalidKeyException: Wrong algorithm: DESede or TripleDES required
    at com.sun.crypto.provider.DESedeCrypt.init(DESedeCrypt.java:65)
    at com.sun.crypto.provider.ElectronicCodeBook.init(ElectronicCodeBook.java:93)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:582)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:458)
    at  com.sun.crypto.provider.DESedeCipher.engineInit(DESedeCipher.java:166)
    at javax.crypto.Cipher.implInit(Cipher.java:802)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:864)
    at javax.crypto.Cipher.init(Cipher.java:1249)
    at javax.crypto.Cipher.init(Cipher.java:1186)
    at EncryptText.main(EncryptText.java:24)
</code></pre>
"	NULL	NULL	NULL	26:25.9	NULL	NULL	NULL	NULL	NULL	2545982	0	1	1	<java><encryption><cryptography><3des>	java.security.InvalidKeyException: Wrong algorithm: DESede or TripleDES required	1599	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
55368098	0	0	"<p>I have the code provided which works with ECB but I need to be able to also implement CBC, CFB, OFB, and CTR. If I can get these modes working, then I can complete my project by testing error propagation, and pattern preservation. I currently have the DES version for you to view, but ideally, i should be able to make slight alterations to make it AES supported as well.</p>

<p>Coding various entry level projects and a few security related projects, but no prior encryption experience.</p>

<pre><code>   import com.sun.xml.internal.messaging.saaj.packaging.mime.util.BASE64DecoderStream;
    import com.sun.xml.internal.messaging.saaj.packaging.mime.util.BASE64EncoderStream;
    import java.io.UnsupportedEncodingException;
    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.KeyGenerator;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    //import java.util.Scanner;

    public class DES {

    public static void main(String[] args) {

    String strEnc = ""01 02 03 04 05 06 0a 0b 0c 0d 0e 0f"";

    try {

    KeyGenerator kg = KeyGenerator.getInstance(""DES"");
    SecretKey myKey = kg.generateKey();
    Cipher enc, des;
    enc = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
    des = Cipher.getInstance(""DES/ECB/PKCS5Padding"");

    // initialize the ciphers with the given key
    enc.init(Cipher.ENCRYPT_MODE, myKey);
    des.init(Cipher.DECRYPT_MODE, myKey);

    //Scanner in = new Scanner(System.in);
    //System.out.println(""Please enter your message: "");
    byte[] messageUtf8 = strEnc.getBytes(""UTF8"");

    System.out.println(""Message [Byte Format} : "" + messageUtf8);
    //System.out.println(""Message: "" + new String(messageUtf8));

    byte[] encMessage = enc.doFinal(messageUtf8);
    encMessage = BASE64EncoderStream.encode(encMessage);
    String encMsg = new String(encMessage);
    System.out.println(""Encrypted Message: "" + encMsg);

    // Decryption

    // decode with base64 to get bytes
    byte[] dec = BASE64DecoderStream.decode(encMsg.getBytes());

    byte[] decMessageUtf8 = des.doFinal(dec);

    String decMsg = new String(decMessageUtf8);   
    System.out.println(""Decrypted Message: "" +decMsg );

    } catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
    } catch (NoSuchPaddingException e) {
    e.printStackTrace();
    } catch (InvalidKeyException e) {

    e.printStackTrace();
    } catch (BadPaddingException e) {

    e.printStackTrace();
    } catch (IllegalBlockSizeException e) {

    e.printStackTrace();
    } catch (UnsupportedEncodingException e) {

    e.printStackTrace();
    }

    }
    }
</code></pre>

<p>Expected results would to provide out put like this for each mode:</p>

<pre><code>Message [Byte Format} : [B@7bb11784
Encrypted Message: dk2TnVfLHZf4p9o7fa00XjVaGenbiIItrCHhhA/UbjDcvf+E2Av5pw==
Decrypted Message: 01 02 03 04 05 06 0a 0b 0c 0d 0e 0f
</code></pre>

<p>However, I am getting these messages when trying to change modes:</p>

<pre><code>java.security.InvalidKeyException: Parameters missing
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:469)
    at com.sun.crypto.provider.DESCipher.engineInit(DESCipher.java:186)
    at javax.crypto.Cipher.implInit(Cipher.java:801)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:863)
    at javax.crypto.Cipher.init(Cipher.java:1248)
    at javax.crypto.Cipher.init(Cipher.java:1185)
    at DES.main(DES.java:30)
</code></pre>
"	NULL	0	NULL	28:46.3	0	28:46.3	NULL	NULL	0	11263308	0	1	2	<java>	implementing opmodes in java encryption program dealing with both DES and AES	121	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
55757515	55760360	2	"<p>I'm trying to produce what this site is doing <a href=""https://codebeautify.org/encrypt-decrypt"" rel=""nofollow noreferrer"">https://codebeautify.org/encrypt-decrypt</a> using <code>Blowfish</code> and <code>CBC</code></p>

<p>I'm not sure what's the actual term but the encryption method that I'd like to achieve shall produce non-consistent encrypted string despite using same content and key, </p>

<p>For example if I encrypt <code>Hello</code> with key <code>key123</code>, twice, the first result may show <code>abcde</code>, and second should show something else, like <code>fghij</code>. But decrypting both <code>abcde</code> and <code>fghij</code> with <code>key123</code> shall return the same <code>Hello</code>.</p>

<p><a href=""https://i.stack.imgur.com/sKW2o.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sKW2o.png"" alt=""enter image description here""></a></p>

<p>Also may I know what's the type of encoding they are using to produce the final result? Such as hex/base64, because I tried both, but it doesn't seems to produce similar result.</p>

<p>This is what I'm using:</p>

<p><strong>The Crypto class:</strong></p>

<pre><code>public static String enc(String content, String key) {
    String encCon = """";

    try {
        String IV = ""12345678"";

        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""Blowfish"");
        Cipher cipher = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");

        String secret = content;
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, new javax.crypto.spec.IvParameterSpec(IV.getBytes(""UTF-8"")));
        byte[] encoding = cipher.doFinal(secret.getBytes(""UTF-8""));

        System.out.println(""-- Encrypted -----------"");
        encCon = DatatypeConverter.printBase64Binary(encoding);
        System.out.println(""-- encCon : "" + encCon);
    } catch (Exception ex) {
        logger.error(ex.getMessage(), ex);
    }

    return encCon;
}

public static String dec(String content, String key) {
    String decCon = """";

    try {
        String IV = ""12345678"";

        SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""Blowfish"");
        Cipher cipher = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");

        // Decode Base64
        byte[] ciphertext = DatatypeConverter.parseBase64Binary(content);

        // Decrypt
        cipher.init(Cipher.DECRYPT_MODE, keySpec, new javax.crypto.spec.IvParameterSpec(IV.getBytes(""UTF-8"")));
        byte[] message = cipher.doFinal(ciphertext);

        System.out.println(""-- Decrypted -----------"");
        decCon = new String(message, ""UTF-8"");
        System.out.println(""-- decCon : "" + decCon);
    } catch (Exception ex) {
        logger.error(ex.getMessage(), ex);
    }

    return decCon;
}
</code></pre>

<p><strong>The calling class (such as Main.java)</strong></p>

<pre><code>// This is what I get from codebeautify site, encrypting Hello with key123
// However, I'm getting javax.crypto.BadPaddingException: Given final block not properly padded
Crypto.dec(""08GCpwyZc+qGNuxSvXAD2A=="", ""key123""); 

// Below 2 lines works fine, the only problem is the result isn't randomized
String encContent = Crypto.enc(""Hello"", ""key123"");
Crypto.dec(encContent, ""key123"");
</code></pre>
"	NULL	15	NULL	26:07.9	0	49:02.2	07:02.8	NULL	1131470	1131470	0	1	1	<java><encryption><blowfish>	Java Blowfish Encryption with CBC	2167	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
55901662	55916311	2	"<p>I am trying to convert an existing C# encryption method to Java, but have hit a roadblock as below</p>

<p>For example when I encrypt a basic string ""12345"" with c# I get this output
8ZQZEUrctqP1PMmQxVtCcA==</p>

<p>And when I encrypt the same string with java I get this
jkEZp2cfeGXVE/IxIW6X3g==</p>

<pre class=""lang-cs prettyprint-override""><code>private static string Encrypt(string plainText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations,
                        string initVector, int keySize)
{
    try
    {
        byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
        byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
        byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        PasswordDeriveBytes password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, passwordIterations);
        byte[] keyBytes = password.GetBytes(keySize / 8);
        RijndaelManaged symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };
        ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] cipherTextBytes = memoryStream.ToArray();
        memoryStream.Close();
        cryptoStream.Close();
        string cipherText = Convert.ToBase64String(cipherTextBytes);
        return cipherText;
    }
    catch (Exception execp)
    {
        MessageBox.Show(string.Format(""Exception in Encrypt function\r\nError: {0}"", execp.Message));
        return """";
    }
}

private static string Decrypt(string cipherText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations,
                                string initVector, int keySize)
{
    try
    {
        if (cipherText == string.Empty)
            return """";

        byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
        byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
        byte[] cipherTextBytes = Convert.FromBase64String(cipherText);
        PasswordDeriveBytes password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, passwordIterations);
        byte[] keyBytes = password.GetBytes(keySize / 8);
        RijndaelManaged symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };
        ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);
        MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
        CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
        byte[] plainTextBytes = new byte[cipherTextBytes.Length];
        int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
        memoryStream.Close();
        cryptoStream.Close();
        string plainText = Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
        return plainText;
    }
    catch (Exception execp)
    {
        MessageBox.Show(string.Format(""Exception in Decrypt function\r\nError: {0}"", execp.Message));
        return """";
    }
}

public static string ProtectPassword(string plainText)
{
    try
    {
        const string passPhrase = ""Ydfv324232r!23%47%7^&amp;ex&gt;,1""; // can be any string
        const string saltValue = ""s@1tValue""; // can be any string
        const string hashAlgorithm = ""SHA1""; // can be ""MD5""
        const int passwordIterations = 101; // can be any number
        const string initVector = ""@1B2vQ94eZF6g7H1""; // must be 16 bytes
        const int keySize = 256; // can be 192 or 128

        string ret = Encrypt(plainText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);

        return ret;
    }
    catch (Exception execp)
    {
        MessageBox.Show(string.Format(""Exception in ProtectPassword function\r\nError: {0}"", execp.Message));
        return """";
    }
}

public static string UnprotectPassword(string cipherText)
{
    try
    {
        const string passPhrase = ""Ydfv324232r!23%47%7^&amp;ex&gt;,1""; // can be any string
        const string saltValue = ""s@1tValue""; // can be any string
        const string hashAlgorithm = ""SHA1""; // can be ""MD5""
        const int passwordIterations = 101; // can be any number
        const string initVector = ""@1B2vQ94eZF6g7H1""; // must be 16 bytes
        const int keySize = 256; // can be 192 or 128

        string ret = Decrypt(cipherText, passPhrase, saltValue, hashAlgorithm, passwordIterations, initVector, keySize);

        return ret;
    }
    catch (Exception execp)
    {
        MessageBox.Show(string.Format(""Exception in UnprotectPassword function\r\nError: {0}"", execp.Message));
        return """";
    }
}
</code></pre>

<p>And below is what I have converted to java, yet still don't quite get the same encrypted inputs and outputs - I just renamed ""ProtectPassword"" to ""Encrypt"" and ""UnprotectPassword"" to ""Decrypt""</p>

<pre class=""lang-java prettyprint-override""><code>import java.io.ByteArrayOutputStream;
import java.security.SecureRandom;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class Encryption {

    public static String Encrypt(String str)
    {
        try 
        {
            String passPhrase = ""Ydfv324232r!23%47%7^&amp;ex&gt;,1"";
            String saltValue = ""s@1tValue"";
            int passwordIterations = 101;
            int keySize = 256;
            String initVector = ""@1B2vQ94eZF6g7H1"";

            SecureRandom random = new SecureRandom();
            byte[] salt = new byte[16];
            random.nextBytes(salt);

            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), saltValue.getBytes(""UTF-8""), passwordIterations, keySize);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(initVector.getBytes(""UTF-8"")));            
            byte[] encryptedText = cipher.doFinal(str.getBytes(""UTF-8""));

            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();           
            outputStream.write(encryptedText);

            // properly encode the complete cipher text
            return DatatypeConverter.printBase64Binary(outputStream.toByteArray());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }   

    public static String Decrypt(String str)
    {
        try 
        {
            String passPhrase = ""Ydfv324232r!23%47%7^&amp;ex&gt;,1"";
            String saltValue = ""s@1tValue"";
            int passwordIterations = 101;
            int keySize = 256;
            String initVector = ""@1B2vQ94eZF6g7H1"";

            byte[] ciphertext = DatatypeConverter.parseBase64Binary(str);           

            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), saltValue.getBytes(), passwordIterations, keySize);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

            cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(initVector.getBytes(""UTF-8"")));
            byte[] plaintext = cipher.doFinal(ciphertext);

            return new String(plaintext, ""UTF-8"");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
"	NULL	0	NULL	40:02.7	0	57:14.8	NULL	NULL	0	4852147	0	1	0	<java><c#><encryption>	Need help converting C# encryption method to Java	694	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
56612055	0	0	"<p>I am encrypting string using java ""DESede"" with 16 bit. I copied code from application which was working fine. But when i tried it is not working. I don't want to change key and encryption</p>

<p>Key in <code>byte[] key = {-104, 26, -6, -116, -34, -72, -88, -9, -27, -96, 81, -76, 9, -69, 68, -49}</code></p>

<pre><code>  Key secretKeySpec = new SecretKeySpec(newChar, ""DESede"");
  Cipher instance = Cipher.getInstance(""DESede"");
  instance.init(Cipher.ENCRYPT_MODE, secretKeySpec);

</code></pre>

<p>Error:</p>

<pre><code>java.security.InvalidKeyException: Wrong key size
    at com.sun.crypto.provider.DESedeCrypt.init(DESedeCrypt.java:69)
    at com.sun.crypto.provider.ElectronicCodeBook.init(ElectronicCodeBook.java:94)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:591)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:467)
    at com.sun.crypto.provider.DESedeCipher.engineInit(DESedeCipher.java:166)
    at javax.crypto.Cipher.implInit(Cipher.java:801)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:863)
    at javax.crypto.Cipher.init(Cipher.java:1248)
    at javax.crypto.Cipher.init(Cipher.java:1185)
</code></pre>
"	NULL	4	NULL	11:49.8	0	39:09.1	39:09.1	NULL	238704	6817572	0	1	0	<java><encryption><key><size>	java.security.InvalidKeyException: Wrong key size DESede encryption	618	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
57575822	0	0	"<p>I've had a client application currently running well on <code>Java 7</code>. In the near future, it has to be run on <code>Java 8</code>. If I change <code>JRE</code> to version 8 the application is still running without errors, but it's performance degrades. This is is also true if I compile it for <code>Java 8</code>. As I have found, one of the issues is the following statement</p>

<pre><code>Cipher cipher = Cipher.getInstance(""DES"");
</code></pre>

<p>With <code>Java 7</code> it takes <code>1300</code> milliseconds on average, with <code>Java 8</code> about <code>2200</code>. That is not much for one call but it adds up for thousands of calls. Because every client call runs in its own <code>VM</code> the cipher instance can not be reused (without rewriting the whole application).</p>

<p>Is there a way to increase performance?</p>
"	NULL	9	NULL	25:22.7	1	32:31.1	32:31.1	NULL	10045660	1457017	0	1	0	<java><encryption>	Cipher.getInstance slow with Java 8	248	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
58091189	58111291	1	"<p>I have used the below OpenSSL code to do an AES encryption which is decrypting successfully in the Tax website</p>

<pre><code>openssl rand 48 &gt; 48byterandomvalue.bin
hexdump /bare 48byterandomvalue.bin &gt; 48byterandomvalue.txt

set /a counter=0
for /f ""tokens=* delims= "" %%i in (48byterandomvalue.txt) do (
set /a counter=!counter!+1
set var=%%i
if ""!counter!""==""1"" (set aes1=%%i)
if ""!counter!""==""2"" (set aes2=%%i)
if ""!counter!""==""3"" (set iv=%%i)
)

set result1=%aes1:~0,50%
set result1=%result1: =%
set result2=%aes2:~0,50%
set result2=%result2: =%
set aeskey=%result1%%result2%
set initvector=%iv:~0,50%
set initvector=%initvector: =%

openssl aes-256-cbc -e -in PAYLOAD.zip -out PAYLOAD -K %aeskey% -iv %initvector%

openssl rsautl -encrypt -certin -inkey test_public.cer -in 
48byterandomvalue.bin -out 000000.00000.TA.840_Key
</code></pre>

<p>But I wanted to do the same this in Java as part of migration, so i used the <strong>javax.crypto</strong> and <strong>java.security</strong> libraries but the decryption is failing when I upload the file on the Tax website</p>

<pre><code>//creating the random AES-256 secret key
SecureRandom srandom = new SecureRandom(); 
KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
keyGen.init(256);
SecretKey secretKey = keyGen.generateKey();
byte[] aesKeyb = secretKey.getEncoded();

//creating the initialization vector
byte[] iv = new byte[128/8];
srandom.nextBytes(iv);
IvParameterSpec ivspec = new IvParameterSpec(iv);

byte[] encoded = Files.readAllBytes(Paths.get(filePath));
str = new String(encoded, StandardCharsets.US_ASCII);

//fetching the Public Key from certificate
FileInputStream fin = new FileInputStream(""test_public.cer"");
CertificateFactory f = CertificateFactory.getInstance(""X.509"");
X509Certificate certificate = (X509Certificate)f.generateCertificate(fin);
PublicKey pk = certificate.getPublicKey();

//encrypting the AES Key with Public Key
Cipher RSACipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
RSACipher.init(Cipher.ENCRYPT_MODE, pk);
byte[] RSAEncrypted = RSACipher.doFinal(aesKeyb);

FileOutputStream out = new FileOutputStream(""000000.00000.TA.840_Key"");
out.write(RSAEncrypted);
out.write(iv);
out.close();
</code></pre>

<p>Also, the AES key generated in java is different from the one generated via openssl. Can you guys please help.</p>

<p><strong>EDIT 1:</strong>
Below is the code for AES Encrpytion used:</p>

<pre><code>Cipher AESCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
AESCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
byte[] AESEncrypted = AESCipher.doFinal(str.getBytes(""UTF-8""));
String encryptedStr = new String(AESEncrypted);
</code></pre>
"	NULL	1	NULL	32:46.2	1	07:02.1	12:46.5	NULL	1853243	1853243	0	1	3	<java><encryption><openssl><aes>	AES Encryption done in OpenSSL is decrypted successfully but fails when encrypted in Java	461	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
58276562	58280688	1	"<p>Preface:  I don't know whether it's more appropriate to ask this question here or on the Crypto site.  Feel free to move or delete or whatever the appropriate SE action is.</p>

<hr>

<p>I've been asked to help update some encryption software.  Broadly speaking, the software already does the following steps, none of which are particularly unusual.  I've left out the error handling and <code>Provider</code> arguments for simplicity of posting:</p>

<p>1) Generates a random symmetric secret key for use with AES-128 (or AES-256, <em>mutatis mutandis</em>):</p>

<pre><code>KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
keygen.init (128, a_SecureRandom_instance);
SecretKey sessionKey = keygen.generateKey();
</code></pre>

<p>2) Wraps the symmetric secret key, depending on whether the user is using...<br>
2a) ...an RSA public key from a keypair:</p>

<pre><code>// OAEP wasn't used in this software for hysterical raisins
Cipher wrapper = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
wrapper.init (Cipher.WRAP_MODE, user_RSA_PublicKey);
</code></pre>

<p>2b) ...a passphrase:</p>

<pre><code>SecretKey stretched = ...passphrase stretched through a PBKDF like bcrypt...;
// I don't remember whether it's specified as ""AES"" or ""AESWrap"" here
Cipher wrapper = Cipher.getInstance(""AES or AESWrap/ECB/NoPadding"");
wrapper.init (Cipher.WRAP_MODE, stretched);
</code></pre>

<p>2c) Either route, the session key is wrapped:</p>

<pre><code>byte[] wrapped = wrapper.wrap(sessionKey);
</code></pre>

<p>3) The session key is used to create a <code>Cipher</code> using <code>Cipher.ENCRYPT_MODE</code> along with a random IV, and then shedloads of data are run through it.  That part is pretty standard but I can post it if you really want to see <code>CipherInputStream</code> usage.  The wrapped session key is stored along with the encrypted data and a bunch of HMACs of everything under the sun.</p>

<p>Later at decryption time, the user provides either the RSA private key, or the passphrase for stretching; the software unwraps the symmetric key and decrypts the data.</p>

<p>All of that has been working for some time.  But of course RSA keypairs are getting big and slow, so they'd like to support an additional possibility for step #2 above, in which the public keys are generated using an elliptic curve algorithm (P384 ECDH is the usual case).  And this is where we're getting confused.</p>

<p>There doesn't seem to be a JCE replacement algorithm/transformation for elliptic curves in the <code>Cipher wrapper = Cipher.getInstance(""RSA/ECB/PKCS1Padding"")</code> invocation.  The only one listed in the Java documentation is ""ECIES"", which seems(?) to be aimed more towards multiple party key agreement?</p>

<p>All of the APIs that I can find for the Java builtin JCE, or even looking over Bouncy Castle, only mention ECDH keys in the context of key agreement and transport, where they're used to <em>generate</em> a symmetric secret key instead of <em>wrapping</em> an existing one.</p>

<p>I feel we're missing something here, possibly because of poor assumptions.  Is <code>Cipher.wrap()</code> genuinely not an option with ECDH keys?  Or it <em>is</em>, but we need to do something funky in order to create the ECIES <code>Cipher</code> instance?</p>
"	NULL	1	NULL	16:09.0	1	36:44.4	NULL	NULL	0	1824182	0	1	2	<java><cryptography><elliptic-curve>	Key wrapping with an ECDH public key?	1012	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
58599423	58602392	1	"<p>I'm trying to create a AES key with this code</p>

<pre class=""lang-java prettyprint-override""><code>    public static SecretKey generateSecretKey() {

        KeyGenerator generator;
        try {

            generator = KeyGenerator.getInstance(StaticHandler.AES_KEY_MODE); // Is ""AES""
            generator.init(StaticHandler.AES_KEY_SIZE); // The AES key size in number of bits // Is ""128""

            return generator.generateKey();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>

<p>however using this code for encrypting/decrypting</p>

<pre class=""lang-java prettyprint-override""><code>
    public static String encrypt(String data, SecretKey secret, Charset charset) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secret);

            return new String(cipher.doFinal(data.getBytes()), charset);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    public static String decrypt(String data, @NonNull SecretKey secret, Charset charset) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, secret);

            return new String(cipher.doFinal(data.getBytes()), charset);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>

<p>gets the error 
<code>java.security.InvalidKeyException: Parameters missing</code></p>

<p>I'm guessing I need to add some salt, though I don't know how to do that with a generated key. I would like to stray away from generating a password but if it's a securely generated password I wouldn't mind.</p>

<p>Edit: Just an after thought, should I use GCM or CBC encryption if I'm sending packets through the network? Remember I'm using randomly generated keys and I am not going to keep them for sessions, randomly generated per client and server session.</p>
"	NULL	3	NULL	58:46.2	0	08:13.4	51:21.1	NULL	9816000	9816000	0	1	1	<java><encryption><cryptography>	How to generate an AES key with AES/CBC/PKCS5Padding for encrypting and decrypting	2590	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
59913009	0	1	"<p>I am curious, why does calling <code>getBlockSize()</code> from the snippet below causes the program to throw exception? It works correctly if I use <code>key2</code>. </p>

<p>This snippet is just a test and security concerns is not the main topic. The main question is: why is calling that seemingly harmless method cause the program to throw exception? </p>

<p>I am specifically using that <code>jar</code> for the <code>RawBytes</code> keyspec. I have: </p>

<pre><code>openjdk version ""1.8.0_232""
OpenJDK Runtime Environment (build 1.8.0_232-8u232-b09-0ubuntu1~18.04.1-b09)
OpenJDK 64-Bit Server VM (build 25.232-b09, mixed mode)
</code></pre>

<p>Here is complete code:</p>

<pre><code>/*
javac -cp ./bcprov-jdk15on-1.62.jar why.java
java -cp ./bcprov-jdk15on-1.62.jar:. why
*/

import java.security.*;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

class why
{
    static
    {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static void main(String args[])
    {
        byte[] ciphertext = {};
        byte[] kbytes = new byte[16];
        SecureRandom rrr = new SecureRandom();
        rrr.nextBytes(kbytes);

        SecretKeySpec key1 = new SecretKeySpec(kbytes, ""RawBytes"");
        SecretKeySpec key2 = new SecretKeySpec(kbytes, ""AES"");

        try {
            byte[] plaintext = ""hello world"".getBytes(""UTF-8"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

            System.out.println(cipher.getBlockSize()); // &lt;---- ???

            cipher.init(
                Cipher.ENCRYPT_MODE, key1, new IvParameterSpec(new 
                byte[16]));
            ciphertext = cipher.doFinal(plaintext);

    } catch (UnsupportedEncodingException | NoSuchAlgorithmException
             | NoSuchPaddingException | InvalidKeyException
             | InvalidAlgorithmParameterException
             | IllegalBlockSizeException | BadPaddingException e) {

        e.printStackTrace();

        }
    }
}
</code></pre>

<p>Below is complete stack trace from the above code:</p>

<pre><code>java.security.InvalidKeyException: Wrong algorithm: AES or Rijndael 
required
    at com.sun.crypto.provider.AESCrypt.init(AESCrypt.java:83)
    at com.sun.crypto.provider.CipherBlockChaining.init(CipherBlockChaining.java:93)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:591)
    at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:346)
    at javax.crypto.Cipher.init(Cipher.java:1393)
    at javax.crypto.Cipher.init(Cipher.java:1326)
</code></pre>

<p>I was wanting to supply the output of <code>getBlockSize()</code> into the <code>byte[]</code> of <code>IvParameterSpec</code> to do away with the hard-coding of the numerical <code>16</code> as it appears in the code above. </p>

<p>The behavior is specific to BouncyCastle provider. </p>
"	NULL	10	NULL	11:46.1	1	47:07.8	03:25.4	NULL	2856202	2856202	0	1	-2	<java><cryptography>	Java Cipher.getBlockSize() throws exception	167	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
60104907	0	1	"<p>The initialization vector and salt are stored in with the encrypted data, so you will only need to supply a password. I need it to distribute my private code signing keys so I have access from whatever computer I'm working on to decrypt and sign any edits. The goal is to migrate to AES-256 but was having problems as described in the title. Here is the (FIXED) code:</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException; 
import java.security.InvalidKeyException; 
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException; 
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.io.IOUtils;
/**
 *
 * @author Tim
 */
public class CryptoTool {
    public static final String className = ""CryptoTool"";
    public static boolean debug = false;

    public CryptoTool() {
    }

    public byte[] encryptFile(String filename,char[] pass, byte[] salt, byte[] iv) {
        // generate key
        SecretKeySpec secretKeySpec = generateKeyFromPassword(pass,salt);
        // erase local password, don't worry, it's fast enough, (local to the function)
        for(int i = 0; i &lt; pass.length;i++) pass[i] = '\0'; // NULL character (end of string for C/C++)

        byte[] data = getBytesUTF8(filename);
        byte[] output = null;
        if (!new File(filename).exists()) {
            System.out.println(className + ""encryptFile: non-existent file: "" + filename);
            // if you don't have a file to operate on, I mean, C'mon, get it together
            return null;
        }
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, iv); 
        byte[] aadData = ""symService"".getBytes();
        try {
            Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, gcmParameterSpec, new SecureRandom());
            cipher.updateAAD(aadData);
            output = cipher.doFinal(data);
            byte[] encrypted = new byte[output.length + 20];
            System.arraycopy(salt  , 0, encrypted, 0 , 8);
            System.arraycopy(iv    , 0, encrypted, 8 , 12);
            System.arraycopy(output, 0, encrypted, 20,output.length);
            writeBytesTo(encrypted,filename + "".encrypted"");
            //System.out.println(""Encrypted To: "" + filename + "".encrypted"");
            new File(filename).delete();
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println(""No Such Algorithm: "" + nsae);
        } catch (InvalidKeyException ike) {
            System.out.println(""Invalid Key: "" + ike);
        } catch (InvalidAlgorithmParameterException iape) {
            System.out.println(""InvalidAlgorithmParameterException: "" + iape);
        } catch (NoSuchPaddingException nspe) {
            System.out.println(""NoSuchPaddingException: "" + nspe);
        } catch (IllegalBlockSizeException ibse) {
            System.out.println(""IllegalBlockSizeException: "" + ibse);
        } catch (BadPaddingException bpe) {
            System.out.println(""BadPaddingException: "" + bpe);
        }
        return iv;
    }    

    public boolean decryptFile(char[] pass,String outPath) {
        // must pass a valid file, note that outPath should end in "".encrypted""
        if (outPath == null || !new File(outPath + "".encrypted"").exists()) return false;

        // get the contents of the file
        byte[] input = getBytesUTF8(outPath + "".encrypted"");

        // from the contents, get the salt and generate the key, so we can erase the password
        byte[] salt = new byte[8];
        System.arraycopy(input,0,salt,0,8);
        if (debug) {
            for(int i = 0; i &lt; salt.length;i++) System.out.print((char)salt[i]);
            System.out.println();
        }

        // generate the key
        SecretKeySpec secretKeySpec = generateKeyFromPassword(pass,salt);
        for(int i = 0; i &lt; pass.length;i++) pass[i] = '\0';

        // get the initalization vector
        byte[] iv = new byte[12];
        System.arraycopy(input, 8, iv, 0, 12);
        if (debug) {
            for(int i = 0; i &lt; salt.length;i++) System.out.print((char)salt[i]);
            System.out.println();
        }

        // copy the encrypted data to a byte array
        byte[] encrypted = new byte[input.length - 20];
        System.arraycopy(input, 20, encrypted, 0, input.length - 20);

        // get the authenticated additional data (the tag we're having trouble with)
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, iv); 
        byte[] aadData = ""symService"".getBytes();

        // decrypt
        byte[] decrypted = null;
        try {
            Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, gcmParameterSpec, new SecureRandom());
            cipher.updateAAD(aadData);
            decrypted = cipher.doFinal(encrypted);
            // save the decrypted file to its' original filename (removes the .encrypted from the filename)
            writeBytesTo(decrypted,outPath);
            // delete the encrypted file 
            new File(outPath + "".encrypted"").delete();
            // if we made it this far, nothing failed, so return true; decryption successful
            return true;
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println(""No Such Algorithm: "" + nsae);
        } catch (InvalidKeyException ike) {
            System.out.println(""Invalid Key: "" + ike);
        } catch (InvalidAlgorithmParameterException iape) {
            System.out.println(""InvalidAlgorithmParameterException: "" + iape);
        } catch (NoSuchPaddingException nspe) {
            System.out.println(""NoSuchPaddingException: "" + nspe);
        } catch (IllegalBlockSizeException ibse) {
            System.out.println(""IllegalBlockSizeException: "" + ibse);
        } catch (BadPaddingException bpe) {
            System.out.println(""BadPaddingException: "" + bpe);
            bpe.printStackTrace();
        }
        // otherwise, something went wrong, return failure code
        return false;
    }

    public static void main(String[] args) { 
/*      The purpose of this test is to encrypt and decrypt a keystore file so we
        may distribute our keys, without fear of someone hacking the data and
        signing code we don't authorize.
        If it works, we can distribute our keys and have immediate access to them
        without fear that anyone else can gain access to them. This allows us to 
        deploy from any machine attached to the Internet.
*/

        // toggle 'test' in order to test both encryption and decryption, or separately.
        boolean test =  true;

        CryptoTool tool = new CryptoTool();
        char[] pass = new RequestPassword().getPassword();
        SecureRandom sr = new SecureRandom();
        byte[] salt = new byte[8];
        sr.nextBytes(salt);
        byte[] iv = new byte[12];
        // maybe we could skip this next line, so delete that and just use one instance of SecureRandom???
        sr = new SecureRandom();
        sr.nextBytes(iv);
        if (debug) {
            for(int i = 0; i &lt; salt.length;i++) System.out.print((char)salt[i]);
            System.out.println();
            for(int i = 0; i &lt; iv.length;i++) System.out.print((char)iv[i]);
            System.out.println();
        }
        String plainFile = ""c:\\java\\keystore_private"";

        // if test is true, encrypt also, otherwise, just decrypt (in this case,
        // salt and IV should be generated, else, get them from the encrypted file.
        if (test) {
            tool.encryptFile(plainFile, pass, salt, iv);
        }
        if (new File(plainFile + "".encrypted"").exists()) 
            System.out.println(""Encrypted To: "" + plainFile + "".encrypted"");
        pass = new RequestPassword().getPassword();
        if (tool.decryptFile(pass,plainFile)) {
            System.out.println(""Decrypted To: "" + plainFile);
        } else {
            System.out.println(""Couldn't Decrypt"");
        }
        // does erasing in a function(method) also erase original? Local to method call.
        if (debug) {
            System.out.print(""Pass: '"");
            for(int i = 0; i &lt; pass.length;i++) System.out.print(pass[i]);
            System.out.println(""'"");
        }
        System.exit(0);
    } 

    public byte[] getBytesUTF8(String filename) {
        FileInputStream in = null;
        try {
            in = new FileInputStream(filename);
        } catch (FileNotFoundException fnfe) {
            // So using this package, that shouldn't happend, but anyway
            System.out.println(className + "".getBytesUTF8: File not found: "" + filename);
        }
        // okay, so load the class
        byte[] data = null;
        try { 
            data = IOUtils.toByteArray(in);
        } catch (IOException ioe) {
            System.err.println(""IOException: reading class data."");
        }
        try {
            in.close();
        } catch (IOException ioe) {
            System.out.println(""Unable to close: "" + filename);
        }
        return data;

    }

    public void writeBytesTo(byte[] data, String filename) {
        FileOutputStream output = null;
        try {
            output = new FileOutputStream(new File(filename));
        } catch (FileNotFoundException fnfe) {
            System.err.println(""Couldn't create: "" + filename);
        }
        try {
            IOUtils.write(data, output);
            //System.out.println(""Wrote file: "" + filename);
        } catch (IOException ioe) {
            System.err.println(""Couldn't write data to: "" + filename);
        }
        try {
            output.close();
        } catch (IOException ioe) {
            System.out.println(""Couldn't close: "" + filename);
        }
    }

    public SecretKeySpec generateKeyFromPassword(char[] password, byte[] salt) {
        /* Derive the key, given password and salt. */
        SecretKeyFactory factory = null;
        try {
            factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println(""No Such Algorithm: "" + nsae);
        }
        KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
        SecretKey tmp = null;
        try { 
            tmp = factory.generateSecret(spec);
        } catch (InvalidKeySpecException ikse) {
            System.out.println(""Inavalid Key Spec Exception: "" + ikse);        
        }
        SecretKeySpec keySpec = new SecretKeySpec(tmp.getEncoded(), ""AES"");        
        return keySpec;
    }
}
</code></pre>
"	NULL	3	NULL	10:15.5	0	41:09.8	41:09.8	NULL	6888983	6888983	0	1	0	<java><security><google-cloud-messaging><aes>	SOLVED: AEADBadTagException. I've tried multiple ways and now store both salt and initialization vector within the encrypted file	144	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
60118474	60118857	1	"<p>I implemented a straight simple Java utility class to encrypt and decrypt using AES/GCM/NoPadding. I use this piece of code:</p>

<pre><code>public byte[] encrypt(byte[] input, byte[] key, byte[] iv) throws Exception{
        Cipher cipher = initAES256GCMCipher(key, iv, Cipher.ENCRYPT_MODE);
        return cipher.doFinal(input);
}

public byte[] decrypt(byte[] input, byte[] key, byte[] iv) throws Exception{
        Cipher cipher = initAES256GCMCipher(key, iv, Cipher.DECRYPT_MODE);
        return cipher.doFinal(input);
}

private Cipher initAES256GCMCipher(byte[] key, byte[] iv, int encryptionMode) throws Exception{
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, iv);

        SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
        cipher.init(encryptionMode, secretKey, gcmParameterSpec);
        return cipher;
}
</code></pre>

<p>IV is always a 12-byte array, key is 32-byte array <strong>generated with SecureRandom taking a seed</strong>. I knowthat on different OS SecureRandom is different, but encryption and decryption are performed on the same OS, so there should be no problem.</p>

<p>Is it quite linear, right? It works perfectly on Windows, ciphering and deciphering return the same text. However, on a Docker image, the same JAR doesn not work: encryption works fine, but decryption throws ""AEADBadTagException"".</p>

<p>Can you help me, please?</p>
"	NULL	0	NULL	38:20.8	0	30:06.1	NULL	NULL	0	5112735	0	1	1	<java><docker><encryption>	Java Crypto AES/GCM/NoPadding works on Windows but not on Docker (AEADBadTagException)	759	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
60819870	60820482	1	"<p>So I am trying to make a web socket which sends data that will be encoded to base64 and then encrypted with AES, the resulting byte array will be sent over a stream between sockets and the server. This works fine up until I am trying to make a certain command which gives me the <code>BadPaddingException</code>. All the pieces of code which are using the <code>Cryptographer</code> class use the exact same class with the same secret.</p>

<p>The websockets has threads for each connection to read and write data. All these threads use the same cyptographer.</p>

<p>The function which is giving me the exception when the result is being decrypted in the connection's thread is written like this within a class called <code>MessageSender</code>, <strong>The Exception will occur when decrypting the result of sendFile()</strong>:</p>

<pre><code>package com.company.client.workers;

import com.company.security.Cryptographer;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.Base64;

public class MessageSender {
    private PrintWriter writer;
    private OutputStream outputStream;
    private Cryptographer cryptographer;

    public MessageSender(OutputStream outputStream) {
        this.outputStream = outputStream;
        this.writer = new PrintWriter(this.outputStream);
        cryptographer = new Cryptographer();
    }

    /**
     * Sends a message to the PrintWriter.
     * @param message to send.
     */
    public void send(String message) {
        try {
            String b64 = Base64.getEncoder().encodeToString(message.getBytes());
            byte[] bytes = cryptographer.getData(b64.getBytes(), 0);
            outputStream.write(bytes, 0, bytes.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Send a file over the server.
     * @param receiver to send to
     * @param path location of file
     */
    public void sendFile(String receiver, String path) {
        File file = new File(path);
        try {
            byte[] bytes = Files.readAllBytes(file.toPath());
            // The encrypted result of this will throw the exception once the server tries to decrypt it.
            String message = ""SFC "" + receiver + "" "" + bytes.length + "" "" + getFileName(path);
            send(message);
            outputStream.write(cryptographer.getData(bytes, 0), 0, bytes.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private String getFileName(String path) {
        String[] parts = path.split(""/"");
        return parts[parts.length-1];
    }
}
</code></pre>

<p>The following run function will read data from an inputstream(this is the socket). And it will also call the cryptographer class to encrypt and decrypt data, this is the same class which also will be used in the client side with a separate instance. In the case of this exception <code>IsReceiving</code> is still set to <code>false</code>. Here is the <code>Cryptographer</code> class:</p>

<pre><code>package com.company.security;

import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Cryptographer {
private Key secretKey;

public Cryptographer() {
    byte[] secret = new byte[16]; // 128 bit is 16 bytes, and AES accepts 16 bytes, and a few others.
    byte[] secretBytes = ""secret"".getBytes();
    System.arraycopy(secretBytes, 0, secret, 0, secretBytes.length);
    secretKey = new SecretKeySpec(secret, ""AES"");
}

/**
 * Get data from either encryption and decryption.
 * @param data to encrypt or decrypt
 * @param mode 0 to encrypt en other numbers to decrypt
 * @return result data as byte array format.
 */
public byte[] getData(byte[] data, int mode) {
    Cipher c;

    try {
        c = Cipher.getInstance(""AES"");
    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
        e.printStackTrace();
        return null;
    }

    try {
        if(mode == 0) { // 0 is encrypt mode.
            c.init(Cipher.ENCRYPT_MODE, secretKey);
        } else { // other numbers are decrypt mode.
            c.init(Cipher.DECRYPT_MODE, secretKey);
        }
    } catch (InvalidKeyException e) {
        e.printStackTrace();
        return null;
    }

    try {
        return c.doFinal(data);
    } catch (IllegalBlockSizeException | BadPaddingException e) {
        e.printStackTrace();
        return null;
    }
}

/**
 * Decode base64 byte array.
 * @param encoded encoded byte array
 * @return decoded string
 */
public String decodeBaseToString(byte[] encoded) {
    return new String(Base64.getDecoder().decode(encoded));
}

/**
 * Decode base64 byte array.
 * @param encoded encoded byte array
 * @return decoded byte array
 */
public byte[] decodeBaseToBytes(byte[] encoded) {
    return Base64.getDecoder().decode(encoded);
}

/**
 * Encode byte array to base64.
 * @param source array to encode
 * @return encoded base64 byte array
 */
public byte[] encodeBase(byte[] source) {
    return Base64.getEncoder().encode(source);
}
</code></pre>

<p>}</p>

<p>The exception stacktrace:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
    at java.base/com.sun.crypto.provider.CipherCore.unpad(CipherCore.java:975)
    at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1056)
    at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
    at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2208)
    at com.company.security.Cryptographer.getData(Cryptographer.java:48)
    at com.company.client.Reader.run(Reader.java:45)
    at java.base/java.lang.Thread.run(Thread.java:835)
Exception in thread ""Thread-3"" java.lang.NullPointerException
    at java.base/java.lang.String.&lt;init&gt;(String.java:623)
    at com.company.client.Reader.run(Reader.java:47)
    at java.base/java.lang.Thread.run(Thread.java:835)
</code></pre>

<p>The encryption works fine with every other command and it also works when I don't include the file name in <code>sendFile()</code>. What am I doing wrong here?</p>
"	NULL	0	NULL	52:42.9	0	38:26.5	49:57.6	NULL	3657460	6003092	0	1	1	<java><encryption><aes>	AES BadPaddingException when decrypting	210	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
60945525	60948235	2	"<p>I have a JAVA code that does the AES encryption of excel file on the Windows Operating System. I want to decrypt the same file on the MacOs Operating System using NodeJS. I've written a decrypt function in NodeJs which is giving me the following error</p>

<p><code>error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt</code></p>

<p>Here is the JAVA Code</p>

<pre><code>import java.security.Key;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class fileEncrypter {
   try {
     final SecretKeySpec key = new SecretKeySpec(""1234"".getBytes(), ""AES"");
     final Cipher instance = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
     final BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(name));
     final BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(name2));
     instance.init(1, key);
     final byte[] b = new byte[4096];
     for (int i = bufferedInputStream.read(b); i &gt; -1; i = bufferedInputStream.read(b)) {
        final byte[] update = instance.update(b, 0, I);
        bufferedOutputStream.write(update, 0, update.length);
     }
     bufferedInputStream.close();
     final byte[] doFinal = instance.doFinal();
     bufferedOutputStream.write(doFinal, 0, doFinal.length);
     bufferedOutputStream.flush();
     bufferedOutputStream.close();
     return ""success"";
   } catch(Exception obj) {
     System.err.println(""Exception occured while encryption:"" + obj);
     obj.printStackTrace();
     return obj.toString();
   }
}
</code></pre>

<p>Here is the NodeJs code to decrypt</p>

<pre><code>function Decrypt_AES() {

const ALGORITHM = 'aes-128-ecb';
const ENCRYPTION_KEY = ""1234"";

var decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
decipher.setAutoPadding(true);
var input = fs.createReadStream('test.enc');
var output = fs.createWriteStream('test_copy.xls');

input.pipe(decipher).pipe(output);

output.on('finish', function () {
    console.log('Encrypted file written to disk!');
});
output.on('error', function (e) {
    console.log(e);
});
</code></pre>

<p>}</p>
"	NULL	1	NULL	38:34.5	0	06:57.6	NULL	NULL	0	6289362	0	1	2	<java><node.js><encryption>	AES Decrypt a file in NodeJs	3049	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
61183401	61358246	1	"<p>I'm using Encryption and Decryption with KeyStore like this. </p>

<p>This is the flow. After i pass a string to encrypt method i save both encrypted and iv so i can retrive value with it later.Problem is some times, some encrypted values can not retrive correctly... not all of them! So think i encrypted 10 items and save them in some where( both encrypted and iv). Then when i wanna retrive one of them can not retrive correcly!</p>

<pre><code> init {
        keyStore = KeyStore.getInstance(ANDROID_KEY_STORE)
        keyStore.load(null)
        cipher = Cipher.getInstance(""AES/GCM/NoPadding"")
    }

  fun encryptData(text: String): Pair&lt;ByteArray, String&gt;? {
        try {
            cipher.init(Cipher.ENCRYPT_MODE, getSecretKet(ALIAS))
            val iv = cipher.iv.toString(Charsets.ISO_8859_1)
            val result = cipher.doFinal(text.toByteArray(Charsets.ISO_8859_1))
            Timber.i(""$TAG encrypted data $result"")
            Timber.i(""$TAG encrypted iv $iv"")
            return if (result != null) {
                Pair(result, iv)
            } else {
                null
            }
        } catch (e: Exception) {
            Timber.e(""$TAG error encryptData"", e)
            return null
        }
    }

fun decryptData(encryptedData: ByteArray, iv: ByteArray): String {
    return try {
        val spec = GCMParameterSpec(128, iv)
        cipher.init(Cipher.DECRYPT_MODE, getSecretKet(ALIAS), spec)
        val result = cipher.doFinal(encryptedData).toString(Charsets.ISO_8859_1)
        Timber.i(""$TAG decrypted data $result"")
        result
    } catch (e: Exception) {
        Timber.e(""$TAG decryptData error may string was not encrypted"", e)
        encryptedData.toString()
    }
}
</code></pre>

<p>And this is for get secret key. First i thougth may be problem is with my key, so I implemented it in this way and this class is singletone. But thing is some time when i re-open application some how this key is not same ( I think, because iv and encrypted value and also cipher are fixed). I also use <strong>Charsets.ISO_8859_1</strong> caue find that this charset is better to keep all characters and lose less.
Then I thought may be proble is with saving place so for test i just move from Room db with sstring field to SharePref with string. But the issue is same so now i'm prettry sure it is not about savig repository.</p>

<pre><code>private fun getSecretKet(alias: String): Key {

    if (keyStore.containsAlias(alias)) {
        //Try for existing key
        return keyStore.getKey(alias, null)
    } else {
        //Key is not present, create new one.
        val keyGenerator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
            val kGenerator =
                KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE)
            val specs = KeyGenParameterSpec
                .Builder(
                    alias,
                    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
                )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .build()
            kGenerator.init(specs)
            kGenerator
        } else {
            KeyGenerator.getInstance(ANDROID_KEY_STORE);
        }
        return keyGenerator.generateKey()
    }
}
</code></pre>

<p>I think this sould works as well as works mostly but eventually i can not get some of my encrypted data as I mentioned above. Any body have any idea?</p>
"	NULL	7	NULL	38:09.9	0	01:44.2	49:28.1	NULL	1498586	1498586	0	1	0	<android><kotlin><encryption><keystore>	"Encryption and Decryption with KeyStore private key and iv goes wrong ""Some times"""	1216	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
61506526	0	1	"<p>I have Java code sitting on a server for decrypting data that I am trying to run locally for some testing. The code runs fine on the server but throws an error in my local build.  </p>

<blockquote>
  <p>ECB mode cannot use IV</p>
</blockquote>

<pre><code>    public static String triple_des_decrypt(String key, String data)
    {
        try
        {
            //needs to have an even number of digits
            if (key.length() % 2 == 1)
            {
                key = ""0"" + key;
            }
            byte[] desKey = Hex.decodeHex(key.toCharArray());

            // pad out key for cipher routine
            int deskeyLength = desKey.length;
            byte[] desKey24 = new byte[24];

            int copySize = 16;
            if (copySize &gt; deskeyLength)
            {
                copySize = deskeyLength;
            }
            System.arraycopy(desKey, 0, desKey24, 0, copySize);

            copySize = 8;
            if (copySize &gt; deskeyLength)
            {
                copySize = deskeyLength;
            }
            System.arraycopy(desKey, 0, desKey24, 16, 8);

            DESedeKeySpec keySpec = new DESedeKeySpec(desKey24);
            Cipher cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
            String algo = ""DESede"";


            SecretKey secretKey = SecretKeyFactory.getInstance(algo).generateSecret(keySpec); 
            IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, iv); //Error thrown here
            byte[] byteData = Hex.decodeHex(data.toCharArray());
            byte[] decryptedData = cipher.doFinal(byteData);

            char tempString[] = Hex.encodeHex(decryptedData);
            String decryptedString = new String(tempString).toUpperCase();
            return decryptedString;
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }
    }
</code></pre>

<p>I'm not familiar with encryption and I'm at a loss as to why this error is thrown.</p>

<p><strong>Edit</strong> Removing the IV parameter from <code>cipher.init</code> fixes the issue, but I'm still curious as to why no error is thrown in a different environment.</p>
"	NULL	2	NULL	17:49.2	0	54:59.2	29:59.8	NULL	5407608	5407608	0	1	0	<java><encryption>	Triple DES Decrypting: ECB mode cannot use IV	1629	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
61645801	61658490	1	"<p>Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size for below code</p>

<p>Char length of the key is 44. I tried with char length 24 am able to encrypt. Please help how to resolve this issue.</p>

<pre><code>
public static void main(String args[]) throws Exception {
    String plainText = ""Hello world!"";
    String encryptionKeyBase64 = ""DWIzFkO22qfVMgx2fIsxOXnwz10pRuZfFJBvf4RS3eY="";
    System.out.println(encryptionKeyBase64.length());
    String ivBase64 = ""AcynMwikMkW4c7+mHtwtfw=="";
    EncDec encDec = new EncDec();
    String cipherText = encDec.encrypt(plainText, encryptionKeyBase64, ivBase64);
}

 public String encrypt(String plainText, String keyBase64, String ivBase64) throws Exception
    {
        byte[] plainTextArray = plainText.getBytes(StandardCharsets.UTF_8);
        byte[] keyArray = DatatypeConverter.parseBase64Binary(keyBase64);
        byte[] iv = DatatypeConverter.parseBase64Binary(ivBase64);

        SecretKeySpec secretKey = new SecretKeySpec(keyArray, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");   
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));
        return new String(DatatypeConverter.printBase64Binary(cipher.doFinal(plainTextArray)));
    }

    public String decrypt(String messageBase64, String keyBase64, String ivBase64) throws Exception {

        byte[] messageArray = DatatypeConverter.parseBase64Binary(messageBase64);
        byte[] keyArray = DatatypeConverter.parseBase64Binary(keyBase64);
        byte[] iv = DatatypeConverter.parseBase64Binary(ivBase64);

        SecretKey secretKey = new SecretKeySpec(keyArray, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        return new String(cipher.doFinal(messageArray));
    }
}```

</code></pre>
"	NULL	0	NULL	33:35.3	0	46:37.6	NULL	NULL	0	5895767	0	1	0	<java>	"Exception in thread ""main"" java.security.InvalidKeyException: Illegal key size. char length of key is 44"	110	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
61792534	61808354	2	"<p>I was trying to implement an encrypt/decrypt program using classes under javax.crypto and file streams for input/output.
To limit the memory usage, I run with <strong>-Xmx256m</strong> parameter.</p>

<p>It works fine with encryption and decryption with smaller files.
But when decrypt a huge file (1G in size), there is an out of memory exception:</p>

<pre><code>java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:3236)
    at java.io.ByteArrayOutputStream.grow(ByteArrayOutputStream.java:118)
    at java.io.ByteArrayOutputStream.ensureCapacity(ByteArrayOutputStream.java:93)
    at java.io.ByteArrayOutputStream.write(ByteArrayOutputStream.java:153)
    at com.sun.crypto.provider.GaloisCounterMode.decrypt(GaloisCounterMode.java:505)
    at com.sun.crypto.provider.CipherCore.update(CipherCore.java:782)
    at com.sun.crypto.provider.CipherCore.update(CipherCore.java:667)
    at com.sun.crypto.provider.AESCipher.engineUpdate(AESCipher.java:380)
    at javax.crypto.Cipher.update(Cipher.java:1831)
    at javax.crypto.CipherOutputStream.write(CipherOutputStream.java:166)
</code></pre>

<p>Here is the decrypt code:</p>

<pre><code>private final int _readSize = 0x10000;//64k

...

GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(gcmTagSize, iv);
Key keySpec = new SecretKeySpec(key, keyParts[0]);
Cipher decCipher = Cipher.getInstance(""AES/GCM/PKCS5Padding"");

decCipher.init(Cipher.DECRYPT_MODE, keySpec, gcmParameterSpec);

try (InputStream fileInStream = Files.newInputStream(inputEncryptedFile);
    OutputStream fileOutStream = Files.newOutputStream(outputDecryptedFile)) {
    try (CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutStream, decCipher)) {
        long count = 0L;
        byte[] buffer = new byte[_readSize];

        int n;
        for (; (n = fileInStream.read(buffer)) != -1; count += (long) n) {
            cipherOutputStream.write(buffer, 0, n);
        }
    }
}
</code></pre>

<p>The key parameters like gcmTagSize and iv are read from a key file, and it works fine with smaller files, like some one around size of 50M.</p>

<p>As I understand, every time there are only 64k data passed to decipher, why it runs out of heap memory?
How can I avoid this?</p>

<p><strong>Edit:</strong></p>

<p>Actually I have tried with 4k as buffer size, failed with same exception.</p>

<p><strong>Edit 2:</strong></p>

<p>With more testing, the max file size it can handle is around 1/4 of the heap size. Like, if you set <strong>-Xmx256m</strong>, files bigger than <strong>64M</strong> will fail to decrypt.</p>
"	NULL	2	NULL	19:22.1	1	16:19.4	16:19.4	NULL	5459839	13496292	0	1	3	<java><exception><encryption><out-of-memory><heap-memory>	Out of memory exception when decrypt large file using Cipher	1038	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
61987839	0	0	"<p>I'm trying to rewrite the following implementation of AES-256-GCM encryption from NodeJS to Java.</p>

<p><a href=""https://i.stack.imgur.com/Bbep9.png"" rel=""nofollow noreferrer"">Packet description</a></p>

<p>Im getting a different output, specifically the auth tag part. From the looks of it, the Java libs dont have any methods to fetch the auth tag, and my attempt to substring it from the output fails. Also, I'm not actually sure that the first AES encryption with the public key (generating a random buffer for GCM) works the same as the NodeJS counterpart.
Can anyone point me in the right direction?</p>

<p>NodeJS: </p>

<pre><code>public encryptPassword(password: string, encryptionKey: string, encryptionKeyId: string): { time: string, encrypted: string } {
    const randKey = crypto.randomBytes(32);
    const iv = crypto.randomBytes(12);
    const rsaEncrypted = crypto.publicEncrypt({
      key: Buffer.from(encryptionKey, 'base64').toString(),
      // @ts-ignore
      padding: crypto.constants.RSA_PKCS1_PADDING,
    }, randKey);
    const cipher = crypto.createCipheriv('aes-256-gcm', randKey, iv);
    const time = Math.floor(Date.now() / 1000).toString();
    cipher.setAAD(Buffer.from(time));
    const aesEncrypted = Buffer.concat([cipher.update(password, 'utf8'), cipher.final()]);
    const sizeBuffer = Buffer.alloc(2, 0);
    sizeBuffer.writeInt16LE(rsaEncrypted.byteLength, 0);
    const authTag = cipher.getAuthTag();
    return {
      time,
      encrypted: Buffer.concat([
        Buffer.from([1, encryptionKeyId]),
        iv,
        sizeBuffer,
        rsaEncrypted, authTag, aesEncrypted])
        .toString('base64'),
    };
  }
</code></pre>

<p>Java:</p>

<pre><code> private static Pair&lt;Long, String&gt; encryptPaswword(String password, String encryptionPubKey, String encryptionKeyId) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidCipherTextException, InvalidAlgorithmParameterException {
    byte[] passwordAsByte = password.getBytes();
    String decoededPubKey = new String(Base64.decode(encryptionPubKey, Base64.NO_WRAP), StandardCharsets.UTF_8);
    decoededPubKey = decoededPubKey.replace(""-----BEGIN PUBLIC KEY-----"", """");
    decoededPubKey = decoededPubKey.replace(""-----END PUBLIC KEY-----"", """");

    SecureRandom random = new SecureRandom();
    byte[] randKey = new byte[32];
    random.nextBytes(randKey);
    byte[] iv = new byte[12];
    random.nextBytes(iv);
    long date = new Date().getTime() / 1000;

    ByteBuffer header = ByteBuffer.allocate(2);
    header.put(Integer.valueOf(1).byteValue());
    header.put(Integer.valueOf(Integer.parseInt(encryptionKeyId)).byteValue());
    ByteBuffer timeAAD = ByteBuffer.allocate(10);
    timeAAD.put(String.valueOf(date).getBytes());

    X509EncodedKeySpec publicSpec = new X509EncodedKeySpec(Base64.decode(decoededPubKey, Base64.NO_WRAP));
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PublicKey publicKey = keyFactory.generatePublic(publicSpec);
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
    rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte[] rsaEncrypted = rsaCipher.doFinal(randKey);

    ByteBuffer sizeBuff = ByteBuffer.allocate(2);
    sizeBuff.put(Integer.valueOf(rsaEncrypted.length).byteValue());

    final Cipher gcmCipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    GCMParameterSpec parameterSpec = new GCMParameterSpec(16 * Byte.SIZE, iv);
    gcmCipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(randKey, ""AES""), parameterSpec);
    gcmCipher.updateAAD(timeAAD);
    byte[] gcmText= gcmCipher.doFinal(passwordAsByte);

    ByteBuffer result = ByteBuffer.allocate(2+12+2+256+gcmText.length);
    result.put(header);
    result.put(iv);
    result.put(sizeBuff);
    result.put(rsaEncrypted);
    result.put(Arrays.copyOfRange(gcmText, gcmText.length - (16 / Byte.SIZE), gcmText.length));
    result.put(Arrays.copyOfRange(gcmText, 0, gcmText.length - (16 / Byte.SIZE)));

    return new Pair(new Long(date), Base64.encodeToString(result.array(), Base64.NO_WRAP));
</code></pre>
"	NULL	3	NULL	01:56.0	2	01:56.0	NULL	NULL	0	13608101	0	1	0	<java><encryption><aes><cryptojs><aes-gcm>	AES 256 GCM Java Implementation	1495	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62001716	62005258	1	"<p>I'm trying to reproduce the LibreOffice encryption of a file inside an ODS (open document spreadsheet) archive. See <a href=""http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part3.html#__RefHeading__752811_826425813"" rel=""nofollow noreferrer"">http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part3.html#__RefHeading__752811_826425813</a> for technical information.</p>
<p>The best summary I found is in <a href=""https://en.wikipedia.org/wiki/OpenDocument_technical_specification#Encryption"" rel=""nofollow noreferrer"">wikipedia</a>:</p>
<blockquote>
<p>When OpenDocument file is password protected the file structure of the bundle remains the same, but contents of XML files in the package are encrypted using following algorithm:</p>
<ol>
<li>The file contents are compressed with the DEFLATE algorithm.</li>
<li>A checksum of a portion of the compressed file is computed (SHA-1 of the file contents, or SHA-1 of the first 1024 bytes of the file, or SHA-256 of the first 1024 bytes of the file) and stored so password correctness can be verified when decrypting.</li>
<li>A digest (hash) of the user entered password in UTF-8 encoding is created and passed to the package component. ODF versions 1.0 and 1.1 only mandate support for the SHA-1 digest here, while version 1.2 recommends SHA-256.</li>
<li>This digest is used to produce a derived key by undergoing key stretching with PBKDF2 using HMAC-SHA-1 with a salt of arbitrary length (in ODF 1.2  it's 16 bytes in ODF 1.1 and below) generated by the random number generator for an arbitrary iteration count (1024 by default in ODF 1.2).</li>
<li>The random number generator is used to generate a random initialization vector for each file.</li>
<li>The initialization vector and derived key are used to encrypt the compressed file contents. ODF 1.0 and 1.1 use Blowfish in 8-bit cipher feedback mode, while ODF 1.2 considers it a legacy algorithm and allows Triple DES and AES (with 128, 196 or 256 bits), both in cipher block chaining mode, to be used instead.</li>
</ol>
</blockquote>
<p>My un-encrypted module content (encoding: utf-8, line break: LF) is:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE script:module PUBLIC &quot;-//OpenOffice.org//DTD OfficeDocument 1.0//EN&quot; &quot;module.dtd&quot;&gt;
&lt;script:module xmlns:script=&quot;http://openoffice.org/2000/script&quot; script:name=&quot;Module1&quot; script:language=&quot;StarBasic&quot; script:moduleType=&quot;normal&quot;&gt;REM  *****  BASIC  *****
REM Hello, world!
&lt;/script:module&gt;
</code></pre>
<p>The encrypted module content produced by LibreOffice and stored in the ODS archive, is (in hexadecimal):</p>
<pre><code>[a3, f4, 61, 98, c1, c8, e8, b1, d3, fa, b0, bc, ef, 51, 87, da, 4c, d8, 92, c2, 09, 7f, 12, 19, 47, 44, af, 3b, 32, 9d, 4a, 33, eb, ab, c0, 45, 97, 00, 27, 60, cf, b3, 49, 55, 76, 46, e2, 3c, 35, a0, a7, a9, 8a, af, a3, cd, 3c, f3, 20, 5f, 83, 89, a4, 9c, d9, b5, a6, f5, db, 68, 0a, b4, d0, 15, 3e, 6d, af, c6, 16, 78, 29, 79, 42, cb, 56, e3, b1, cd, c1, a6, a0, 13, 91, 16, e3, 89, a8, c6, d4, 69, e8, ea, 87, e9, 9d, 09, bb, 03, a0, 6e, a0, 29, 37, 85, 9a, 59, fb, 47, 3a, 72, 1d, 85, 25, b0, 92, 37, 55, a4, eb, de, 03, eb, de, e1, b6, f3, f9, 7b, 3a, 09, 2c, ad, 8e, ff, 1e, a2, 79, 63, 12, 04, 93, 67, 3d, 59, 6c, e8, aa, ae, 37, 7e, 66, cf, 99, 54, 63, a5, ea, 31, 78, 44, b1, 54, be, 5a, af, 3f, 0d, bf, b5, ce, 98, c8, 7a, 44, 61, d4, 76, 69, 3b, 01, 6f, 27, ab, 5f, a2, b0, 98, 32, 52, 0c, 9c, 08, 0c, 6a, 0c, 54, e0, 83, dc, d0, ad, 3a, 0f, 0f, 75, 6f, e6, 0d, db, db, 50, a4, 2b, d3, 5f, 43, 7c, 2d, 16, fa, 87, 62, 09, f6, d2, 28, 31, b5, a0, be]
</code></pre>
<p>And here's the relevant part of the manifest produced by LibreOffice:</p>
<pre><code>    &lt;manifest:file-entry manifest:full-path=&quot;Basic/Test/Module1.xml&quot; manifest:media-type=&quot;text/xml&quot; manifest:size=&quot;332&quot;&gt;
     &lt;manifest:encryption-data manifest:checksum-type=&quot;urn:oasis:names:tc:opendocument:xmlns:manifest:1.0#sha256-1k&quot; manifest:checksum=&quot;/UdU2OKZn04r0e9O047PaWNqi7LGaHYN9mURmvMCM60=&quot;&gt;
      &lt;manifest:algorithm manifest:algorithm-name=&quot;http://www.w3.org/2001/04/xmlenc#aes256-cbc&quot; manifest:initialisation-vector=&quot;ZEk8JHG3bHu8kZw0VGOT+g==&quot;/&gt;
      &lt;manifest:key-derivation manifest:key-derivation-name=&quot;PBKDF2&quot; manifest:key-size=&quot;32&quot; manifest:iteration-count=&quot;100000&quot; manifest:salt=&quot;jGIagiBnlFdvQctdCkYfRQ==&quot;/&gt;
      &lt;manifest:start-key-generation manifest:start-key-generation-name=&quot;http://www.w3.org/2000/09/xmldsig#sha256&quot; manifest:key-size=&quot;32&quot;/&gt;
     &lt;/manifest:encryption-data&gt;
    &lt;/manifest:file-entry&gt;
</code></pre>
<p>The password was <code>123</code>.</p>
<hr />
<p>Here's my code:</p>
<pre><code>// imports
// needs a dependency on `org.bouncycastle/bcprov-jdk15on/1.65`

public class EncryptMacro {
    public static void main(String[] args)
            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException,
            IllegalBlockSizeException, InvalidKeyException, BadPaddingException,
            InvalidAlgorithmParameterException, NoSuchPaddingException {
        new EncryptMacro().encryptAsLO();
    }

    public void encryptAsLO() throws IOException, NoSuchAlgorithmException,
            InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        // needs a dependency on `org.bouncycastle/bcprov-jdk15on/1.65`
        Security.addProvider(new BouncyCastleProvider());

        // copy the manifest parameters
        int plainSize = 332;
        byte[] checksum = Base64.decode(&quot;/UdU2OKZn04r0e9O047PaWNqi7LGaHYN9mURmvMCM60=&quot;);
        byte[] iv = Base64.decode(&quot;ZEk8JHG3bHu8kZw0VGOT+g==&quot;);
        int iterationCount = 100000;
        byte[] salt = Base64.decode(&quot;jGIagiBnlFdvQctdCkYfRQ==&quot;);
        int startKeySize = 32;
        int keySize = 32;

        // password
        String password = &quot;123&quot;; // that's for testing purpose!

        String plainText =
                &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&lt;!DOCTYPE script:module PUBLIC \&quot;-//OpenOffice.org//DTD OfficeDocument 1.0//EN\&quot; \&quot;module.dtd\&quot;&gt;\n&lt;script:module xmlns:script=\&quot;http://openoffice.org/2000/script\&quot; script:name=\&quot;Module1\&quot; script:language=\&quot;StarBasic\&quot; script:moduleType=\&quot;normal\&quot;&gt;REM  *****  BASIC  *****\nREM Hello, world!\n&lt;/script:module&gt;&quot;;
        byte[] encrypted =
                new byte[]{-93, -12, 97, -104, -63, -56, -24, -79, -45, -6, -80, -68, -17, 81, -121,
                        -38, 76, -40, -110, -62, 9, 127, 18, 25, 71, 68, -81, 59, 50, -99, 74, 51,
                        -21, -85, -64, 69, -105, 0, 39, 96, -49, -77, 73, 85, 118, 70, -30, 60, 53,
                        -96, -89, -87, -118, -81, -93, -51, 60, -13, 32, 95, -125, -119, -92, -100,
                        -39, -75, -90, -11, -37, 104, 10, -76, -48, 21, 62, 109, -81, -58, 22, 120,
                        41, 121, 66, -53, 86, -29, -79, -51, -63, -90, -96, 19, -111, 22, -29, -119,
                        -88, -58, -44, 105, -24, -22, -121, -23, -99, 9, -69, 3, -96, 110, -96, 41,
                        55, -123, -102, 89, -5, 71, 58, 114, 29, -123, 37, -80, -110, 55, 85, -92,
                        -21, -34, 3, -21, -34, -31, -74, -13, -7, 123, 58, 9, 44, -83, -114, -1, 30,
                        -94, 121, 99, 18, 4, -109, 103, 61, 89, 108, -24, -86, -82, 55, 126, 102,
                        -49, -103, 84, 99, -91, -22, 49, 120, 68, -79, 84, -66, 90, -81, 63, 13,
                        -65, -75, -50, -104, -56, 122, 68, 97, -44, 118, 105, 59, 1, 111, 39, -85,
                        95, -94, -80, -104, 50, 82, 12, -100, 8, 12, 106, 12, 84, -32, -125, -36,
                        -48, -83, 58, 15, 15, 117, 111, -26, 13, -37, -37, 80, -92, 43, -45, 95, 67,
                        124, 45, 22, -6, -121, 98, 9, -10, -46, 40, 49, -75, -96, -66};

        // check the plain text size
        byte[] source = plainText.getBytes(StandardCharsets.UTF_8);
        this.check(&quot;Plain size&quot;, plainSize == source.length);
        // deflate the content (see 1. above)
        byte[] deflated = this.deflate(source);
        // and check the checksum (see 2. above)
        this.check(&quot;Deflated hash&quot;, Arrays.equals(checksum, this.getSha256_1k(deflated)));

        // hash the password (see 3. above)
        byte[] hashedPassword = this.getSha256_1k(password.getBytes(StandardCharsets.UTF_8));
        char[] chars = new char[hashedPassword.length];
        for (int i = 0; i &lt; hashedPassword.length; i++) {
            chars[i] = (char) hashedPassword[i];
        }
        this.check(&quot;Start key size&quot;, chars.length == startKeySize);
        // or:
        // char[] chars = password.toCharArray();

        // get the key (see 4. above)
        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
        KeySpec keySpec = new PBEKeySpec(chars, salt, iterationCount, keySize * 8);
        SecretKey s = factory.generateSecret(keySpec);
        Key key = new SecretKeySpec(s.getEncoded(), &quot;AES&quot;);

        // encrypt the data (see 6. above)
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;);
        // or:
        // Cipher cipher = Cipher.getInstance(&quot;AES/CBC/ISO10126Padding&quot;); // W3C padding
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] result = cipher.doFinal(deflated);

        this.check(&quot;Encrypted&quot;, Arrays.equals(encrypted, result));
    }

    private byte[] deflate(byte[] data) throws IOException {
        InputStream is = new ByteArrayInputStream(data);
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        final byte[] buffer = new byte[16];  // for testing purpose

        Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION, true);
        DeflaterOutputStream dos = new DeflaterOutputStream(os, deflater);
        int count = is.read(buffer);
        while (count != -1) {
            dos.write(buffer, 0, count);
            count = is.read(buffer);
        }
        dos.close();
        return os.toByteArray();
    }

    private byte[] getSha256_1k(byte[] data) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);
        digest.update(data, 0, Math.min(data.length, 1024));
        return digest.digest();
    }

    private void check(String text, boolean test) {
        if (test) {
            System.out.println(text + &quot; ok&quot;);
        } else {
            System.out.println(text + &quot; NOT ok&quot;);
            System.exit(1);
        }
    }
}
</code></pre>
<p>The output is:</p>
<pre><code>Plain size ok
Deflated hash ok
Start key size ok
Encrypted NOT ok
</code></pre>
<p>Of course, I would like the generated encrypted data to be identical to the one present in the ODS archive. I tried to change the padding, the key derivation function, to pass the <code>password</code> directly to <code>PBEKeySpec</code>, triple-checked the password, etc. without success. I also had a look to the source code of LibreOffice (<a href=""https://github.com/LibreOffice/core/tree/master/oox/source/crypto"" rel=""nofollow noreferrer"">https://github.com/LibreOffice/core/tree/master/oox/source/crypto</a>), but did not manage to find what is wrong in my code. (If that matters, I used LibreOffice Calc Version: 6.0.7.3 on Ubuntu 18.04.10 and Java 8.)</p>
<p>My question is: where is my mistake and how do I fix it?</p>
"	NULL	0	NULL	41:38.9	0	06:05.4	12:55.1	NULL	-1	6914441	0	1	1	<java><encryption><aes><libreoffice><ods>	Encrypt a file inside an ODS archive	264	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62120891	62132453	1	"<p>I am trying to obtain the <code>SecretKey</code> passed to the <code>decryptAesCipherText</code> function. I hooked the function in Frida to try to print out the arguments when the method is called but since <code>SecretKey</code> is an object, all attempts to print it out give output as <code>[object Object]</code>. However the SecretKey object has a method getEncoded() which will return a byte array which can be printed out in hex format. How can I call this method from Frida and get the result? </p>

<p>The java function, I am hooking to is given below</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;

private byte[] decryptAesCipherText(SecretKey secretKey, byte[] bArr) {
        Cipher instance = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        instance.init(2, secretKey);
        return decryptCipherText(instance, bArr);
}
</code></pre>

<p><br><br>
The javascript snippet (incomplete) to hook the function</p>

<pre><code>var target_class = Java.use('com.reactlibrary.securekeystore.RNSecureKeyStoreModule');

target_class.decryptAesCipherText.overload('javax.crypto.SecretKey','[B').implementation = function(key, array){
        console.log(""Inside decrypt aes"");

        //Call getEncoded method on key to get byte array

        var ret = my_class.decryptAesCipherText.overload('javax.crypto.SecretKey','[B').call(this, key, array);
        return ret;
}
</code></pre>
"	NULL	0	NULL	41:20.5	0	01:11.4	NULL	NULL	0	12306553	0	1	3	<java><android><frida>	Calling a method of a Java object passed as argument to hooked function in Frida	3231	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62204882	62206791	1	"<pre><code>public class Main {

public static void main(String[] args) {
    String result = blowfish(""123123"");
    System.out.println(result);
}

public static String blowfish(String source) {
    final String BLOWFISH_KEY = ""22ddba9832444234"";

    try {
        Cipher cipher = Cipher.getInstance(""Blowfish/ECB/PKCS5Padding"");

        cipher.init(
                Cipher.ENCRYPT_MODE,
                new SecretKeySpec(BLOWFISH_KEY.getBytes(""UTF-8""), ""Blowfish"")
        );
        return new String(cipher.doFinal(source.getBytes(""UTF-8"")));

    } catch (Exception e) {
        e.printStackTrace(System.out);
        return null;
     }
   }
}
</code></pre>

<p>If I run this code with java 6 oracle and then run with java 8 openJdk gives me different outputs, Why?</p>
"	NULL	6	NULL	00:48.8	0	26:34.9	54:06.0	NULL	8450064	5992224	0	1	2	<java><encryption><blowfish>	Different results with Blowfish between java 6 and java 8	139	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62367038	62367274	1	"<pre><code> public byte[] encryptWithAesKey(byte[] key, byte[] iv, byte[] data) {
      try {
             IvParameterSpec ivSpec = new IvParameterSpec(iv);
             Cipher cipher = Cipher.getInstance(""AES/CTR/NoPadding"");
             SecretKeySpec aesKey = new SecretKeySpec(key, ""AES"");
             cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);
             return cipher.doFinal(data);
          } catch (Exception e) {
             System.out.println(""Error while encrypting: "" + e.toString());
          }
     return null;
 }
</code></pre>

<p>at javax.crypto.spec.SecretKeySpec.(SecretKeySpec.java:96)</p>

<p>This is returning an exception but works well in android 28 lower.</p>

<p>StackTrace as follows:</p>

<pre><code>System.out: encryptwithAES:[B@b8979fbIV:[B@78d7813data:[B@3841a50
System.err: java.lang.IllegalArgumentException: Empty key
System.err:    at javax.crypto.spec.SecretKeySpec.&lt;init&gt;(SecretKeySpec.java:96)
System.err:    at com..Security.SecurityController.encryptWithAesKey(SecurityController.java:93)
System.err:    at com..Controllers.Files.FileController.encryptAndSaveFile(FileController.java:75)
System.err:    at com..Controllers.Files.FileControllerRN.encryptAndSaveFileRN(FileControllerRN.java:68)
System.err:    at java.lang.reflect.Method.invoke(Native Method)
System.err:    at com.facebook.react.bridge.JavaMethodWrapper.invoke(JavaMethodWrapper.java:372)
System.err:    at com.facebook.react.bridge.JavaModuleWrapper.invoke(JavaModuleWrapper.java:151)
System.err:    at com.facebook.react.bridge.queue.NativeRunnable.run(Native Method)
System.err:    at android.os.Handler.handleCallback(Handler.java:883)
System.err:    at android.os.Handler.dispatchMessage(Handler.java:100)
System.err:    at com.facebook.react.bridge.queue.MessageQueueThreadHandler.dispatchMessage(MessageQueueThreadHandler.java:27)
System.err:    at android.os.Looper.loop(Looper.java:214)
System.err:    at com.facebook.react.bridge.queue.MessageQueueThreadImpl$4.run(MessageQueueThreadImpl.java:226)
System.err:    at java.lang.Thread.run(Thread.java:919)
</code></pre>
"	NULL	3	NULL	23:48.8	0	26:38.6	49:15.8	NULL	12588090	12588090	0	1	1	<java><exception><encryption><cryptography><illegalargumentexception>	java.lang.IllegalArgumentException: Empty key	3706	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62437595	0	1	"<p>At runtime, getting java.lang.IllegalStateException with Cipher not initialized message while decypting ciphertext
my code is as below:</p>

<pre><code>public String decrypt(String cipherText) throws SecurityException {
        String clearText = null;
        try {
            cipher = Cipher.getInstance(""AES/OFB/NoPadding"");
            byte[] cipherTextBytes = Base64.decodeBase64(cipherText.getBytes());
            byte[] iv = ArrayUtils.subarray(cipherTextBytes, 0, INIT_VECTOR_LENGTH);
            cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
            byte[] decryptedBytes = cipher
                    .doFinal(ArrayUtils.subarray(cipherTextBytes, INIT_VECTOR_LENGTH, cipherTextBytes.length));
            clearText = new String(decryptedBytes, CHARACTER_ENCODING).trim();
        } catch (InvalidKeyException | IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException
                | NoSuchAlgorithmException | NoSuchPaddingException | InvalidAlgorithmParameterException e) {
            throw new SecurityException(e);
        }
        return clearText;
    }
</code></pre>

<p>Exception in thread ""pool-5-thread-3"" java.lang.IllegalStateException: Cipher not initialized
at javax.crypto.Cipher.checkCipherState(Cipher.java:1749)
at javax.crypto.Cipher.doFinal(Cipher.java:2156)</p>

<p>and this is intermittent issue, after some time it decrypts ciphetext and works as expected.</p>
"	NULL	0	NULL	12:12.4	0	04:31.1	NULL	NULL	0	13764842	0	1	1	<java><multithreading><encryption><cryptography><illegalstateexception>	Exception in thread java.lang.IllegalStateException: Cipher not initialized	1176	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62443278	0	1	"<p>I've following aes encryption code in Java which I want to write it in C#, but it is not giving same output.<br/>
Java Code</p>

<pre><code>public String doEncryptString(String salt, String password,String token) throws CryptoException {
        try {
            Cipher cipher = Cipher.getInstance(""AES"");
            SecretKeySpec secretKeySpec = generateKeySpec(salt,password);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            byte[] inputBytes = token.getBytes();
            byte[] outputBytes = cipher.doFinal(inputBytes);
            return Base64Utils.encodeToString(outputBytes);
        } catch (NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException | BadPaddingException
                | IllegalBlockSizeException ex) {
            throw new CryptoException(""Error encrypting password"", ex);
        }
    } 

private SecretKeySpec generateKeySpec(String salt,String password) throws CryptoException{
        try {

        String generatedkey=salt+password;
        byte[] key = generatedkey.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16); // use only first 128 bit
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
        return secretKeySpec;
    } catch (NoSuchAlgorithmException | IOException ex) {
        throw new CryptoException(""Error encrypting password"", ex);
    }
    }
</code></pre>

<p>This is what I've tried in C#</p>

<pre><code>public static string DoEncrypt(string salt, string password, string token)
        {
            var tdes = new AesManaged();
            tdes.Key = GenerateKey(salt, password);
            tdes.Mode = CipherMode.ECB;
            tdes.Padding = PaddingMode.PKCS7;
            ICryptoTransform crypt = tdes.CreateEncryptor();
            byte[] plain = Encoding.UTF8.GetBytes(token);
            byte[] cipher = crypt.TransformFinalBlock(plain, 0, plain.Length);
            return Convert.ToBase64String(cipher);
        }

        private static byte[] GenerateKey(string salt, string password)
        {
            string generatedkey = $""{salt}{password}"";
            var key = Encoding.UTF8.GetBytes(generatedkey);
            var sha1 = SHA1Managed.Create();
            key = sha1.ComputeHash(key);
            return key.Take(16).ToArray(); // use only first 128 bit
        }
</code></pre>

<p><strong>string/token to encrypt :</strong> ZHKRIWB310XVVWG315PI7UZZWU1V0YYL5WE9JL <br/>
<strong>Java output:</strong> eUjNH8kcgWtlEmuCFHMPwnCFWjy5Pye/gF+itrPs1g8AjtAEZQqlzW/v7kEt2haG <br/>
<strong>My C# code output:</strong> O8sKdJWH+XCOIbexZPEwN5NxWqpWRHC5b3ZsihT8cfBqpI1eVr3PEr9Eq39a5pMn
<br/><br />
I don't know what I am doing wrong here. Any help would be appreciated. Thanks
<br/><br/>
<strong>Update</strong> <br/><br/>
My apologies everyone. The code translated in C# in working fine. By mistake, I was passing different salt value. Thanks everyone.</p>
"	NULL	5	NULL	56:46.3	0	41:47.4	41:47.4	NULL	13622084	13622084	0	1	1	<java><c#><encryption><aes>	AES-Encryption result of C# code is not same as of Java AES-Encryption	243	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62471603	0	2	"<p>I'm Encrypting the data with ""AES/GCM/NoPadding"" algorithm, before cipher init method I'm getting <strong>java.security.InvalidAlgorithmParameterException: GCM can not be used with class javax.crypto.spec.GCMParameterSpec</strong> error, is there any specific reason for this??</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
GCMParameterSpec parameterSpec = new GCMParameterSpec(128, iv);
SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
cipher.init(Cipher.ENCRYPT_MODE, keySpec, parameterSpec);
</code></pre>
"	NULL	6	NULL	43:14.4	0	43:21.0	39:07.6	NULL	5711075	5711075	0	1	0	<java><encryption><cryptography><aes><aes-gcm>	java.security.InvalidAlgorithmParameterException: GCM can not be used with class javax.crypto.spec.GCMParameterSpec	1779	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62562417	0	NULL	"<p>I'm trying to implement encrypt with AES/128/CBC, but I need to encrypt with a 64 bytes key, But I have the problem with the length.</p>
<p>It is possible encrypt AES/128/CBC with a 64 bytes key or not, because I have the cipher algoritm in php with a 64 bytes key and it works, but not in java.</p>
<p>This is the encrypt code:</p>
<pre><code> public static String ALGORITHM = &quot;AES&quot;;

 public static String AES_CBC_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;

 public static byte[] encrypt(final byte[] key, final byte[] IV, final byte[] message) throws Exception {
  return AESManager.encryptDecrypt(Cipher.ENCRYPT_MODE, key, IV, message);
 }

 public static byte[] decrypt(final byte[] key, final byte[] IV, final byte[] message) throws Exception {
  return AESManager.encryptDecrypt(Cipher.DECRYPT_MODE, key, IV, message);
 }

 private static byte[] encryptDecrypt(final int mode, final byte[] key, 
                                    final byte[] IV, final byte[] message) throws Exception {
  final Cipher cipher = Cipher.getInstance(AES_CBC_PADDING);
  final SecretKeySpec keySpec = new SecretKeySpec(key, ALGORITHM);
  final IvParameterSpec ivSpec = new IvParameterSpec(IV);
  cipher.init(mode, keySpec, ivSpec);
  return cipher.doFinal(message);
 }

 public static String getHex(byte[] data, int length) {
  StringBuffer sb = new StringBuffer();
  for (int i = 0; i &lt; length; i++) {
   String hexStr = Integer.toHexString(((int) data[i]) &amp; 0xFF);
   if (hexStr.length() &lt; 2) {
    sb.append(&quot;0&quot;).append(hexStr.toUpperCase());
   } else {
    sb.append(hexStr.toUpperCase());
   }
  }
  return sb.toString();
 }
</code></pre>
<p>I have this error:</p>
<pre><code>java.security.InvalidKeyException: Invalid AES key length: 64 bytes
at com.sun.crypto.provider.AESCrypt.init(AESCrypt.java:87)
at com.sun.crypto.provider.CipherBlockChaining.init(CipherBlockChaining.java:93)
at com.sun.crypto.provider.CipherCore.init(CipherCore.java:591)
at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:346)
at javax.crypto.Cipher.implInit(Cipher.java:805)
at javax.crypto.Cipher.chooseProvider(Cipher.java:863)
at javax.crypto.Cipher.init(Cipher.java:1395)
at javax.crypto.Cipher.init(Cipher.java:1326)
at ec.otecel.tuenti.balance.util.AESManager.encryptDecrypt(AESManager.java)
at ec.otecel.tuenti.balance.util.AESManager.encrypt(AESManager.java)
at ec.otecel.tuenti.balance.util.FreemiumUtil.ciphertoFreemium(FreemiumUtil.java)
at ec.otecel.tuenti.balance.util.FreemiumUtil.main(FreemiumUtil.java)
</code></pre>
<p>I have local_policy.jar and US_export_policy.jar in C:\Program Files\Java\jdk1.8.0_241\jre\lib\security
so, what could be the problem ?</p>
"	NULL	NULL	NULL	09:32.6	NULL	NULL	NULL	NULL	NULL	10287727	0	1	0	<java><encryption><cypher><aes><cbc-mode>	AES-128-CBC cipher in java	2714	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62591015	0	1	"<p>Communicate with encrypted parameters between Java and Delphi.
If Delphi encrypts them, Java needs to decrypt them.
But if I operate as below, Java will have an error...
How should I change the Java sauce?</p>
<p>[ Delphi source (Encrypt) ]</p>
<pre><code>var
  Data: string;
begin
  Data := Memo1.Text;
  DCP_rijndael1.InitStr(Edt_Password.Text, TDCP_sha256);
  DCP_rijndael1.EncryptCBC(Data[1],Data[1],Length(Data));
  DCP_rijndael1.Burn;
  Memo2.Text := Base64EncodeStr(Data);
end;
</code></pre>
<p>[ Delphi source (Decrypt) ]</p>
<pre><code>var
  Data: string;
begin
  Data := Base64DecodeStr(Memo2.Text);
  DCP_rijndael1.InitStr(Edt_Password.Text, TDCP_sha256);
  DCP_rijndael1.DecryptCBC(Data[1],Data[1],Length(Data));
  DCP_rijndael1.Burn;
  Memo3.Text := Data;
end;
</code></pre>
<p>[Java source]</p>
<pre><code>public static String Decrypt(String text, String key) throws Exception

{

          Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);

          byte[] keyBytes= new byte[16];

          byte[] b= key.getBytes(&quot;UTF-8&quot;);

          int len= b.length;

          if (len &gt; keyBytes.length) len = keyBytes.length;

          System.arraycopy(b, 0, keyBytes, 0, len);

          SecretKeySpec keySpec = new SecretKeySpec(keyBytes, &quot;AES&quot;);

          IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);

          cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);


          sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();

          byte [] results = cipher.doFinal(decoder.decodeBuffer(text));

          return new String(results,&quot;UTF-8&quot;);

}
</code></pre>
"	NULL	7	NULL	35:38.3	0	56:23.3	16:16.3	NULL	13817754	13817754	0	1	0	<java><delphi><encryption><aes><rijndael>	AES encryption between Delphi and Java	572	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62712114	62721941	1	"<p>I am trying to code a simple encryption and decryption method for my program in Java. It should encrypt and decrypt a string with another string as key.</p>
<p>While testing, a <code>BadPaddingException</code> occured.</p>
<p>My current method to encrypt:</p>
<pre><code>public String encrypt(String strToEncrypt, String secretKey) {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            byte[] salt = new Hash().hashString(secretKey).getBytes();
            KeySpec spec = new PBEKeySpec(secretKey.toCharArray(), salt, 65536, 256);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
            IvParameterSpec ivspec = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);

            byte[] ciphertext = cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;Finished encryption&quot;);
            return new Base64().encodeToString(ciphertext);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
</code></pre>
<p>My current method to decrypt:</p>
<pre><code>public String decrypt(String strToDecrypt, String secretKey) {  
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            byte[] salt = new Hash().hashString(secretKey).getBytes();
            KeySpec spec = new PBEKeySpec(secretKey.toCharArray(), salt, 65536, 256);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
            IvParameterSpec ivspec = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, secret, ivspec);
            
            byte[] decodedPlaintext = new Base64().decode(strToDecrypt);
            byte[] plaintext = cipher.doFinal(decodedPlaintext);
            System.out.println(&quot;Finished decryption&quot;);
            return new Base64().encodeToString(plaintext);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
</code></pre>
<p>I am getting the followed exception:</p>
<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
    at java.base/com.sun.crypto.provider.CipherCore.unpad(CipherCore.java:975)
    at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1056)
    at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
    at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2202)
</code></pre>
"	NULL	6	NULL	06:59.8	0	40:42.6	55:55.2	NULL	13858394	13858394	0	1	0	<java><exception><cryptography><aes>	Java AES giving BadPaddingException	463	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
62832136	0	0	"<p>I need to decrypt an file in Java.<br />
The file was encrypted in C# using RijndaelManaged.
This are the C# settings for the encryption (summarized and not mentioned are default value):</p>
<pre><code>var crypto = new RijndaelManaged();
crypto.GenerateKey();
crypto.BlockSize = crypto.KeySize;
crypto.IV = crypto.Key;
crypto.Padding = PaddingMode.Zeros;
</code></pre>
<p>my java code so far, which produces an error:</p>
<blockquote>
<p><code>java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long</code>:</p>
</blockquote>
<pre class=""lang-java prettyprint-override""><code>Key aesKey = new SecretKeySpec(key, &quot;AES&quot;);
Cipher cipher2 = Cipher.getInstance(&quot;AES/CBC/noPadding&quot;);
byte[] iv = key;
IvParameterSpec ivspec = new IvParameterSpec(iv);
cipher2.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));
byte[] decryptedFile = cipher2.doFinal(buildFile);
</code></pre>
<p>I see 2 Problems concerning the C# code:</p>
<ol>
<li>the generated Key is 256bit. Then the block size is set to to 256bit, but the standard is 128bit. As far as I know, Java is only able to use a 128bit block size, as the Error message suggests. At least I didn't find out how to set the block size.</li>
<li>Rijndael uses <code>PaddingMode.Zeros</code>, whats the equivalent Padding for Cipher?</li>
</ol>
<p><strong>please be aware that I can't change the C# code</strong></p>
<p>Is there even a way to decrypt this in Java?</p>
<p><strong>Update - Solution</strong><br />
I finally managed to decrypt the file using <a href=""http://www.bouncycastle.org/java.html"" rel=""nofollow noreferrer"">BouncyCastle</a> suggested by <a href=""https://stackoverflow.com/users/9014097/topaco"">Topaco</a> in the comments.<br />
BouncyCastle includes <code>RijndaelEngine</code>, same as the C# part. It allows to set the block size to 256bit.</p>
<p>To answer my 2. question: <code>PaddinMode.Zeros</code> equals <code>new ZeroBytePadding()</code></p>
<p>Full code:</p>
<pre><code>import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.engines.RijndaelEngine;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
...

private byte[] decryptPart(byte[] part, byte[] key) throws Exception {
    BlockCipher engine = new RijndaelEngine(key.length * 8);
    PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(engine),
            new ZeroBytePadding());

    KeyParameter keyParam = new KeyParameter(key);
    CipherParameters cipherParams = new ParametersWithIV(keyParam, key);
    cipher.init(false, cipherParams);
    byte[] output = new byte[cipher.getOutputSize(part.length)];
    int tam = cipher.processBytes(part, 0, part.length, output, 0);
    try {
        cipher.doFinal(output, tam);
    } catch (Exception ce) {
        ce.printStackTrace();
    }
    return output;
}
</code></pre>
"	NULL	6	NULL	16:01.0	0	05:43.7	05:43.7	NULL	13329087	13329087	0	1	0	<java><c#><encryption><aes><rijndael>	decrypt an encrypted file with 256bit block size in Java (encryption Rijndael C#)	286	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63042648	0	NULL	"<p>Can someone help on why I am getting &quot;javax.crypto.AEADBadTagException: Tag mismatch&quot; error? Not sure, what I am missing.
Below is the decryption util code.  EncryptedData includes initVector as well.</p>
<pre><code>import org.apache.commons.codec.binary.Base64

import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec
import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import java.security.SecureRandom

class GCMEncryptionUtil {
    static final String AES = &quot;AES&quot;
    static final String AES_GCM_NO_PADDING = &quot;AES/GCM/NoPadding&quot;

    static final int TAG_LENGTH_BIT = 128
    static final int IV_LENGTH_BYTE = 12

    private static final Charset UTF_8 = StandardCharsets.UTF_8

    public static void main(String[] args) {
        String encryptedDataWithIV = args[0]
        SecretKey key = generateSecretFromSymmetricKey(&quot;thisismysecretkey&quot;)
        decrypt(encryptedDataWithIV, key)
    }

    static String decrypt(String encryptedData, SecretKey secret) throws Exception {
        byte[] encryptedDataInBytes = Base64.decodeBase64(encryptedData)
        ByteBuffer cipherTextBuffer = ByteBuffer.wrap(encryptedDataInBytes)

        // Get IV from cipherText
        byte[] iv = new byte[IV_LENGTH_BYTE]
        cipherTextBuffer.get(iv)

        // Remove IV from cipherText which is actual payload to be decrypted
        byte[] cipherText = new byte[cipherTextBuffer.remaining()]
        cipherTextBuffer.get(cipherText)

        Cipher cipher = Cipher.getInstance(AES_GCM_NO_PADDING)
        cipher.init(Cipher.DECRYPT_MODE, secret, new GCMParameterSpec(TAG_LENGTH_BIT, iv))
        byte[] plainText = cipher.doFinal(cipherText)
        return new String(plainText, UTF_8)
    }

    static SecretKey generateSecretFromSymmetricKey(String key) {
        byte[] bytes = Base64.decodeBase64(key)
        new SecretKeySpec(bytes, 0, bytes.length, AES)
    }
}
</code></pre>
"	NULL	NULL	NULL	25:36.5	NULL	NULL	NULL	NULL	NULL	13912830	0	1	1	<java><encryption>	Java javax.crypto.AEADBadTagException: Tag mismatch	809	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63107993	0	NULL	"<p>Despite checking that both my IV and derived keys are equal for encryption and decryption, it still throws the same error. The byte array will encrypt no problem, but decryption always fails. My decryption and encryption code looks like:</p>
<pre><code>private final static int BLOCK_SIZE = 256;
private final static int IV_SIZE = 16;
private final static int ITERATION_COUNT = 10;
private final static String ENCRYPTION_ALGORITHM = &quot;PBKDF2WithHmacSHA256&quot;;
private final static String ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;

public byte[] encryptByteArray(byte[] plaintext, String fileName) throws InvalidKeyException
{
    extractIVfromName(fileName);
    genKey();
    
    try {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(BLOCK_SIZE, iv);

        Log.d(&quot;encryptByteArray&quot;, &quot;Size: &quot; + plaintext.length + &quot; IV SPEC: &quot; +
                Base64.encodeToString(parameterSpec.getIV(), Base64.DEFAULT) + &quot;DerivedKey: &quot; +
                Base64.encodeToString(derivedKey.getEncoded(), Base64.DEFAULT));

        cipher.init(Cipher.ENCRYPT_MODE, derivedKey, parameterSpec);
        return cipher.doFinal(plaintext);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>And here we have decryption, where the error is occuring:</p>
<pre><code>public byte[] decryptByteArray(byte[] ciphertext, String fileName) throws InvalidKeyException
{
    extractIVfromName(fileName);
    genKey();
    try {
        //IV fails for some reason
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(BLOCK_SIZE, iv);
        Log.d(&quot;decryptByteArray&quot;, &quot;Size: &quot; + ciphertext.length + &quot; IV SPEC: &quot; +
                Base64.encodeToString(parameterSpec.getIV(), Base64.DEFAULT) + &quot;DerivedKey: &quot; +
                Base64.encodeToString(derivedKey.getEncoded(), Base64.DEFAULT));
        cipher.init(Cipher.DECRYPT_MODE, derivedKey, parameterSpec);
        return cipher.doFinal(ciphertext);

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>An example of the debug log gives this:</p>
<pre><code>2020-07-26 22:40:03.667 9089-9089/com.iso.gallery256 D/decryptByteArray: Size: 45312 IV SPEC: NWZmYmUzZGItZGE4MS00Yw==
    DerivedKey: pa2OYoRLjTphldeSi1L6EQCmlXTzQJLeXgPIuu6kRus=

2020-07-26 22:40:00.184 9089-9089/com.iso.gallery256 D/encryptByteArray: Size: 45307 IV SPEC: NWZmYmUzZGItZGE4MS00Yw==
    DerivedKey: pa2OYoRLjTphldeSi1L6EQCmlXTzQJLeXgPIuu6kRus=
</code></pre>
<p>I don't think the problem is with how the IV or key are generated, since they come out exactly the same for decryption and encryption, but rather with my cipher options.</p>
"	NULL	NULL	NULL	45:41.7	NULL	NULL	NULL	NULL	NULL	3475043	0	1	0	<java><android><encryption>	Android Decryption Throwing java.security.InvalidAlgorithmParameterException: IV must be specified in CBC mode	528	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63222761	63540754	1	"<p>This issue occurs around once in a day on the production environment. The load is around 20TPS and the AES decryption is called twice for every request on the server. The error is not generated for all requests but It crashes once in a day. Following is the snippet of hs_err_pid file.</p>
<p>A fatal error has been detected by the Java Runtime Environment:</p>
<p><strong>SIGSEGV (0xb) at pc=0x00007f26cc5de47e, pid=53978, tid=0x00007f26837f7700</strong>
JRE version: Java(TM) SE Runtime Environment (8.0_241-b31) (build 1.8.0_241-b31)
Java VM: Java HotSpot(TM) 64-Bit Server VM (25.241-b31 mixed mode linux-amd64 compressed oops)
<strong>Problematic frame:</strong>
<strong>v  ~StubRoutines::arrayof_jbyte_fill</strong></p>
<pre><code>Current thread (0x00007f26d0a03800):  JavaThread &quot;http-nio-9094-exec-10&quot; daemon 
[_thread_in_Java, id=54617, stack(0x00007f26836f7000,0x00007f26837f8000)]


Stack: [0x00007f26836f7000,0x00007f26837f8000],  sp=0x00007f26837f44f0,  free space=1013k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
v  ~StubRoutines::arrayof_jbyte_fill
J 26458 C2 java.util.Arrays.fill([BB)V (21 bytes) @ 0x00007f26cc737ca2 
[0x00007f26cc737c60+0x42]
j  com.sun.crypto.provider.CipherCore.fillOutputBuffer([BI[BII[B)I+73
j  com.sun.crypto.provider.CipherCore.doFinal([BII)[B+65
j  com.sun.crypto.provider.AESCipher.engineDoFinal([BII)[B+7
j  javax.crypto.Cipher.doFinal([B)[B+30
j  com.hello.genesys.common.AES.decrypt([BLjava/lang/String;)[B+92
</code></pre>
<p>Following is the decryption method :</p>
<pre><code>public static byte[] decrypt(byte[] data, String password) throws Exception {
    try {
        log.info(&quot;/// Inside the decrypter method of AES class ////&quot;);
        if (null == cipher) {
            log.info(&quot;The Cipher is null and hence forming new object of cipher&quot;);
            cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
        }

        log.info(&quot;Key generation method to be called&quot;);
        Key k = new SecretKeySpec(password.getBytes(), AES_ENCRYPTION_TYPE);
        
        log.info(&quot;Cipher initialization to be done&quot;);
        cipher.init(Cipher.DECRYPT_MODE, k);

        log.info(&quot;The byte array value to be returned&quot;);
        
        return cipher.doFinal(data);
    } catch (Throwable e) {
        log.info(&quot;Inside Exception of AES decryption method&quot;);
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>This method is called in a different class :</p>
<pre><code>byte[] decrypter = AES.decrypt(decodeToken, _env(&quot;tokenSalt&quot;));
</code></pre>
<p>It does not throws an exception but crashes with <strong>arrayof_jbyte_fill</strong> related error. Please help me solve this issue as it occurs only in the production environment but not in a lower environment. Link to the hs_err_pid file for more details: <a href=""https://drive.google.com/file/d/1WDG4rm7vIw6HDbhZPtXjud7r8TEh4d74/view?usp=sharing"" rel=""nofollow noreferrer"">https://drive.google.com/file/d/1WDG4rm7vIw6HDbhZPtXjud7r8TEh4d74/view?usp=sharing</a></p>
"	NULL	5	NULL	52:40.9	0	20:16.7	NULL	NULL	0	9669745	0	1	3	<java><spring><encryption><cryptography><aes>	Jar crashes while decrypting AES encrypted Authorization token method in code. hs_err _pid file mentions arrayof_jbyte_fill	127	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63599484	63601942	1	"<p>I need to decrypt text data I get from SAP. The data is encrypted using co_aes256_algorithm_pem similar to <a href=""https://blogs.sap.com/2019/08/26/aes-encryption-in-abap/"" rel=""nofollow noreferrer"">this</a></p>
<p>SAP sends me a key and data encrypted and we should use this key to decrypt the data in Java.
In SAP side, The IV Value (32 0's is added to padding )</p>
<p>Below is an example of key and encrypted data. I am trying to decrypt it in simple java program but can not initiate a key with with suitable length.</p>
<pre><code>    String encryptionKey = &quot;D5F748A3CE9C5AAAFF5C216387C92C43BC5C5BE443281D07E9128759A02FA0A2&quot;;
    
    String encryptedString = &quot;AA68A1E527F81C7E2101910AC39B9E482AD85EB37A414492D6F647878236D5466F92B4F650BB89456A282FC01664063FE6B07FA92043F2447463C3529676C81DC050010F84D402460BBE2F031508D0B2109314DDB001D726C012DBA577F9EB5791BF43AEF87D215E5C8C9DC657A869FB509F77EAD71542EA5BC8568F4E636A2575544816AAAFE6A1DE73888A858EA879B754BB0A9DE48B6E52541A999F881AE6EB83C8C548BE5088C31556B86F9A5DABA4105031240B8599EA028C734044E5A5403B196FCA220FB8ECAB176C4F689157961C93AA96EA912558673532A9D6D5D58437137EA28653112A3DBAE35AFF2DC0C4F8A635017274CB713A0207D116E22D5D6C156AEF579FD1D36F4B64DDDB39A97FD8E6DBA4ED9DC970F4F5F2A5E0A8CBEFCE0A3750C31CE01927CBCF9713E28B186B631F331514530C8906D7BC4BEF022466715DEAC62B15DF933E79AFB4152E1472FF456B090CBD6186F288D090A96DA96D4865D6CD835B3C77151BA4F35D6F199B11DF6B1CBA4157888FAA8D1BCB24259F2EB58713826F147C8AC96697C021482F5185E7D232A23C8A0A54E483BC02D033C5FA5D50250AC30D2EBEA6A257B8E3FA441111EC0EF3CBA01FE83681EF5ED233D1D4006F55BDACD50E1A42EE65AB869E41BE6084647DC508DEF4AF4FE8D5E39E92338EAF3AF54D91FFBA1E1F1D7F5DE8893C6CEEED16563EDAE8EDD7032C11F90C698265A0E8D2145489534EE5107D226C1D1F5229FD1E83369A5A7CAABD3CDBFCC643BDD00A640C189C3D582CBE41F697EA3DBA0A33930F616E007AD0695752FABAB91EAD96639651E9E017F039DC7004A9E2FDC06A383E46F8157EFB7FC634BDD9712C9DD9A3F254FED39EB750B2D8D1C8A7A369B5EC292059E7729C1FBDF755518CB2AF8EDFD796D268A32CAD9FF804450E8A0EC17F1A895DCF4E62D0AF845F14A023AD7F9EAF70EA014B34C589B85FAE2AFBE91BB7D0A8F731FD8000FA0766339EA9E451F88AEFC9860B1408EC50D0A7E330CE5A8C39CA84717717DEBC2367A42D057509DA24B391B586934A94DBE2B354A10C4075126D4613BAADC5C9D04F1A76144DAA95BBDA55E6C64DF92C1CC37FA4DA699386EFEC3065D2562101AAAB730BD9F450E87C00282632028EE582B85CBFB4860921EAF1AED0DDE83EA5D64E004EB8DBE771A098C6D804D8B1A7DA5CFCEEF162C0597530AB62937568FB4324B2FC97F2E535FF33668FB1121135D9B7798692D0B8187C9FB0AAE76438524CCD2C4AA97FFEBE666295F4B99278BABE306AE30CDD41C377E1DA6EC65B85FCFCA1E224430C9919B755727C8E86C7CACBB08CDCD5E24ABD5B8E0208FE5A50D59388605B883D32F35A91B201D1A632F26DFA4AC5EDB223DB73974DC206BC70F16E58D0ED0616F9A15C3B4C66E0169813402AF2AA0FF9440A7A368EDEA125EE62DB630FD49183588C68B3964E8BBBA06B02D08350D85A6400F5C97F7DF42E9EB79880337E14A9C0228A502E4D834832CF93859DBD36E68F5811BFD1EAAD30F82A807ECB2C5D44D7CFAAF45497C685A1114A3EFD6FCD9A76CD8FB6CDDF3985396D358B696B59EDA7411A427C495B99289EA4E5F0F64DB60A338B97A211E73EE36D70B3594559FB292E7E5C6A29894F807C70C6324C1F22E7998C107E1D2DB9795AA7C81EA80B6AD5762B50C1925DD06C3DC7FF1B5188749DF27D16F92A79D216111E0F27EF3BEE736F0D84AABB5D874A9B607CB5DC3BC61B41E5FA9F0A8F7931D1E9333281150BF70C719AB893635DE9DDC45F916328DE54F8F3C0C0B9109F7D507FB42CEFB12B9190BB0AED218AE70597DBAB53D3F5BB1E7312D343D9A615A46FC9D0179F20389AC99C7061FA9828C665C8077996D3262A35D68A55B1B682686FF86D2F3E7683E13BB9F828403FAF56F9186448B4F25FC7A0AFB5E2B1FE57D864AD177155C9BACE2D734CEDBA8BE5DCDDA241413ABF739082C48094225CDF069BF89338F9E991A3F6457A56A71B7F941E222E3B6A25E7B1F5892E9997C0E5D6EE8CAC041B455F976901CD25D98BC29FCC347C90445E34599F59DCFAE5477E0D492BC09B263E0516D4A622BA96F78F48B59E01F0DD3CE5113966286BC0DAABD3FD9C470E4EF1A5074819B964102C3C4006A3FD3395A7492B583FCA3AC1F51C7C1E54929A9963A0F9995E7EF7C098ACF4930F1795740E605AE79BFC6CDB0541FEC7259520D0A0588A64B7CD595D5E69CAE43907BEDDFD6DDCBA26486E56313315E83500315F2EA51B67D7F45B29736EDB47A10A614304242C8C1719FE198104BD4CCA50AB78BBB4D0C05D41860BE276FA742FB4BFDA2EFBCAA4DBC2B6542ED660E5F1113B19286833C7393BF846A20E7E2D6C9D8BB9760A4A3D65F92C7FF2E337FEFB4EC7BC6EE9F3C2DF1D78936554ABE0891DF0A4EEE552043A5AC44DA8EF309DC1A9E9226E2AE81813566596F209F9AB51C7B34AEA8BB6C24981A493E399243D7C5AEFEA60287EE7E58549F0A075C8CF120F1A5DC8ABD34553FACE945081BC729E1F1864235E3407845F058FD77E2C97207BCEFA0EECB4FCFE7B78789329D0985BA25C1EEB78846F10B9565659230642734586202542819C3DD1A9B161269CA4BB7454CF0186AF6CE724A31B9F545F4886AC08A2F5EE72254644423920D2C31F20C532DE8614E270B337451C69C695E7CB76D2CFF35896843C91BAA69AE67875243B74CEA1AEA7D9F008026206FA9D2774DA36423FF24B8839A2ECE0AEE750CB339ED015D817E10C802C51F76CF56C387C63FD04632EEBA5FBAFD6166BC034DA1F5697042369D2B1A1C0E0E27D131A079B537A3271682FAA49D7E821DE1DFBA9897CC65A2E8E0AAD17579095EEFB34E3A744D747AC452FDBB36A86502BDB0E&quot;;
    
    byte[] encryptedBytes = Base64.getDecoder().decode(encryptedString);
    
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    
    SecretKeySpec secKeySpec = new SecretKeySpec(encryptionKey.getBytes(), &quot;AES&quot;);
    
    byte[] ivBytes = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);

    cipher.init(Cipher.DECRYPT_MODE, secKeySpec, ivParameterSpec);

    String decrypted = new String(cipher.doFinal(encryptedBytes));      
    
    System.out.println(decrypted);
</code></pre>
<p>I get <strong>java.security.InvalidKeyException: Invalid AES key length: 64 bytes</strong></p>
<p>I checked this <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption?rq=1"">this </a> but I do not have a salt. And I also checked this <a href=""https://www.javainterviewpoint.com/aes-256-encryption-and-decryption/"" rel=""nofollow noreferrer"">this link</a> but I can not generate a key using my own encryptionKey.</p>
<p>Is there another solution for this? how can this be decrypted?</p>
"	NULL	0	NULL	09:16.4	0	24:45.5	24:45.5	NULL	9150270	8863925	0	1	1	<java><encryption><cryptography><abap>	Decrypting data encrypted in SAP using co_aes256_algorithm_pem in Java	1012	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63609617	63622130	1	"<pre class=""lang-java prettyprint-override""><code>Java code

public String encrypt(String key, String value) {
    try {
      String initVector = &quot;RgUkXp2s5v8y/B?E&quot;;
      IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;));
      SecretKeySpec skeySpec = new SecretKeySpec(hashKey(key), &quot;AES&quot;);
      Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
      cipher.init(1, skeySpec, iv);
      byte[] encrypted = cipher.doFinal(value.getBytes());
      return Base64.getEncoder().encodeToString(encrypted);
    } catch (Exception ex) {
      ex.printStackTrace();
      return null;
    } 
  }
  
  private byte[] hashKey(String keyValue) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    byte[] key = keyValue.getBytes(&quot;UTF-8&quot;);
    MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA-1&quot;);
    key = messageDigest.digest(key);
    return Arrays.copyOf(key, 16);
  }



public static String decrypt(byte[] key, String encrypted)
{
    try
    {
        String initVector = &quot;RgUkXp2s5v8y/B?E&quot;;
        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;));
        SecretKeySpec skeySpec = new SecretKeySpec(key, &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
        cipher.init(2, skeySpec, iv);
        byte[] original = cipher.doFinal(Base64.getDecoder().decode(encrypted));
        return new String(original);
    }
    catch (Exception ex)
    {
        Logger.getLogger(&quot;Decryption &quot;).log(Level.SEVERE, &quot;Exception processing decryption &quot; + ex.getMessage());
        return null;
    }
}

String encryptedLicense = ENCRYPT.encrypt(string_key, stringToEncrypt);



</code></pre>
<pre class=""lang-cs prettyprint-override""><code>
converted c# code

   public static byte[] getDefaultKey()
{
    return DecryptUtil.hashKey(DecryptUtil.getUniqueIdentifier());
}


private static byte[] hashKey(string keyValue)
{
    try
    {
        var sha1 = SHA1Managed.Create();
        byte[] inputBytes = Encoding.UTF8.GetBytes(keyValue);
        byte[] outputBytes = sha1.ComputeHash(inputBytes);
        return outputBytes;
       
    }
    catch (Exception ex)
    {
        ErrorLogger.WriteToFile(&quot;hashKey &quot; + ex.Message.ToString());
    }
    return null;
}

public static string Decrypt_License(string encryptedText, byte[] key)
{
    string initVector = &quot;RgUkXp2s5v8y/B?E&quot;;
                var ivBytes = Encoding.UTF8.GetBytes(initVector);
                var keyBytes = new byte[16];
                Array.Copy(key, keyBytes, Math.Min(keyBytes.Length, key.Length));
                string plaintext = null;
                // Create AesManaged    
                using (AesManaged aes = new AesManaged())
                {
                    aes.Padding = PaddingMode.PKCS7;
                    aes.Key = keyBytes;
                    aes.IV = ivBytes;
                    aes.BlockSize = 128;
                    aes.KeySize = 128;
                    aes.Mode = CipherMode.CBC;
                     
                    ICryptoTransform decryptor = aes.CreateDecryptor(keyBytes, ivBytes);
                   
                    
                    using (MemoryStream ms = new MemoryStream(Convert.FromBase64String(encryptedText)))
                    {
                       
                        using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                        {
                               
                            using (StreamReader reader = new StreamReader(cs))
                                plaintext = reader.ReadToEnd();
                        }
                    }
                }
                return plaintext;
}

String decryptedString = DecryptUtil.Decrypt_License(hashkey(string_key), stringToDecrypt);
</code></pre>
<p>I am converting java code to c#, encryption done in java now I am trying to decrypt the data in c# . I read PaddingMode.PKCS7 and PKCS5 both are same. Is it true? or should I change padding type?</p>
<p>I have used all the concepts which is used in java. but it is not working. Am I missing something?</p>
<p>I have doubt in Convert.FromBase64String(encryptedText), because this is the place they(java) have used value.getBytes(). getBytes() equivalent in c# is Convert.FromBase64String()? will they produce same result?</p>
<p>Java hashkey() method and C# hashkey method giving different results. How to compare them as byte[]?</p>
<p>If I change Convert.FromBase64String() to Encoding.UTF8.GetBytes() then it is throwing 'Length of the data to decrypt is invalid AES C#' error.</p>
<p>This is my encrypted text
wJZESOEPNb66FbnpB8DqmwLcyosxGOjzgPKa9+7/VUatEFxSs1YqS28HHU26EmCcZDo7otE5PvX/qIpgQgTrhlCHgUJBb0+qd522/1egYoisE48ZL8X3cwCNx1AOVYJ0T2VOLB+J3HDWK4HOJfgm2CqbQpep0ioOTgNKQA0SF3SRmF92MGbf7wjUBA8WGdeUiIKRX9Lm/x6mUUuXHEIrCHbZOqDZvo2xR9zndIzwT/FfgLsQbJQjRjZPg7urfWLpUt6drbYcPFm3KgTmSrsRhzk15P6mw3GNO+3BmqBIndKmzi8blQqG8YFXVW8wiaurCm0jVcX5kwdU1PO1ktHSXQ==</p>
<p>secret key used for encryption
BFEBFBFF000306D4</p>
"	NULL	8	NULL	15:26.1	0	26:01.5	49:46.4	NULL	9370429	9370429	0	1	0	<java><c#><encryption><aes>	Padding is invalid and cannot be removed - decryption in c# (encryption done in java)	419	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63653977	63657265	NULL	"<p>I have coded up a Java program which asks the user to specify a random secret key (in base 64 encoding), to specify the plaintext file to encrypt, and the name of the output file (the encrypted text file.)</p>
<p>Then the reverse to decrypt (secret key + input encrypted file + name of output decrypted file).</p>
<p>This follows the very similar behavior to what <a href=""https://www.openssl.org/"" rel=""nofollow noreferrer"">OpenSSL</a> offers.</p>
<p>My java code uses the mode <code>AES/CBC/PKCS5PADDING</code>.</p>
<p>I have appended my randomly generated initialization vector (16 byte IV), to my ciphertext beforehand using the file output stream. Then I believe the cipher output stream writes the ciphertext after the IV.</p>
<p>I can confirm that the generated and fetched IV from both the encrypt and decrypt method is the same (both can be printed out with base64 encoding, and will match).</p>
<p>The problem, however, lies with trying to decrypt the encrypted text. The decrypted text is able to show the second half of the encrypted text (which matches the second half of the original plain text).</p>
<p>Example:</p>
<p>Plain text: <code>my secret motto: i am awesome!</code></p>
<p>Cipher text: <code>&lt;lots of encrypted characters&gt;</code></p>
<p>Decrypted text: <code>&lt;a few encrypted characters&gt; i am awesome!</code></p>
<p>The first half though seems to be overwritten or perhaps collected some weird leftover encrypted text. This leads me to believe that something is not quite right with how I am encrypting/decrypting the IV using streams.</p>
<p>The relevant executed code is when the boolean <code>fileStoreIV</code> is true. The else code is for when the user provides both the key and IV as inputs.</p>
<p>Therefore <code>fout.write(initVector);</code> and <code>encryptedData.read(fileIV);</code> are the main bits of code.</p>
<p>Encryption method:</p>
<pre><code>private static void encrypt(byte[] key, byte[] initVector, String inputFile, String outputFile) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IOException {
    //Initalisation for encryption
    Cipher cipher = Cipher.getInstance(CIPHER);
    if(fileStoreIV) {
        SecretKeySpec skeySpec = new SecretKeySpec(key, ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    }
    else {
        IvParameterSpec iv = new IvParameterSpec(initVector);
        SecretKeySpec skeySpec = new SecretKeySpec(key, ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
    }
    
    //File error checking
    File loadFile = new File(inputFile);
    Path saveFile = Paths.get(outputFile);
    
    Path loadFilePath = Paths.get(inputFile);
    if (!Files.exists(loadFilePath)){
        System.out.println(&quot;The inputFile you specified does not exist&quot;);
        return;
    }
    
    Path parentDir = saveFile.getParent();
    if (parentDir != null &amp;&amp; !Files.exists(parentDir)) {
        System.out.println(&quot;The outputFile directory/s you specified does not exist&quot;);
        return;
    }
    
    System.out.println(&quot;Secret key is &quot; + Base64.getEncoder().encodeToString(key));
    System.out.println(&quot;IV is &quot; + Base64.getEncoder().encodeToString(initVector));

    //Special file reading and writing with 'Cipher Stream'
    try (InputStream fin = FileEncryptor.class.getResourceAsStream(loadFile.getName());
            OutputStream fout = Files.newOutputStream(saveFile);
            
            CipherOutputStream cipherOut = new CipherOutputStream(fout, cipher) {
    }) {
        final byte[] bytes = new byte[1024];
        for(int length=fin.read(bytes); length!=-1; length = fin.read(bytes)){
            
            
            if(fileStoreIV) {
                fout.write(initVector);
                fileStoreIV = false;
            }
            
            cipherOut.write(bytes, 0, length);
            
        }
    } catch (IOException e) {
        System.out.println(&quot;Something went wrong with reading and writing these files!&quot;);
        System.out.println(&quot;Please check you have the latest version of this program&quot;);
        System.out.println(&quot;Contact your IT admin to make sure you have sufficient privileges&quot;);
    }
    System.out.println(&quot;SUCCESS! Encryption finished, saved at specified location&quot;);
</code></pre>
<p>Decryption method:</p>
<pre><code>private static void decrypt(String inputKEY, String inputIV, String inputFile, String outputFile) throws NoSuchAlgorithmException, NoSuchPaddingException, IOException, InvalidKeyException, InvalidAlgorithmParameterException {
    //Initalisation for decryption
    Cipher cipher = Cipher.getInstance(CIPHER);
    if(!fileStoreIV) {
        IvParameterSpec iv = new IvParameterSpec(Base64.getDecoder().decode(inputIV));
        SecretKeySpec skeySpec = new SecretKeySpec(Base64.getDecoder().decode(inputKEY), ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
    }
    
    Path saveFile = Paths.get(outputFile);
    
    Path loadFilePath = Paths.get(inputFile);
    if (!Files.exists(loadFilePath)){
        System.out.println(&quot;The inputFile you specified does not exist&quot;);
        return;
    }
    
    Path parentDir = saveFile.getParent();
    if (parentDir != null &amp;&amp; !Files.exists(parentDir)) {
        System.out.println(&quot;The outputFile directory/s you specified does not exist&quot;);
        return;
    }
    
    InputStream encryptedData = Files.newInputStream(loadFilePath);
    
    if(fileStoreIV) {
        {
            byte[] fileIV = new byte[16];
            encryptedData.read(fileIV);
            System.out.println(Base64.getEncoder().encodeToString(fileIV));
                SecretKeySpec skeySpec = new SecretKeySpec(Base64.getDecoder().decode(inputKEY), ALGORITHM);
                cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(fileIV));
                fileStoreIV = false;
        }
    }
    
        try (CipherInputStream decryptStream = new CipherInputStream(encryptedData, cipher);    
        OutputStream decryptedOut = Files.newOutputStream(saveFile)){
        final byte[] bytes = new byte[1024];
        for(int length=decryptStream.read(bytes); length!=-1; length = decryptStream.read(bytes)){
            decryptedOut.write(bytes, 0, length);
        }
    } catch (IOException e) {
        System.out.println(&quot;Something went wrong with reading and writing these files!&quot;);
        System.out.println(&quot;Please check you have the latest version of this program&quot;);
        System.out.println(&quot;Contact your IT admin to make sure you have sufficient privileges&quot;);
    }
    
    System.out.println(&quot;SUCESS! Decryption finished, saved at specified location&quot;);
</code></pre>
<p>Additional note: when I add enough whitespaces before and inside the plain text file. I manage to shift enough of the text over, to get the decrypted file to display: <code>&lt;a few encrypted characters&gt; my secret motto: i am awesome!</code>.</p>
"	NULL	NULL	NULL	32:08.9	NULL	NULL	NULL	NULL	NULL	5280975	0	1	0	<java><encryption><cryptography><jce>	"Encrypt and decrypt a file with streams, using an appended initalisation vector java"	1183	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63811173	0	NULL	"<p>We are developing the ionc v3 based mobile app and we have to encrypt the password at front side and needs to decrypt the password at java middleware level. now ionic v3 we did sample encryption but the encrypted data not able to decrypt in our java. please advise as below ionic and java code, where we have to change it exactly.</p>
<p>ionic v3 AES 256 sample code</p>
<pre><code>import { Component } from '@angular/core';
import { NavController } from 'ionic-angular';
import { AES256 } from '@ionic-native/aes-256';
import { Platform } from 'ionic-angular/index';
import * as CryptoJS from 'crypto-js';
@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {
  text: string;
 private secureKey:string ;// Any string, the length should be 32
 private secureIV:string ;
 private password = &quot;test@123&quot;
 
  EncryptedData :string;
  constructor(public navCtrl: NavController, private aes256: AES256, private platform: Platform) {
 
   this.generateSecureKey(this.password);
  this.generateSecureIV(this.password);
  }
  

  generateSecureKey(password) {
    this.platform.ready().then(() =&gt; {
      this.aes256.generateSecureKey(password).then((secureKey)  =&gt; {
          this.secureKey = secureKey;
          console.log('Secure Key----', secureKey);          
        }, (error) =&gt; {
          console.log('Error----', error);
        });
    });
  }
  generateSecureIV(password) {
    this.platform.ready().then(() =&gt; {
      this.aes256.generateSecureIV(password).then((secureIV)  =&gt; {
        this.secureIV = secureIV;
          console.log('Secure Key----', secureIV);          
        }, (error) =&gt; {
          console.log('Error----', error);
        });
    });
  }
  encrypt() {
  this.platform.ready().then(() =&gt; {
   
  this.aes256.encrypt(this.secureKey, this.secureIV, this.text)
  
  .then(res =&gt;  {alert('Encrypted Data: '+res)
  console.log(&quot;Secure Key&quot; +this.secureKey);
  console.log(&quot;Secure Key&quot; +this.secureIV);
  this.EncryptedData = res;
  console.log(EncryptedData);
  })
  .catch((error: any) =&gt; console.error(error));
   });
 }
 decrypt() {
  this.platform.ready().then(() =&gt; {
  this.aes256.decrypt(this.secureKey, this.secureIV, this.EncryptedData)
  .then(res =&gt; { alert('Decrypted Data : '+res)
  console.log(&quot;Secure Key&quot; +this.secureKey);
  console.log(&quot;Secure Key&quot; +this.secureIV);
  
})
  .catch((error: any) =&gt; console.error(error));

});
 }
}
</code></pre>
<p>Java Code sample:</p>
<pre><code>package com.test.reactapi;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;


public class TestEncry {
    
    private static final String ENCRYPT_ALGO = &quot;AES/GCM/NoPadding&quot;;

    private static final int TAG_LENGTH_BIT = 128;

    private static final Charset UTF_8 = StandardCharsets.UTF_8;
    
    
    public static String encrypt(byte[] pText) throws Exception {
        String password = &quot;test@123&quot;;
        byte[] salt = getRandomNonce(32);
        byte[] iv = getRandomNonce(12);
        SecretKey aesKeyFromPassword = getAESKeyFromPassword(password.toCharArray(), salt);
        Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);
        cipher.init(1, aesKeyFromPassword, new GCMParameterSpec(TAG_LENGTH_BIT, iv));
        byte[] cipherText = cipher.doFinal(pText);
        byte[] cipherTextWithIvSalt = ByteBuffer.allocate(iv.length + salt.length + cipherText.length).put(iv).put(salt)
                .put(cipherText).array();
        return Base64.getEncoder().encodeToString(cipherTextWithIvSalt);
    }

    public static SecretKey getAESKeyFromPassword(char[] password, byte[] salt)
            throws NoSuchAlgorithmException, InvalidKeySpecException {

        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;SHA256&quot;);
        KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
        return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);

    }

    public static String decrypt(String cText) throws Exception {
        
        byte[] plainText = null;
        
        try {
        String password = &quot;test@123&quot;;
        byte[] decode = Base64.getDecoder().decode(cText.getBytes(UTF_8));
        ByteBuffer bb = ByteBuffer.wrap(decode);
        byte[] iv = new byte[12];
        bb.get(iv);
        byte[] salt = new byte[32];
        bb.get(salt);
        byte[] cipherText = new byte[bb.remaining()];
        bb.get(cipherText);
        SecretKey aesKeyFromPassword = getAESKeyFromPassword(password.toCharArray(), salt);
        Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);
        cipher.init(2, aesKeyFromPassword, new GCMParameterSpec(128, iv));
        plainText = cipher.doFinal(cipherText);
        
        } catch (Exception e) {
            e.printStackTrace();
        }
        return new String(plainText, UTF_8);
    
    }
    
    public static byte[] getRandomNonce(int numBytes) {
        byte[] nonce = new byte[numBytes];
        new SecureRandom().nextBytes(nonce);
        return nonce;
    }

    public static void main(String[] args) throws Exception {
    
            System.out.println(&quot;Decrypted pwd:&quot; + decrypt(&quot;kkkkkk/kllmnn==&quot;));
}
    
    

}
</code></pre>
<p>please advise and help us</p>
<p>error :</p>
<pre><code>java.nio.BufferUnderflowException
    at java.nio.HeapByteBuffer.get(HeapByteBuffer.java:151)
    at java.nio.ByteBuffer.get(ByteBuffer.java:715)
    at com.test.reactapi.TestEncry.decrypt(TestEncry.java:62)
    at com.test.reactapi.TestEncry.main(TestEncry.java:90)
Exception in thread &quot;main&quot; java.lang.NullPointerException
    at java.lang.String.&lt;init&gt;(String.java:515)
    at com.test.reactapi.TestEncry.decrypt(TestEncry.java:73)
    at com.test.reactapi.TestEncry.main(TestEncry.java:90)
</code></pre>
"	NULL	NULL	NULL	56:28.3	NULL	NULL	NULL	NULL	NULL	2878290	0	1	0	<java><ionic-framework><ionic3>	ionic v3 AES 256 algorithm to using encrypted not able to decrypt in java AES/GCM/noPadding algorithm	1106	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63864527	63864873	2	"<p>Is it normal that when decrypting AES-encoded encrypted text in CBC mode with an initialization vector different from the original, you get almost the original text?</p>
<p>I am attaching a complete example code, I did not create it but I took it from an online tutorial, I just modified the main to explain better and with an example what I mean:</p>
<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Main {
    private static final String key = &quot;aesEncryptionKey&quot;;
    private static String initVector = &quot;encryptionIntVec&quot;;

    public static String encrypt(String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
            byte[] original = cipher.doFinal(Base64.getDecoder().decode(encrypted));

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static void main(String[] args) {
        String originalString = &quot;password&quot;;
        System.out.println(&quot;Original String to encrypt - &quot; + originalString);
        String encryptedString = encrypt(originalString);
        System.out.println(&quot;Encrypted String with initVector: 'encryptionIntVec' - &quot; + encryptedString);

        String decryptedString = decrypt(encryptedString);
        System.out.println(&quot;Decrypted String with initVector: 'encryptionIntVec' - &quot; + decryptedString);
        //output: &quot;password&quot;

        initVector = &quot;dncryftionIntVec&quot;;
        String decryptedString2 = decrypt(encryptedString);
        System.out.println(&quot;Decrypted String with initVector: 'dncryftionIntVec' - &quot; + decryptedString2);
        //output: &quot;qasswyrd&quot;

    }
}
</code></pre>
<p>Output:</p>
<pre><code>Original String to encrypt - password
Encrypted String with initVector: 'encryptionIntVec' - AIDTAIiCazaQavILI07rtA==
Decrypted String with initVector: 'encryptionIntVec' - password
Decrypted String with initVector: 'dncryftionIntVec' - qasswyrd
</code></pre>
"	NULL	1	NULL	13:30.3	0	28:48.7	NULL	NULL	0	14059176	0	1	1	<java><encryption><base64><aes><cbc-mode>	"Almost getting the original text with different IVs, is it normal?"	212	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63920039	63926787	1	"<p>I have been working on cryptoJs for a week now but the issue I am facing is with Javascript. I am a newbie in Javascript and I really need your help.</p>
<p>I have the following cryptojs based java encryption/decryption codes which works perfectly fine but I am trying to have the Javascript equivalent.</p>
<p>I was getting different encryption.</p>
<p><strong>in java I got:</strong> <code>2BECE44E5375C690FE5785CA9C4814868D620F600AFFA14584B2B7E336742AEF9D52D4102962AD81E9A1267ED48A466B2B739E71FB3433CE9F4ED7661BFA3504C7BA70583E2BC315A1EEE89167F06309D6B3D1CF69DC1028F1396E58150483BF</code></p>
<p><strong>While in javascript I got:</strong> <code>2a478540c889da6bede186c21c7133d1</code></p>
<pre><code>import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.security.NoSuchAlgorithmException;
import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.security.sasl.SaslException;
import javax.security.*;

public class AESCrypter {
    private String iv = &quot;9%Ysr^xyBTrPr!$Y&quot;;
    private String secretkey = &quot;GnxUFjKw9(bk7Ay$&quot;;
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    public static void main(String args[]) throws UnsupportedEncodingException, Exception {
        AESCrypter crypta = new AESCrypter();
        //String toenc = &quot;1&quot;;
        String toenc = &quot; srcAccount:\&quot;0011295527\&quot;,\r\n&quot; + 
                &quot;requestId\&quot;:\&quot;12345678901234567890\&quot;,\r\n&quot; + 
                &quot;pin:\&quot;3019\&quot;&quot;;
        String enc = &quot;&quot;;
        String dec = &quot;&quot;;
        // encrypt the value
        //enc = crypta.encrypt(toenc);
        enc = crypta.encrypt(toenc);
        // encrypted value print out
        System.out.println(&quot; ENCED : &quot; + enc);
        // decrypt the value
        dec = crypta.decrypt(enc);
        // decrypted value print out
        System.out.println(&quot; DECED : &quot; + dec);
    }

    public AESCrypter(String keyz, String ivStr) {
        ivspec = new IvParameterSpec(ivStr.getBytes());
        keyspec = new SecretKeySpec(keyz.getBytes(), &quot;AES&quot;);
        try {
            cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    public AESCrypter()
    {
    ivspec = new IvParameterSpec(iv.getBytes());
    keyspec = new SecretKeySpec(secretkey.getBytes(), &quot;AES&quot;);
    System.out.println(&quot;this ivspec = &quot; + ivspec);
    try
    {
    cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    }
    catch (NoSuchAlgorithmException e)
    {
    e.printStackTrace();
    }
    catch (NoSuchPaddingException e)
    {
    e.printStackTrace();
    }}

    public String encrypt(String text) throws SecurityException {
        System.out.println(&quot;text = &quot; + text);
        if (text == null || text.length() == 0) {
            throw new SecurityException(&quot;Empty string&quot;);
        }
        byte[] encrypted = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            encrypted = cipher.doFinal(text.getBytes(&quot;UTF-8&quot;));
        } catch (Exception e) {
            throw new SecurityException(&quot;[encrypt] &quot; + e.getMessage());
        }
        return bytesToHex(encrypted);
    }

    public String decrypt(String code) throws SecurityException, UnsupportedEncodingException {
        if (code == null || code.length() == 0) {
            throw new SecurityException(&quot;Empty string&quot;);
        }
        byte[] decrypted = null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e) {
            e.printStackTrace();
            throw new SecurityException(&quot;[decrypt] &quot; + e.getMessage());
        }
        return new String(decrypted, &quot;UTF-8&quot;);
    }

    public static String bytesToHex(byte[] data)
    {
    if (data==null) {
    return null;
    }
    int len = data.length;
    String str = &quot;&quot;;
    for (int i=0; i&lt;len; i++)
    {
    

    if ((data[i]&amp;0xFF)&lt;16) {
    str = str + &quot;0&quot; + java.lang.Integer.toHexString(data[i]&amp;0xFF);
    }
    else {
    str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
    }}return str;

    }

    public static byte[] hexToBytes(String str) {
        if (str == null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i = 0; i &lt; len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);
            }
            return buffer;
        }
    }
}
</code></pre>
<p>Trying to solve it in Javascript I did the following:</p>
<pre><code>      let iv = &quot;tzsee5eWyBlpTHSn&quot;;
        let secret_key = &quot;IhrhcWT@HsH!l6#M&quot;;
        let body = {&quot;srcAccount&quot; : user_login, 
                    &quot;requestId&quot; : &quot;12345678901234567890&quot;,
                    &quot;pin&quot; : user_password};
        
    
    body = CryptoJS.enc.Utf8.parse(body);
    secret_key = CryptoJS.enc.Latin1.parse(secret_key);
    iv = CryptoJS.enc.Latin1.parse(iv);
    
    var encrypted = CryptoJS.AES.encrypt(body, secret_key, { iv: iv, 
    padding: CryptoJS.pad.Pkcs7, 
    mode: CryptoJS.mode.CBC
});

var encrypted = CryptoJS.enc.Hex.parse(iencrypted.ciphertext.toString());
console.log(&quot; Encrypted  &quot; +encrypted);
</code></pre>
<p>Could someone please point me to the right direction.</p>
"	NULL	5	NULL	25:00.6	1	36:26.0	36:26.0	NULL	319826	12872822	0	1	0	<javascript><java><encryption>	How to get java equivalent of encryptJs in javascript	165	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
63961511	0	0	"<p>I'm trying to encrypt a 512 Mb file with AES/CBC algorithm. It is taking around 7 sec which is too much. How to reduce the encryption time and make it faster.</p>
<p>I'm using a fixed key and tried using CipherOutStream as well as cipher.update() instead of cipher.dofinal(). Still, it is taking around 7 secs.</p>
<p>How much time generally it would take to encrypt a 512 MB file with the below encryption. It is taking 6 seconds for me on a Mac with 16 GB memory and 2 GHz Quad-Core Intel Core i5 processor. I'm using JDK 11 for execution. Is it normal or my code is responding slow. Should I be concerned? How to improve the time for encryption.</p>
<pre><code>package com.encrypterdecrypter;

import org.apache.commons.io.output.ByteArrayOutputStream;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.io.ClassPathResource;

import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.SecretKeySpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;

@SpringBootApplication
public class DemoApplication {
    private static final String SECRET_KEY = &quot;aesencryptionKey&quot;;
    private static final String initVector = &quot;encryptionIntVec&quot;;

    public static void main(String[] args) throws Exception {
        SpringApplication.run(DemoApplication.class, args);
        File inputFile = new ClassPathResource(&quot;fivetwelvemb.zip&quot;).getFile();
        InputStream inputStream = new FileInputStream(inputFile);
        SecretKeySpec secretkey = new SecretKeySpec(SECRET_KEY.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);


        long startTime = System.currentTimeMillis();
        OutputStream encryptStream = encryptDecryptBinary(inputStream, Cipher.ENCRYPT_MODE, secretkey);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Encryption Time in ms : &quot; + (endTime - startTime));

    }

    public static OutputStream encryptDecryptBinary(InputStream inputStream, int encryptMode, SecretKeySpec secretkey) throws Exception {
        Cipher aesCipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        aesCipher.init(encryptMode, secretkey);
        OutputStream out =  new ByteArrayOutputStream();
        CipherOutputStream cipherOutputStream = new CipherOutputStream(out, aesCipher);

       /* byte[] encryptedData = aesCipher.doFinal(inputStream.readAllBytes()); */

        byte[] buf = new byte[8192];
        int numRead = 0;
        while ((numRead = inputStream.read(buf)) &gt;= 0) {
            cipherOutputStream.write(buf, 0, numRead);
        }
        cipherOutputStream.close();
        return out;
    }
}
<span class=""math-container"">```</span>
</code></pre>
"	NULL	8	NULL	02:51.8	0	46:03.9	30:47.1	NULL	2670892	6884109	0	1	3	<java><encryption><aes><aes-gcm>	Java large file AES Encryption is very slow	374	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64032705	0	1	"<p>I am using Java to encrypt a text payload with Triple DES. First I create an ephemeral key that I will use for encrypting the payload:</p>
<pre><code>private byte[] createEphemeralKey() throws Exception {
    KeyGenerator keygen = KeyGenerator.getInstance(&quot;DESede&quot;);
    keygen.init(168);
    return keygen.generateKey().getEncoded();
}
</code></pre>
<p>Then I encrypt my payload with said key:</p>
<pre><code>private String encryptTripleDES(byte[] ephemeralKey, String payload) throws Exception {

    Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/NoPadding&quot;);
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(ephemeralKey, &quot;DESede&quot;));

    byte[] plainTextBytes = payload.getBytes();
    byte[] cipherText = cipher.doFinal(plainTextBytes);
    return Base64.getEncoder().encodeToString(cipherText);
}
</code></pre>
<p>Also need a padding function to ensure the data length is divisable by 8:</p>
<pre><code>private String adjustPadding(String input, int blockSize) {

    int len = input.length() % blockSize;
    int paddingLength = (len == 0) ? 0 : (blockSize - len);

    while (paddingLength &gt; 0) {
        input += &quot;F&quot;;
        paddingLength--;
    }

    return input;
}
</code></pre>
<p>And here is my process end to end:</p>
<pre><code>String data = &quot;Marnus&quot;
byte[] = ephemeralKey = createEphemeralKey();

String adjustedData = adjustPadding (data,8);

String encryptedPayload = encryptTripleDES(ephemeralKey, adjustedData);

String encodedKey = Base64.getEncoder().encodeToString(ephemeralKey)
</code></pre>
<p>So I take the 2 variables <code>encryptedPayload</code> and <code>encodedKey</code>, that are both Base64 encoded string, and send it off via HTTP to node express app.</p>
<p>In the Javascript side of things, I use <a href=""https://www.npmjs.com/package/node-forge#cipher"" rel=""nofollow noreferrer"">node-forge</a> - Here is the part of my express app that does the decryption:</p>
<pre><code>let nodeBuffer = Buffer.from(data, 'base64')    
let input = forge.util.createBuffer(nodeBuffer.toString('binary'))

// 3DES key and IV sizes
let keySize = 24;
let ivSize = 8;

let derivedBytes = forge.pbe.opensslDeriveBytes(ephemeralKey, null, keySize + ivSize);
let buffer = forge.util.createBuffer(derivedBytes);
let key = buffer.getBytes(keySize)
let iv = buffer.getBytes(ivSize)

let decipher = forge.cipher.createDecipher('3DES-ECB', key)
decipher.start({iv: iv})
decipher.update(input)
console.log('decipher result', decipher.finish())

let decryptedResult = decipher.output.data;
</code></pre>
<p>Here is an Triples DES example in the node-forge docs:
<a href=""https://i.stack.imgur.com/Dkejd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Dkejd.png"" alt=""enter image description here"" /></a></p>
<p><strong>A few notes:</strong>
I create a node-forge buffer from a regular buffer since I don't have a input file like the examples gives. Here is how the docs states one should create one buffer from the other:
<a href=""https://i.stack.imgur.com/uAwyD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uAwyD.png"" alt=""enter image description here"" /></a></p>
<p>*I use base64 as that is what I used in the java side to encode the data that was sent.</p>
<p>Then, I dont have a salt so I left the 2'nd param <code>null</code> in <code>opensslDeriveBytes</code> as specified in the docs I should do.</p>
<p>Thirdly, I am also not sure if my keysize of 24 is correct?</p>
<p><strong>My results</strong></p>
<p>So doing an end to end test yields the following:</p>
<p>In my Java app, the test data was <code>&quot;Marnus&quot;</code>, the <code>encryptedPayload</code> was <code>ez+RweSAd+4=</code> and the <code>encodedKey</code> was <code>vCD9mBnWHPEBiQ0BGv7gc6GUCOoBgLCu</code>.</p>
<p>Then in my javascript code <code>data</code> was obviously <code>ez+RweSAd+4=</code>(encryptedPayload) and the <code>ephemeralKey</code> was <code>vCD9mBnWHPEBiQ0BGv7gc6GUCOoBgLCu</code>(encodedKey).</p>
<p>After the decryption ran, the value of <code>decryptedResult</code> was <code>©ýÕ?µ{'</code>, which is obviously just garbage since it was not encoded yet, but I cant figure out which encoding to use?</p>
<p>I tried using <code>forge.util.encode64(decipher.output.data)</code>, but that just gave me <code>qf3VP7UYeyc=</code>, which is not right.</p>
<p>For what it's worth, <a href=""https://imgur.com/a/aID3rwg"" rel=""nofollow noreferrer"">here is the type</a> that <code>decipher.output</code></p>
"	NULL	3	NULL	50:28.0	1	24:14.9	29:06.3	NULL	2670576	2670576	0	1	0	<javascript><java><node.js><encryption><tripledes>	TripleDES Java Encryprion to Javascript Decryption	552	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64460457	0	0	"<p>I've been trying to do AES_GCM encryption in Python and decryption in Java, below is the relevant code snippet for what I'm trying to accomplish, I have also checked the question at: <a href=""https://stackoverflow.com/questions/50396221/pycrypto-aes-gcm-encryption-and-java-decryption"">Pycrypto AES GCM encryption and Java decryption</a> this is similar to my problem. I am suspecting that the IV/nonce I set for Python is incorrect, any help would be greatly appreciated.</p>
<p>Python Encryption Code:</p>
<pre><code>from Crypto.Cipher import AES
from base64 import b64encode
someKey = 'Sixteen byte key'
cipher = AES.new(someKey, AES.MODE_GCM, nonce='0000000000000000', mac_len=16)
ciphertext, tag = cipher.encrypt_and_digest(data)
ciphertext = ciphertext + tag
print b64encode(ciphertext)
</code></pre>
<p>Java Decryption Code:</p>
<pre><code>private static byte[] initializationVector = new byte[16];


Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;); 
 
SecretKeySpec keySpec = new SecretKeySpec(someKey, &quot;AES&quot;); 

GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, initializationVector);  
     
cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmParameterSpec);

byte[] bytesString = Base64.getDecoder().decode(theString);  
 
return new String(cipher.doFinal(bytesString), &quot;UTF-8&quot;);
</code></pre>
<p>I am however unable to decrypt this in Java, I get the following error:</p>
<pre><code>javax.crypto.AEADBadTagException: Tag mismatch!
at java.base/com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:623)
at java.base/com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1116)
at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1053)
at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2202)
</code></pre>
"	NULL	5	NULL	18:43.8	0	38:54.9	38:54.9	NULL	2172649	2172649	0	1	0	<java><encryption><aes-gcm><pycryptodome>	Pycryptodome AES_GCM Encryption to Java Decryption	445	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64505267	64507126	1	"<p>When I initialize a Cipher object with the default AES/GCM algorithm, it has a reandom 12 bytes IV but the first 4 byte does not get incremented ater doFinal is called and throws the <em>java.lang.IllegalStateException: Cannot re-use same key and IV for multiple encryptions</em> exception.</p>
<pre><code>SecretKey secretKey = ...

final Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
cipher.init(Cipher.ENCRYPT_MODE, secretKey);

byte[] iv1 = encCipher.getIV();
byte[] ctext = encCipher.doFinal(&quot;a&quot;.getBytes());
      
cipher.update(&quot;b&quot;.getBytes());
byte[] iv2 = encCipher.getIV();
ctext = encCipher.doFinal();
</code></pre>
"	NULL	5	NULL	09:29.7	0	23:10.1	NULL	NULL	0	14507326	0	1	1	<java><android><security><encryption><aes-gcm>	Java AES/GCM/NoPadding encryption does not increment the counter of the IV after doFinal	1422	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64660813	64661905	1	"<p>I have problem with AES GCM Encryption on Swift
We have app on Java, where encryption is ok, server can read and process data, but my result server can not read
We have 2 different results.
At first I tried to use encryption CBC and ECB, but they told I should to use GCM.
If someone understand what I doing wrong, help me</p>
<p>Java code:</p>
<pre><code>final String airSecretKey = &quot;Wk+Uzyyn8991w/2V5OIqiQ==&quot;;
static Cipher cipher=null;
SecretKeySpec new_key=null;
Key kateKey=null;

public void onCreate() {
    super.onCreate();
    handler = new Handler();
    if (doCryptoAes) {
        new_key = new SecretKeySpec(airSecretKey.getBytes(), &quot;AES&quot;);
        kateKey = (Key) new SecretKeySpec(airSecretKey.getBytes(), &quot;AES&quot;);
    }
}

void generateCliper(){
    try {
        cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);  ///&quot;, &quot;BC
    } catch (NoSuchAlgorithmException e) {
        Log.e(&quot;AES 1&quot;, e.toString());
    } catch (NoSuchPaddingException e) {
        Log.e(&quot;AES 2&quot;, e.toString());
    } /*catch (NoSuchProviderException e) {
        Log.e(&quot;AES 3&quot;, e.toString());
    }*/
}

protected String encryptAir(String testText) {
    byte[] encodedBytes = null;
    String s_encode_result = &quot;&quot;;
    try {
        byte[] iv = new byte[12];
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
        if (cipher==null){  
             generateCliper();  
        }
        cipher.init(Cipher.ENCRYPT_MODE, kateKey, ivParameterSpec); //new_key  //
        encodedBytes = cipher.doFinal(testText.getBytes());
        for (int i=0;i&lt;encodedBytes.length; i++){
            s_encode_result+=getEncodeHex(encodedBytes[i]);//+&quot; &quot;;
        }

    } catch (Exception e) {
        Log.e(e.toString());
    }

    return &quot;&lt;BJSN&gt;&quot;+s_encode_result+&quot;&lt;/BJSN&gt;&quot;;
}

protected String decryptAir(String encodedText) {
    if (encodedText.length()&lt;20) return &quot;&quot;;

    byte[] encryptedTextByte = getConvAES(encodedText);
            //Base64.decode(encodedText, Base64.DEFAULT);


    byte[] iv = new byte[12];
    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
    try {
        cipher.init(Cipher.DECRYPT_MODE, kateKey, ivParameterSpec);

    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    }

    byte[] decryptedByte = new byte[0];
    try {
        decryptedByte = cipher.doFinal(encryptedTextByte);
    } catch (BadPaddingException e) {
        Log.e(&quot;AES 1&quot;, e.toString());
    } catch (IllegalBlockSizeException e) {
        Log.e(&quot;AES 2&quot;, e.toString());
    }
    String decryptedText = new String(decryptedByte);
  //  MainActivity.toast_str=&quot;Decrypted: &quot;+decryptedText;
    return  decryptedText;
}

byte[] getConvAES(String textAesStr) {
    int i_len = (textAesStr.length()-13)/2;
    byte[] aesNonce= new byte[i_len];
    if (textAesStr.indexOf( &quot;&lt;BJSN&gt;&quot;) == 0 &amp;&amp;
            textAesStr.indexOf( &quot;&lt;/BJSN&gt;&quot;) &gt; 0 &amp;&amp; i_len &gt; 0) {
        for (int i = 3; i &lt; i_len+3; i++) {
            String s_hex = &quot;&quot;;
            s_hex+=textAesStr.charAt(i*2);
            s_hex+=textAesStr.charAt(i*2+1);
            int i_binary=0;
            try {
                i_binary=Integer.parseInt(s_hex, 16);
                aesNonce[i-3]=(byte) i_binary;
            } catch (Exception e) {
                aesNonce[i-3]=0;
            }
        }
    }
    return aesNonce;
}
</code></pre>
<p>My Swift Code:</p>
<pre><code>import CryptoKit
let key = SymmetricKey(size: .bits192)
let plain = &quot;BSD AIR&quot;

func cryptoDemoCombinedData() {

    let nonce = try! AES.GCM.Nonce(data: Data(base64Encoded: &quot;fv1nixTVoYpSvpdA&quot;)!)
    let tag = Data(base64Encoded: &quot;Wk+Uzyyn8991w/2V5OIqiQ==&quot;)!

    // Encrypt
    let sealedBox = try! AES.GCM.seal(plain.data(using: .utf8)!, using: key, nonce: nonce, authenticating: tag)

    // Decrypt
    let sealedBoxRestored = try! AES.GCM.SealedBox(combined: sealedBox.combined!)
    let decrypted = try! AES.GCM.open(sealedBoxRestored, using: key, authenticating: tag)

    print(&quot;Crypto Demo II\n\n&quot;)
    print(&quot;Combined:\n\(sealedBox.combined!.base64EncodedString())\n&quot;)
    print(&quot;Cipher:\n\(sealedBox.ciphertext.base64EncodedString())\n&quot;)
    print(&quot;Nonce:\n\(nonce.withUnsafeBytes { Data(Array($0)).base64EncodedString() })\n&quot;)
    print(&quot;Tag:\n\(tag.base64EncodedString())\n&quot;)
    print(&quot;Decrypted:\n\(String(data: decrypted, encoding: .utf8)!)\n&quot;)
}

</code></pre>
"	NULL	11	NULL	15:44.2	1	41:06.9	24:07.4	NULL	14569710	14569710	0	1	0	<java><swift><encryption><aes><aes-gcm>	Swift AES encryption with Java	551	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64698127	0	0	"<p>I am using aes encryption to encrypt the pdf file it encrypts the file without any error but it is giving some error of parameters missing during the decryption of the pdf file.</p>
<p>my code is for encryption and decryption is</p>
<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;

public class Encrypt {
    public static void main(String[] args) {
        try{

//            encryptWitEcb(&quot;src//d.pdf&quot; , &quot;src//d.enc.pdf&quot; , &quot;f1dda0fc3b96f6d0&quot;.getBytes());
            decryptWithEcb(&quot;src//d.enc.pdf&quot; , &quot;src//d.dec.pdf&quot; ,&quot;f1dda0fc3b96f6d0&quot;.getBytes());
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public static void encryptWitEcb(String filenamePlain, String filenameEnc, byte[] key) throws Exception{
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        try (FileInputStream fis = new FileInputStream(filenamePlain);
             BufferedInputStream in = new BufferedInputStream(fis);
             FileOutputStream out = new FileOutputStream(filenameEnc);
             BufferedOutputStream bos = new BufferedOutputStream(out)) {
            byte[] ibuf = new byte[1024];
            int len;
            while ((len = in.read(ibuf)) != -1) {
                byte[] obuf = cipher.update(ibuf, 0, len);
                if (obuf != null)
                    bos.write(obuf);
            }
            byte[] obuf = cipher.doFinal();
            if (obuf != null)
                bos.write(obuf);
        }
    }

    public static void decryptWithEcb(String filenameEnc, String filenameDec, byte[] key) throws Exception
            {
        try (FileInputStream in = new FileInputStream(filenameEnc);
             FileOutputStream out = new FileOutputStream(filenameDec)) {
            byte[] ibuf = new byte[1024];
            int len;
            Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            while ((len = in.read(ibuf)) != -1) {
                byte[] obuf = cipher.update(ibuf, 0, len);
                if (obuf != null)
                    out.write(obuf);
            }
            byte[] obuf = cipher.doFinal();
            if (obuf != null)
                out.write(obuf);
        }
    }
}

</code></pre>
<p>the error occurred during decryption is</p>
<pre><code>java.security.InvalidKeyException: Parameters missing
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:469)
    at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:313)
    at javax.crypto.Cipher.implInit(Cipher.java:805)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:867)
    at javax.crypto.Cipher.init(Cipher.java:1252)
    at javax.crypto.Cipher.init(Cipher.java:1189)
    at Encrypt.decryptWithEcb(Encrypt.java:46)
    at Encrypt.main(Encrypt.java:11)
</code></pre>
<p>how can I solve it?</p>
"	NULL	4	NULL	22:56.7	0	22:56.7	NULL	NULL	0	14285912	0	1	0	<java><encryption><aes>	error during decryption of pdf file in java	85	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
64776944	64777345	1	"<p>I'm implementing the following steps:</p>
<ol>
<li>Bob encrypts a message with AES</li>
<li>Bob encodes the encryption to a base64 string</li>
<li>Bob writes the string to a file</li>
<li>Alice reads the file</li>
<li>Alice converts the string to byte</li>
<li>Alice decrypts the message</li>
</ol>
<p>However, I'm failing at the last step.</p>
<p>Heres the encryption:</p>
<pre><code>public void sendHelloWorld() {
    String msg = &quot;hello world!&quot;;
    try {
        SecretKeySpec AesKeySpec = new SecretKeySpec(aesKeyBytes, &quot;AES&quot;);
        Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        c.init(Cipher.ENCRYPT_MODE, AesKeySpec);
        aesEncryptedHello = c.doFinal(msg.getBytes());
    } catch (BadPaddingException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException | NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    String s = new String(aesEncryptedHello, StandardCharsets.UTF_8);
    System.out.println(&quot;Message = &quot; + s);
    sendMessage(Base64.getEncoder().encodeToString(aesEncryptedHello));
}
</code></pre>
<p>Here's the decrypt:</p>
<pre><code>public void decryptAESMessage(byte[] encryptedMessage) {
    try {
        String s = new String(encryptedMessage, StandardCharsets.UTF_8);
        System.out.println(&quot;Message = &quot; + s);
        SecretKeySpec AesKeySpec = new SecretKeySpec(bobAesKey, &quot;AES&quot;);
        Cipher c = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        c.init(Cipher.DECRYPT_MODE, AesKeySpec);
        byte[] aesMessage = c.doFinal(encryptedMessage);
        String message = new String(aesMessage, StandardCharsets.UTF_8);
        System.out.println(&quot;Message is &quot; + message);
    } catch (BadPaddingException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException | NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    
}
</code></pre>
<p>Here's the write to file:</p>
<pre><code>public void sendMessage(String msg) {
    try {
        
        FileWriter myWriter = new FileWriter(&lt;myredactedfilepath&gt;);
        myWriter.write(msg);
        myWriter.close();
    } catch (IOException e) {
        System.out.println(&quot;An error occurred.&quot;);}
}
</code></pre>
<p>Here's stage 5, just to show the decode isn't missed:</p>
<pre><code>alice.decryptAESMessage(Base64.getDecoder().decode(alice.readEncryptedMessage()));
</code></pre>
<p>I print the keys and the encrypted messages at both ends and they match.</p>
"	NULL	6	NULL	21:58.7	0	10:23.5	10:23.5	NULL	1820553	8271065	0	1	2	<java><encryption><cryptography><base64><aes>	AES Decryption when writing to a file using base64 encoding	99	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65011962	0	1	"<p>getInstance returns NoSuchAlghoritmExeptoin, although when checked by the operator, one of them is AndroidOpenSSL: Cipher. AES/ECB/PKCS5Padding</p>
<pre><code>    Cipher cipher;
    cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
</code></pre>
"	NULL	0	NULL	05:36.8	0	29:33.9	NULL	NULL	0	13203879	0	1	3	<java><android>	NoSuchAlghoritmExeption when you call the java cipher.getinstance()	40	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65065499	65065875	1	"<p>I am trying to create a cipher in order to encode an AES key that I have created. I had read in a public key from a file that I stored the public key in and converted it from bytes to a public key object. When I try to initilize the cipher using this public key, I get the error &quot;No installed provider supports this key: sun.security.rsa.RSAPublicKeyImpl&quot; at <code>      cipherAES.init(Cipher.ENCRYPT_MODE, DecodedPublicKey);</code></p>
<p>So when I create a RSA 2048 key generator object to get the provider, which is the specifications I used in order to create the previous key in another program, I get the error &quot;No such algorithm: AES/GCM/NoPadding&quot; at <code>Cipher cipherAES = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;, kpgenProv.getName());</code></p>
<p>I need to use the transformation AES/GCM/NoPadding, and the provider that is being given from the .getProvider seems to be right, which is SunRsaSign. Does anyone have any insight into this problem? It recognizes the transformation fine when there is no provider, but rejects it when there is a provider.</p>
<pre><code>      String pubAlgo = publicKeyScanner.nextLine(); // not used
      String PublicKey = publicKeyScanner.nextLine(); // this will stop when it hits a newline and the encoded key may have the newline char value causing the private key to be piecemeal
      byte[] decodedPublicKey = Base64.getDecoder().decode(PublicKey);
      KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;); // or &quot;EC&quot; or whatever
      PublicKey DecodedPublicKey = kf.generatePublic(new X509EncodedKeySpec(decodedPublicKey));
      publicKeyScanner.close();
      System.out.println(DecodedPublicKey.toString());
    
      KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;);
      keyGen.init(128); // for example
      SecretKey AESKey = keyGen.generateKey();

      KeyPairGenerator kpgen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
      kpgen.initialize(2048);
      Provider kpgenProv = kpgen.getProvider();
      System.out.println(kpgenProv.getName());
      Cipher cipherAES = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;, kpgenProv.getName());
      cipherAES.init(Cipher.ENCRYPT_MODE, DecodedPublicKey);
      byte[] AESKEYBYTES = AESKey.getEncoded();```
</code></pre>
"	NULL	1	NULL	42:52.0	0	26:29.4	NULL	NULL	0	9105530	0	1	0	<java><encryption><rsa>	No installed provider supports this key: sun.security.rsa.RSAPublicKeyImpl and No such algorithm: AES/GCM/NoPadding	1328	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65071090	65072352	NULL	"<p>I want to encrypt data with NodeJS and then decrypt the data with Java. I searched a lot of examples on the Internet, but did not find a suitable answer.
The NodeJS code is as follows:</p>
<pre><code>const crypto = require('crypto');

function encrypt(content) {
    const salt = crypto.randomBytes(cryptoConfig.saltLength);
    const iv = crypto.randomBytes(cryptoConfig.ivLength);
    const key = crypto.pbkdf2Sync(cryptoConfig.masterKey, salt, cryptoConfig.iterations, 
    cryptoConfig.keyLength, cryptoConfig.digest);
    const cipher = crypto.createCipheriv(cryptoConfig.cipherAlgorithm, key, iv);

    const encrypted = Buffer.concat([cipher.update(content, 'utf8'), cipher.final()]);

    const tag = cipher.getAuthTag();

    const encdata = Buffer.concat([salt, iv, tag, encrypted]).toString('base64');
    return encdata;
}

const cryptoConfig = {
    cipherAlgorithm: 'aes-256-gcm',
    masterKey: 'sfcpnnjFG6dULJfo1BEGqczpfN0SmwZ6bgKO5FcDRfI=',
    iterations: 65535,
    keyLength: 32,
    saltLength: 16,
    ivLength: 12,
    tagLength: 16,
    digest: 'sha512'
}
</code></pre>
<p>const encryptedData = encrypt('hello world');
console.log('encrypt data -&gt;', encryptedData);</p>
<p>JAVA Code:</p>
<pre><code>private static final Charset UTF_8 = StandardCharsets.UTF_8;
private static final String CIPHER_ALGORITHM = &quot;AES/GCM/NoPadding&quot;;

private static final int TAG_LENGTH = 16;
private static final int IV_LENGTH = 12;
private static final int SALT_LENGTH = 16;
private static final int KEY_LENGTH = 16;
private static final int ITERATIONS = 65535;

public static String decrypt(String cipherContent, String password) throws Exception {
    byte[] decode = Base64.getDecoder().decode(cipherContent.getBytes(UTF_8));
    ByteBuffer bb = ByteBuffer.wrap(decode);
    byte[] salt = new byte[SALT_LENGTH];
    bb.get(salt);
    byte[] iv = new byte[IV_LENGTH];
    bb.get(iv);
    byte[] content = new byte[bb.remaining()];
    bb.get(content);

    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
    SecretKey aesKeyFromPassword = getAESKeyFromPassword(password.toCharArray(), salt);
    cipher.init(Cipher.DECRYPT_MODE, aesKeyFromPassword, new GCMParameterSpec(TAG_LENGTH * 8, iv));

    byte[] plainText = cipher.doFinal(content);
    return new String(plainText, UTF_8);
}

private static SecretKey getAESKeyFromPassword(char[] password, byte[] salt)
        throws NoSuchAlgorithmException, InvalidKeySpecException {
    SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA512&quot;);
    KeySpec spec = new PBEKeySpec(password, salt, ITERATIONS, KEY_LENGTH * 8);
    SecretKey secret = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
    return secret;
}

public static void main(String[] args) throws Exception {
    String masterKey = &quot;sfcpnnjFG6dULJfo1BEGqczpfN0SmwZ6bgKO5FcDRfI=&quot;;
    String encryptedData = &quot;&lt;NodeJS return encryptedData&gt;&quot;;
    String decryptedText = decrypt(encryptedData, masterKey);
    System.out.println(&quot;Decrypted: &quot; + decryptedText));
}
</code></pre>
<p>After execution, throw an exception:</p>
<pre><code>Exception in thread &quot;main&quot; javax.crypto.AEADBadTagException: Tag mismatch!
    at com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:571)
    at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1046)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:983)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:845)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at javax.crypto.Cipher.doFinal(Cipher.java:2165)
    at com.xxx.common.AesCrypto.decrypt(AesCrypto.java:92)
    at com.xxx.common.AesCrypto.main(AesCrypto.java:131)
</code></pre>
<p>how can I change to make this scene run through</p>
"	NULL	NULL	NULL	37:34.0	NULL	NULL	NULL	NULL	NULL	10866523	0	1	3	<java><node.js><aes-gcm>	"AES/GCM/NoPadding encrypt from node and decrypt on java, throw AEADBadTagException: Tag mismatch"	3368	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65106860	0	0	"<p>my code generates two different values for the same target text in two differents servers,</p>
<p>this is my code :</p>
<pre><code>private static Key generateKey() throws Exception {
    MessageDigest digester = MessageDigest.getInstance(&quot;MD5&quot;);
    digester.update(String.valueOf(keyValue).getBytes(&quot;UTF-8&quot;));
    Key key = new SecretKeySpec(digester.digest(), &quot;AES&quot;);
    return key;
}
</code></pre>
<p>encrypt code :</p>
<pre><code>    Key key = generateKey();
    Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    c.init(Cipher.ENCRYPT_MODE, key);
</code></pre>
<p>if you have any ideas, thanks in advance</p>
"	NULL	9	NULL	07:45.2	1	07:45.2	NULL	NULL	0	5129906	0	1	0	<java><encryption><jvm><aes>	Issue with AES encryption different result in Java app runing in 2 servers (2 JVMs)?	106	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65131400	0	0	"<p>I am writing a program that encrypts and decrypts a directory of files and replaces them with the ciphered files. So far, the program works when there is a single file in the directory, but past that, it will not encrypt anything else. The program complains that the same key or iv is being used, but we want to use the same cipher for the encryption of all the files in the directory, and Cipher.dofinal should reset the cipher back to the initial state, according to the documentation. There is other code pertaining to the creation of the AES key, and etc. but that seems to be working fine. Does anyone have any ideas what is causing this problem?</p>
<pre><code>      //Creates Cipher and encodes with the AES key
      Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
      cipher.init(Cipher.ENCRYPT_MODE, AESKey, spec);
      //write all files to directory
      File dir = new File(directory);
      if (dir.isDirectory()) {
        EncryptDirectory(dir, cipher);
      } else {
        System.out.println(&quot;Error: Directory Invalid&quot;);
        return;
      }
    }
  }
  static public void EncryptDirectory(File dir, Cipher cipher) throws Exception {
    String[] pathnames;
    pathnames = dir.list();
    for (String pathname : pathnames) {
      File dirFile = new File(dir.getAbsolutePath() + &quot;/&quot;+ pathname);
      if (dirFile.isDirectory()) {
        EncryptDirectory(dirFile, cipher);
      } else if (pathname.equals(&quot;keyfile&quot;) || pathname.equals(&quot;keyfile.sig&quot;)) {
        continue;
      } else {
        String newFile = dir.getAbsolutePath() + &quot;/&quot; + dirFile.getName() + &quot;.ci&quot;; // Not sure what this will be.
        // Error checking if file exists
        File newFileCreate = new File(newFile);
        if (!newFileCreate.createNewFile()) {
          newFileCreate.delete();
          newFileCreate.createNewFile();
        }
        FileOutputStream cipherFile = new FileOutputStream(newFileCreate);
        FileInputStream in = new FileInputStream(dir.getAbsolutePath() + &quot;/&quot;+ pathname);
        byte[] ibuf = new byte[1024];
        int len;
        while ((len = in.read(ibuf)) != -1) {
          byte[] obuf = cipher.update(ibuf, 0, len);
          if ( obuf != null ) {
            cipherFile.write(obuf);
          }
        }
        cipherFile.write(cipher.doFinal());
        cipherFile.close();
        in.close();
        if (!dirFile.delete()) {
          System.out.println(&quot;Error in deleting file.&quot;);
        }
      }
    }
</code></pre>
"	NULL	2	NULL	51:45.7	0	51:45.7	NULL	NULL	0	9105530	0	1	0	<java><encryption><aes-gcm>	Cipher only encrypts one file in the directory	42	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65178776	0	1	"<p>I use PHP to encrypt use AES/GCM to communicate with JAVA?but it does not work? This is the code?I don't know where is the wrong?</p>
<pre class=""lang-php prettyprint-override""><code>&lt;?php

$key = &quot;123456789012345678901234567890&quot;;
$plaintext = &quot;aaaaaaa&quot;;
$encryptStr = aesGcmEncrypt($plaintext, $key);
echo &quot;????&quot; . $encryptStr;


function aesGcmEncrypt($plaintext, $key)
{

    $ivlen = openssl_cipher_iv_length($cipher = &quot;aes-128-gcm&quot;);
    $iv = openssl_random_pseudo_bytes($ivlen);
    $ciphertext_raw = openssl_encrypt($plaintext, $cipher, $key, OPENSSL_NO_PADDING, $iv, $tag);
    $ciphertext = base64_encode($iv . $ciphertext_raw . $tag);
    return $ciphertext;
}

function decrypt($str, $key)
{
    $encrypt = base64_decode($str);
    $ivlen = openssl_cipher_iv_length($cipher = &quot;aes-128-gcm&quot;);
    $tag_length = 16;
    $iv = substr($encrypt, 0, $ivlen);
    $tag = substr($encrypt, -$tag_length);
    $ciphertext = substr($encrypt, $ivlen, -$tag_length);

    $ciphertext_raw = openssl_decrypt($ciphertext, $cipher, $key, OPENSSL_NO_PADDING, $iv, $tag);
    return $ciphertext_raw;
}

</code></pre>
<p>this is the java code?</p>
<pre><code>private static String aesGcmEncrypt(String content, byte[] key) {
        try {
            System.out.println(content);
            System.out.println(content.getBytes(UTF_8).length);
            // ??????ALGORITHM?????
            Cipher cipher = Cipher.getInstance(&quot;AES/GCM/PKCS5Padding&quot;);
            SecretKeySpec skey = new SecretKeySpec(key, &quot;AES&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, skey);
            //????
            byte[] ivb = cipher.getIV();
            byte[] encodedByteArray = cipher.doFinal(content.getBytes(UTF_8));

            byte[] message = new byte[ivb.length + encodedByteArray.length];

            System.arraycopy(ivb, 0, message, 0, ivb.length);
            System.arraycopy(encodedByteArray, 0, message, ivb.length, encodedByteArray.length);
            String ss = Base64.getEncoder().encodeToString(message);
            return ss;
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException
                | BadPaddingException e) {
            return null;
        }
    }

</code></pre>
<p>JAVA code can't modify,because it is not mine,I must adapt to the java code.</p>
"	NULL	2	NULL	07:23.6	1	19:54.1	NULL	NULL	0	14762252	0	1	4	<java><php><aes-gcm>	how do i encrypt and decrypt use AES/GCM/ between PHP and JAVA	1134	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65198620	0	0	"<p>Trying to define UDF functions in Spark to encrypt/decrypt columns in a DataFrame. I am using two encryption functions, one of which uses a random IvParameterSpec (IV). What is not clear to me is how to use the decryption. I know that is the worst thing in the world to use a fixed IV, and to reuse a IV with the same key.</p>
<pre class=""lang-scala prettyprint-override""><code>val encryptUDF = udf((initVecText: String, key : String, text : String) =&gt; {
    val Algorithm = &quot;AES/CBC/PKCS5Padding&quot;
    val Key = new SecretKeySpec(Base64.getDecoder.decode(key), &quot;AES&quot;)
    val IvSpec = new IvParameterSpec(initVecText.getBytes(&quot;UTF-8&quot;))
    val cipher = Cipher.getInstance(Algorithm)
    cipher.init(Cipher.ENCRYPT_MODE, Key, IvSpec)
    new String(Base64.getEncoder.encode(cipher.doFinal(text.getBytes(&quot;utf-8&quot;))), &quot;utf-8&quot;)
})

val encryptUDF2 = udf((key : String, text : String) =&gt; {
    val Algorithm = &quot;AES/CBC/PKCS5Padding&quot;
    val Key = new SecretKeySpec(Base64.getDecoder.decode(key), &quot;AES&quot;)
    val rand = new SecureRandom()
    val bytes = new Array[Byte](16)
    rand.nextBytes(bytes)
    val ivSpec = new IvParameterSpec(bytes)
    val cipher = Cipher.getInstance(Algorithm)
    cipher.init(Cipher.ENCRYPT_MODE, Key, ivSpec)
    new String(Base64.getEncoder.encode(cipher.doFinal(text.getBytes(&quot;utf-8&quot;))), &quot;utf-8&quot;)
})

val dencryptUDF = udf((initVector: String, key : String, text : String) =&gt; {
    val iv = new IvParameterSpec(initVector.getBytes(&quot;UTF-8&quot;))
    val skeySpec = new SecretKeySpec(Base64.getDecoder.decode(key), &quot;AES&quot;)
    val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;)
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv)
    val original = cipher.doFinal(Base64.getDecoder.decode(text))
    new String(original)
})

val dencryptUDF2 = udf((key : String, text : String) =&gt; {
    val rand = new SecureRandom()
    val bytes = new Array[Byte](16)
    rand.nextBytes(bytes)
    val iv = new IvParameterSpec(bytes)
    val skeySpec = new SecretKeySpec(Base64.getDecoder.decode(key), &quot;AES&quot;)
    val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;)
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv)
    val original = cipher.doFinal(Base64.getDecoder.decode(text))
    new String(original)
})
</code></pre>
<p>Examples (not a Scala snippet):</p>
<pre class=""lang-scala prettyprint-override""><code>text=&quot;417701467673&quot;
key=&quot;YWFhYWJiYmJjY2NjZGRkZGVlZWVmZmZmZ2dnZ2hoaGg=&quot;
initVec1=&quot;InitVec_FAKEVEC1&quot;
initVec2=&quot;InitVec_FAKEVEC2&quot;

// encryption
CASE 1: encryptUDF(initVec1, key, text) =&gt; &quot;h0iI8IWv4sCaEhMOdGU6pw==&quot; // does not change if rerun twice
CASE 2: encryptUDF(initVec2, key, text) =&gt; &quot;DVs9geuiNB2VPkwG1OSuTA==&quot; // does not change if rerun twice
CASE 3: encryptUDF2(key, text)          =&gt; &quot;3XTQwfjBN77GTMd5Xk2o3w==&quot; // always a random output at each run

// decryption

// CASE 1:
dencryptUDF(initVec1, key, &quot;h0iI8IWv4sCaEhMOdGU6pw==&quot;) =&gt; &quot;417701467673&quot; // OK, using the same IV
dencryptUDF(initVec2, key, &quot;h0iI8IWv4sCaEhMOdGU6pw==&quot;) =&gt; &quot;417701464673&quot; // WRONG! using another IV (note it is a different number)
dencryptUDF2(key,          &quot;h0iI8IWv4sCaEhMOdGU6pw==&quot;) =&gt; javax.crypto.BadPaddingException using a random IV

// CASE 2:
dencryptUDF(initVec1, key, &quot;DVs9geuiNB2VPkwG1OSuTA==&quot;) =&gt; &quot;417701467673&quot; // WRONG! using another IV 
dencryptUDF(initVec2, key, &quot;DVs9geuiNB2VPkwG1OSuTA==&quot;) =&gt; &quot;417701464673&quot; // OK, using the same IV
dencryptUDF2(key,          &quot;DVs9geuiNB2VPkwG1OSuTA==&quot;) =&gt; javax.crypto.BadPaddingException using a random IV

// CASE 3:
dencryptUDF(initVec1, key, &quot;3XTQwfjBN77GTMd5Xk2o3w==&quot;) =&gt; javax.crypto.BadPaddingException using initVec1
dencryptUDF(initVec2, key, &quot;3XTQwfjBN77GTMd5Xk2o3w==&quot;) =&gt; javax.crypto.BadPaddingException using initVec2
dencryptUDF2(key,          &quot;3XTQwfjBN77GTMd5Xk2o3w==&quot;) =&gt; javax.crypto.BadPaddingException using a random IV
</code></pre>
<p>The exception:</p>
<pre><code>Caused by: javax.crypto.BadPaddingException: Given final block not properly padded
  at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:989)
  at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:845)
  at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
  at javax.crypto.Cipher.doFinal(Cipher.java:2165)
  at $anonfun$1.apply(&lt;console&gt;:76)
  at $anonfun$1.apply(&lt;console&gt;:71)
  ... 16 more
</code></pre>
"	NULL	5	NULL	07:39.4	0	51:05.6	51:05.6	NULL	11862465	11862465	0	1	0	<java><scala><apache-spark><encryption><cryptography>	"Using random IvParameterSpec, the decryption doesn't work"	734	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65244260	65247750	1	"<p>I want to encrypt a text, I'm using the AES encryption with key and Vector variables  and I have the following code:</p>
<pre><code>import java.util.zip.GZIPOutputStream;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec; 

log.info(&quot;Beanshell Execution Commenced&quot;); 

String plainText = vars.get(&quot;xmlDeclaracion&quot;).toString();

//log.info(plainText); 

static final String _Key = vars.get(&quot;keybytes&quot;);
static final String _Iv = vars.get(&quot;iv&quot;);

Cipher _Cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
SecretKeySpec _KeySpec = new SecretKeySpec(_Key.getBytes(), &quot;AES&quot;);
IvParameterSpec _IvSpec = new IvParameterSpec(_Iv.getBytes());

_Cipher.init(Cipher.ENCRYPT_MODE, _KeySpec, _IvSpec); 

byte[] cipherText = _Cipher.doFinal(plainText.getBytes(&quot;UTF-8&quot;)); 

String encryptedResponse = Base64.encodeBase64String(cipherText); 

vars.put(&quot;encryptedResponse&quot;,encryptedResponse); 
</code></pre>
<p>But in Console shows the ERROR <code>Error invoking bsh method</code> when I run the test</p>
<pre><code>2020-12-10 18:29:25,154 INFO o.a.j.e.StandardJMeterEngine: Running the test!
2020-12-10 18:29:25,154 INFO o.a.j.s.SampleEvent: List of sample_variables: []
2020-12-10 18:29:25,155 INFO o.a.j.g.u.JMeterMenuBar: setRunning(true, *local*)
2020-12-10 18:29:25,155 INFO o.a.j.e.StandardJMeterEngine: Starting ThreadGroup: 1 : Thread Group
2020-12-10 18:29:25,155 INFO o.a.j.e.StandardJMeterEngine: Starting 1 threads for group Thread Group.
2020-12-10 18:29:25,155 INFO o.a.j.e.StandardJMeterEngine: Thread will continue on error
2020-12-10 18:29:25,155 INFO o.a.j.t.ThreadGroup: Starting thread group... number=1 threads=1 ramp-up=1 delayedStart=false
2020-12-10 18:29:25,160 INFO o.a.j.t.ThreadGroup: Started thread group number 1
2020-12-10 18:29:25,160 INFO o.a.j.e.StandardJMeterEngine: All thread groups have been started
2020-12-10 18:29:25,160 INFO o.a.j.t.JMeterThread: Thread started: Thread Group 1-1
2020-12-10 18:29:25,160 INFO o.a.j.s.FileServer: Stored: C:/Jmeter/Morales2020/MoralesAnual.csv
2020-12-10 18:29:25,165 INFO o.a.j.u.BeanShellTestElement: Beanshell Execution Commenced
2020-12-10 18:29:25,166 ERROR o.a.j.u.BeanShellInterpreter: Error invoking bsh method: eval Sourced file: inline evaluation of: ``import java.util.zip.GZIPOutputStream; import java.security.InvalidAlgorithmPara . . . '' : Method Invocation _Cipher.init
2020-12-10 18:29:25,166 WARN o.a.j.p.j.s.BeanShellSampler: Exception executing script. org.apache.jorphan.util.JMeterException: Error invoking bsh method: eval Sourced file: inline evaluation of: ``import java.util.zip.GZIPOutputStream; import java.security.InvalidAlgorithmPara . . . '' : Method Invocation _Cipher.init**
2020-12-10 18:29:25,166 INFO o.a.j.t.JMeterThread: Thread is done: Thread Group 1-1
2020-12-10 18:29:25,166 INFO o.a.j.t.JMeterThread: Thread finished: Thread Group 1-1
2020-12-10 18:29:25,167 INFO o.a.j.e.StandardJMeterEngine: Notifying test listeners of end of test
2020-12-10 18:29:25,167 INFO o.a.j.s.FileServer: Close: C:/Jmeter/Morales2020/MoralesAnual.csv
2020-12-10 18:29:25,167 INFO o.a.j.g.u.JMeterMenuBar: setRunning(false, *local*)
</code></pre>
"	NULL	2	NULL	38:32.3	0	05:28.5	09:09.1	NULL	238704	14324679	0	1	0	<java><encryption><jmeter><beanshell>	Jmeter Encrypt AES 128 with CBC	410	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65551823	0	0	"<h1>Aim:</h1>
<p>To be able to encrypt a piece of data (a string) on iOS and decrypt on Android or vice versa to provide users with end-to-end encryption.</p>
<p>Unfortunately, Encrypted Message in Java does not match the Encrypted Message in Swift.<br />
<strong>Java:</strong> <em>gTwbbTCiE+Km/5Lw3yWlTr/sd5aoN6II66CqsvbiSAE=</em><br />
<strong>Swift:</strong> <em>iFA3j0lBPiyz64ge0M67pBPWLYEsVgSHvwY2m+anDQ+lRUauQOq9b3cLqFH1</em></p>
<hr />
<h1>What I Tried:</h1>
<h2>Java Implementation</h2>
<pre class=""lang-java prettyprint-override""><code>package com.company;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Base64;

public class Main {


    public static void main(String[] args) throws Exception {
        // Get Base64 encoder
        Base64.Encoder b64e = Base64.getEncoder();

        // Message to encrypt
        String str = &quot;Hello, playground&quot;;
        // Password to use for encryption
        String key = &quot;password&quot;;

        // The bytes of the string requiring encryption
        byte[] strByteArray = str.getBytes(StandardCharsets.UTF_8);
        // Print the message in plaintext
        System.out.println(&quot;Message: &quot; + str);
        // Print the Base64 encoded message bytes
        System.out.println(&quot;Message B64: &quot; + b64e.encodeToString(strByteArray));

        // The bytes of the key
        byte[] keyByteArray = key.getBytes(StandardCharsets.UTF_8);
        // Print the key in plaintext
        System.out.println(&quot;Key: &quot; + key);

        // Create an instance of MessageDigest to hash the key using the SHA-256 algorithm
        MessageDigest hasher = MessageDigest.getInstance(&quot;SHA-256&quot;);
        // The bytes of the hash digest
        byte[] keyHashByteArray = hasher.digest(keyByteArray);
        // Print the Base64 encoded key hash bytes
        System.out.println(&quot;Key B64: &quot; + b64e.encodeToString(keyHashByteArray));

        // Create an instance of a SecretKey from the key hash bytes
        SecretKey secretKey = new SecretKeySpec(keyHashByteArray, &quot;AES&quot;);

        // Create an instance of an AES cipher
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
        // Set the cipher mode to encryption and supply the previously computed SecretKey
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        // Encrypt the message string bytes using an AES-256 cipher using the secret key
        byte[] ciphertext = cipher.doFinal(strByteArray);
        // Print the Base64 encoded ciphertext bytes
        System.out.println(&quot;Encrypted Message: &quot; + b64e.encodeToString(ciphertext));
    }
}

</code></pre>
<h2>Java Output:</h2>
<p>Message: Hello, playground<br />
Message B64: SGVsbG8sIHBsYXlncm91bmQ=<br />
Key: password<br />
Key B64: XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=<br />
Encrypted Message: gTwbbTCiE+Km/5Lw3yWlTr/sd5aoN6II66CqsvbiSAE=</p>
<h2>Swift Implementation</h2>
<pre class=""lang-swift prettyprint-override""><code>import Cocoa
import CryptoKit

// Message to encrypt
var str = &quot;Hello, playground&quot;

// Print the message in plaintext
print(&quot;Message: \(str)&quot;)

// The bytes of the string requiring encryption
var messageByteArray = Data(str.utf8)

// Print the Base64 encoded message bytes
print(&quot;Message B64: \(Data(messageByteArray).base64EncodedString())&quot;)

// Password to use for encryption
var key = &quot;password&quot;

// Print the key in plaintext
print(&quot;Key: \(key)&quot;)

// The bytes of the key
var keyByteArray = Data(key.utf8)

// The bytes of the hash digest
var keyHashByteArray = SHA256.hash(data: keyByteArray);

// Create an instance of a SymmetricKey from the key hash bytes
var symetricKeyFromHash = SymmetricKey(data: keyHashByteArray)

// Print the Base64 encoded key hash bytes
symetricKeyFromHash.withUnsafeBytes {body in
    print(&quot;Key B64: \(Data(body).base64EncodedString())&quot;)
}

// Encrypt the message string bytes using an AES-256 cipher using the secret key
let sealed = try AES.GCM.seal(messageByteArray, using: symetricKeyFromHash)

// Print the Base64 encoded ciphertext bytes
print(&quot;Encrypted Message: \(sealed.combined!.base64EncodedString())&quot;)

</code></pre>
<h2>Swift Output:</h2>
<p>Message: Hello, playground<br />
Message B64: SGVsbG8sIHBsYXlncm91bmQ=<br />
Key: password<br />
Key B64: XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=<br />
Encrypted Message: NAYn6W22c4IcJUyYpXAKbMLq5yktFUGDPYCOvIRFXISDAK4xrJHh9Yv+15Z9</p>
"	NULL	5	NULL	55:24.2	0	55:24.2	NULL	NULL	0	12979231	0	1	3	<java><android><ios><swift><encryption>	Equivalent Encryption and Decryption on iOS and Android	646	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65721100	65722564	NULL	"<p>I'm trying to understand how encryption/decryption works, so i've this encrypt JAVA function to convert in PHP (decryption method too):</p>
<pre><code>// JAVA
public byte[] encrypt( String text, String salt, String key, ecrypt enc, eprovider provider, ebit bit ) {
    byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    IvParameterSpec ivspec = new IvParameterSpec( iv );
    SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
    KeySpec spec = new PBEKeySpec( key.toCharArray(), salt.getBytes(), 65536, bit.getValue() );
    SecretKey tmp = factory.generateSecret( spec );
    SecretKeySpec secretkey = new SecretKeySpec( tmp.getEncoded(), enc.getValue() );
    Cipher cipher = Cipher.getInstance( provider.getValue() );
    cipher.init( Cipher.ENCRYPT_MODE, secretkey, ivspec );
    return cipher.doFinal( text.getBytes( &quot;UTF-8&quot; ) );
}
</code></pre>
<p>I wrote something like this to decrypt in PHP (i suppose i receive a base64 string encrypted by the JAVA above):</p>
<pre><code>// PHP
$IvLength = 16;
$password = '&lt;PASSWD&gt;';
$salt = &quot;&lt;SALT&gt;&quot;;
$keyLength = 65536;
$iterations = 256;
$hash = hash_pbkdf2(&quot;sha256&quot;, $password, $salt, $iterations, $keyLength);
$ciphertext = base64_decode('&lt;MY-BASE-64-CRYPT-STRING&gt;');
$iv = substr($ciphertext, 0, $IvLength);
$ciphertext = substr($ciphertext, $IvLength);
$decryptedtext = openssl_decrypt($ciphertext, &quot;aes-256-cbc&quot;, $hash, OPENSSL_RAW_DATA, $iv);
</code></pre>
<p>but i'm still missing something, because 'openssl_decrypt' returns false.</p>
<p>What am i missing?</p>
"	NULL	NULL	NULL	42:04.2	NULL	NULL	NULL	NULL	NULL	5313756	0	1	1	<java><php><encryption>	Encrypt/Decrypt java to PHP	837	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
65772470	0	2	"<p>Am getting exception while doing decryption as per the below logic. Please suggest me any issue in the below code snippet. Encryption is fine and able to encrypt.</p>
<pre><code>public String encryptDataSymmetric(String dataTobeEncrypted) {
    String encryptedData = null;
    try {
        Charset CHARSET = Charset.forName(&quot;UTF8&quot;);
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        SecureRandom securerandom = new SecureRandom();
        KeyGenerator keygenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keygenerator.init(192, securerandom);
        SecretKey key = keygenerator.generateKey();
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;);
        // cipher.init(Cipher.ENCRYPT_MODE, key, ivspec);
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(new byte[cipher.getBlockSize()]));
        encryptedData = DatatypeConverter.printBase64Binary(cipher.doFinal(dataTobeEncrypted.getBytes(CHARSET)))
                .trim();
        System.out.println(&quot;---encryptedData-----&quot; + encryptedData);
    } catch (Exception ex) {
        ex.printStackTrace();
    }

    return encryptedData;
}

public String decryptDataSymmetric(String dataTobeDecrypted) {
    String decryptedData = null;
    try {
        Charset CHARSET = Charset.forName(&quot;UTF8&quot;);
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        SecureRandom securerandom = new SecureRandom();
        KeyGenerator keygenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keygenerator.init(192, securerandom);
        SecretKey key = keygenerator.generateKey();
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;);
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(new byte[cipher.getBlockSize()]));
        decryptedData = new String(
                DatatypeConverter.parseBase64Binary(new String(cipher.doFinal(dataTobeDecrypted.getBytes()))));
        System.out.println(&quot;---decryptedData----&quot; + decryptedData);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return decryptedData;
}
</code></pre>
<blockquote>
<p>javax.crypto.BadPaddingException: pad block corrupted     at
org.bouncycastle.jce.provider.JCEBlockCipher.engineDoFinal(Unknown
Source)</p>
</blockquote>
"	NULL	1	NULL	11:46.6	0	03:07.3	15:58.8	NULL	1000551	2249207	0	1	0	<java><exception><encryption><symmetric>	BadPaddingException while performing symmetric encryption decryption	144	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66129148	0	1	"<p>Environment: Java 8 / SpringBoot v2.0.2</p>
<p>I'm trying to fix a security issue in the code by changing Cipher instance from just &quot;AES&quot; to &quot;AES/GCM/NoPadding&quot;. However, the existing test for the REST endpoint which has an encrypted path parameter value which uses this encrypt method fails.</p>
<p>Here is my encrypt method,</p>
<pre><code>public String encrypt(final Long transactionId) {
    Assert.notNull(transactionId, &quot;Transaction Id Should Not Be null&quot;);
    String encryptedText = &quot;&quot;;
    try
    {   final byte[] encodedSecretKey = Base64.decodeBase64(encryptKey);
        final SecretKeySpec secretKey = new SecretKeySpec(encodedSecretKey, &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        cipher.init(1, secretKey);
        final byte[] contentAsBytes = transactionId.toString().getBytes();
        byte[] contentAsByteCypherText = cipher.doFinal(contentAsBytes);

        byte[] iv = cipher.getIV();
        byte[] message = new byte[NUMBER_OF_IV_BYTES + contentAsByteCypherText.length];
        System.arraycopy(iv, SRC_POSITION, message, DEST_POSITION, NUMBER_OF_IV_BYTES);
        System.arraycopy(contentAsByteCypherText, SRC_POSITION, message, NUMBER_OF_IV_BYTES, contentAsByteCypherText.length);
        encryptedText = Base64.encodeBase64URLSafeString(message);

    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
        LOGGER.error(&quot;Failed to encrypt Transaction ID &quot;, e);
        throw new BlahException(&quot;Failed to encrypt transaction id&quot;, e);
    }
    return encryptedText;
}
</code></pre>
<p>My Test</p>
<pre><code>public void testJourney(final Long transactionId) throws Exception {
    final String request = loadExpectedContent(transactionId);
    mockRestServiceServer.reset();
    mockRestServiceServer.expect(requestTo(&quot;/spring/rest/transaction/&quot; + webClient.encrypt(transactionId)))
            .andExpect(method(HttpMethod.GET))
            .andRespond(withSuccess().contentType(MediaType.APPLICATION_JSON).body(request));
    final CompletableFuture&lt;String&gt; completable = webClient.getWebJourney(transactionId);
    mockRestServiceServer.verify();
    final String response = completable.get();
    Assert.assertNotNull(response);
    LOGGER.info(LoggingUtils.format(LoggingUtils.keyValue(&quot;Request&quot;, transactionId),
            LoggingUtils.keyValue(&quot;Response&quot;, LoggingUtils.parse(response))));
}
</code></pre>
<p>In this test the encrypt method is hit twice.</p>
<ol>
<li>when trying to create the expect</li>
<li>inside webClient.getWebJourney(transactionId)</li>
</ol>
<p>The difference is when <code>Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);</code> is used those two times it returns two different values failing the test. But when <code>Cipher.getInstance(&quot;AES&quot;);</code> is used (without IV) it returns same value both times.</p>
<p>My question is how can I test this REST endpoint with &quot;AES/GCM/NoPadding&quot;?</p>
"	NULL	2	NULL	13:22.2	0	38:16.5	38:16.5	NULL	934005	934005	0	1	0	<java><spring-boot><encryption><aes><aes-gcm>	Test a REST Endpoint with AES Encrypted data	197	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66180326	0	1	"<p>Hello and sorry in advance for my broken English.
I would like in a project to realize several different encryption from a character string.</p>
<p>So I turned to the counter mode of AES (which I have already used in python without any problem)</p>
<p>But when I use the program below twice on the same string the result is exactly the same.
I probably don't understand how AES works. But I wonder if the counter increments by itself or not.</p>
<p>I tried to use an Iv but must I increment it myself to have a different result?</p>
<p>Here's a sample code:</p>
<pre><code>String key = &quot;thisisa128bitkey&quot;;

Cipher cipher = Cipher.getInstance(&quot;AES/CTR/PKCS5PADDING&quot;);
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

byte[] encrypted = cipher.doFinal(gu.getGraine().getBytes());
System.out.println(&quot;first id : &quot;+Base64.encodeToString(encrypted,Base64.DEFAULT));

byte[] encrypted2 = cipher.doFinal(gu.getGraine().getBytes());
System.out.println(&quot;second id: &quot;+Base64.encodeToString(encrypted2,Base64.DEFAULT));
</code></pre>
<p>Here gu.getGraine() is a simple string.
For display the two values ??are identical</p>
<p>Thanks in advance for your time.</p>
"	NULL	3	NULL	27:44.3	0	20:08.1	NULL	NULL	0	15185587	0	1	0	<java><encryption><aes><counter>	how is the counter of the counter mode of AES incremented?	96	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66184216	0	1	"<p>I have a problem when decrypting the data that I get from the SQL in java.</p>
<p>What I am trying to do is sending the encrypted info to the SQL database then getting it from the database and decrypting it, but I get this exception:</p>
<blockquote>
<p>javax.crypto.BadPaddingException: Given final block not properly
padded. Such issues can arise if a bad key is used during decryption.</p>
</blockquote>
<p>What might be the problem, how can I solve it? And how do I save the key for each password?</p>
<p>Here is my code:</p>
<pre><code>import java.sql.*;
import java.util.Base64;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import java.security.*;
import java.security.spec.*;


public class try_3 {

    
    public static SecretKey getKeyFromPassword(String Mpass, String salt)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
            
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
            KeySpec spec = new PBEKeySpec(Mpass.toCharArray(), salt.getBytes(), 65536, 256);
            SecretKey secret = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
            return secret;
        }
     
    
    public static IvParameterSpec generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }
   
    public static String encryptPasswordBased(String plainText, SecretKey key, IvParameterSpec iv)
            throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);
            return Base64.getEncoder()
                .encodeToString(cipher.doFinal(plainText.getBytes()));
        }

        public static String decryptPasswordBased(String cipherText, SecretKey key, IvParameterSpec iv)
            throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
            cipher.init(Cipher.DECRYPT_MODE, key, iv);
            return new String(cipher.doFinal(Base64.getDecoder().decode(cipherText)));
        }
        
        
        
        public static void main(String[] args) throws InvalidKeyException, NoSuchAlgorithmException, IllegalBlockSizeException, 
        BadPaddingException, InvalidAlgorithmParameterException, NoSuchPaddingException, InvalidKeySpecException {
            // TODO Auto-generated method stub
            
            String plainText = &quot;Hi&quot;;
            String password = &quot;Hi123&quot;;
            String salt = &quot;12345678&quot;;
            
            IvParameterSpec ivParameterSpec = generateIv();
            SecretKey key = getKeyFromPassword(password,salt);
                 
///Encrypt/// 
            
            String cipherText = encryptPasswordBased(plainText, key, ivParameterSpec);
            
            try {

               Connection myConn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:8889/Account&quot;, &quot;root&quot;, &quot;root&quot;);
                       
               PreparedStatement st = myConn.prepareStatement(&quot;insert into Encryption&quot;);
               
               st.executeUpdate(&quot;INSERT INTO Encryption (pass) VALUE ('&quot;+cipherText+&quot;')&quot;);
               
               System.out.println(&quot;The Cipher Text has been insteld &quot;);
                           
               st.close();   
              }
              catch (Exception exc) {
               exc.printStackTrace();
              }
            
///Decrypt/// 
            

            try {
                 
                  Connection myConn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:8889/Account&quot;, &quot;root&quot;, &quot;root&quot;);
                   
                  Statement myStmt = myConn.createStatement();
                   
                  int id= 12;
                  ResultSet myRs = myStmt.executeQuery(&quot;SELECT pass FROM Encryption WHERE ID = '&quot; + id + &quot;' &quot;);
                
                  while (myRs.next()) {
                            
                  String  encreptedText= myRs.getString(&quot;pass&quot;); 
                  String  decryptedCipherText = decryptPasswordBased(encreptedText, key, ivParameterSpec);
                  
                  System.out.println(&quot;The decrypted Cipher Text: &quot;+decryptedCipherText);
                  }
              }
              catch (Exception exc) {
               exc.printStackTrace();
              }
            
    }
            



}
</code></pre>
<p>Note:
The only way this exception doesnt occur is when encrypting and decrypting the same password in the same run (which use the same key). So, what I did is adding the id (of the password to be added) at the decryption time so it can see the same key.
I know that this is an inconvenient way to solve this problem, but I am new to security and I have no idea how to solve it.</p>
"	NULL	3	NULL	46:14.7	0	15:44.8	NULL	NULL	0	15199336	0	1	1	<java><sql><encryption><cryptography><javax.crypto>	decrypting data from the SQL in java	322	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66499175	66500559	1	"<p>I need to code a Java function that encrypts a string using AES256, with CBC mode and PKCS#5 padding. I've been given a secret key and some before-after examples so I can validate my implementation. This is all I've got. I found that the expected results are exactly the one produced by this online generator: <a href=""https://encode-decode.com/aes-256-cbc-encrypt-online/"" rel=""nofollow noreferrer"">https://encode-decode.com/aes-256-cbc-encrypt-online/</a></p>
<p>One of the parameters I must provide my Cipher instance with is an initialization vector (&quot;IV&quot;). If I don't specify one, Java uses a random one, and therefore produces a different result on each run, which is not the behavior I want.</p>
<p>The above generator does not ask its users for an IV, and still it produces the same results as my target. So I'd like to know how it is possible. Do people tend to use the same IV (regardless of whether it's secure or not), something like &quot;0000000000000000&quot;, &quot;1234567812345678&quot; (I tried both, just in case)? Or is there any other way to encrypt with the above parameters without using an IV?</p>
<p>Just in case, here is my code for the moment :</p>
<pre class=""lang-java prettyprint-override""><code>package com.example.test;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class AesTest {
    public static String key = &quot;abcdefghijklmnopqrstuvwxyz012345&quot;;
    public static String email = &quot;test@example.com&quot;;
    public static String initVector = &quot;????????????????&quot;;

    public static void main(String []args) {
        try {
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);

            cipher.init(
                Cipher.ENCRYPT_MODE,
                new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;),
                new IvParameterSpec(initVector.getBytes(StandardCharsets.UTF_8))
            );

            byte[] encrypted = cipher.doFinal(email.getBytes());
            System.out.println(Base64.getEncoder().encodeToString(encrypted));
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}
</code></pre>
"	NULL	3	NULL	22:37.9	0	13:00.7	13:00.7	NULL	2516943	2516943	0	1	1	<java><encryption><cryptography><aes>	AES/CBC/PKCS5Padding encryption with fixed IV (or without one)	8683	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66651213	66654999	NULL	"<p>I have written the following Java code to encrypt a message/data. Currently it is using default encryption algorithm  (AES/ECB/PKCS5PADDING). In JavaScript while decrypting I have used mode ECB. I read articles that ECB is not secure. So I need to move to CBC mode. But changing the mode is causing issue for me. Can you help me to change the mode in proper way so that it is compatible?</p>
<pre><code>import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class EncryptDecryptImpl {

    private static final String secretKey = &quot;abcdefghijklmnop&quot;;
    private static final String mySecretKey = &quot;my-secret-key&quot;;

    private static final String encryptionAlgorithm = &quot;AES&quot;; // need to use AES/CBC/PKCS5Padding

    public static String encrypt(String data, String secret) {
        try {
            Key key = generateKey(secret);
            Cipher cipher = Cipher.getInstance(encryptionAlgorithm);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedValue = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encryptedValue);
        } catch (InvalidKeyException | NoSuchPaddingException | NoSuchAlgorithmException |
                BadPaddingException | IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String strToDecrypt, String secret) {
        try {
            Key key = generateKey(secret);
            Cipher cipher = Cipher.getInstance(encryptionAlgorithm);
            cipher.init(Cipher.DECRYPT_MODE, key);
            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        } catch (NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException |
                BadPaddingException | IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        return null;
    }

    private static Key generateKey(String secret) {
        byte[] decoded = Base64.getDecoder().decode(secret.getBytes());
        return new SecretKeySpec(decoded, encryptionAlgorithm);
    }

    public static String encodeKey(String key) {
        byte[] encoded = Base64.getEncoder().encode(key.getBytes());
        return new String(encoded);
    }

    public static String decodeKey(String key) {
        byte[] decoded = Base64.getDecoder().decode(key.getBytes());
        return new String(decoded);
    }

    public static String encodedBase64Key() {
        return encodeKey(secretKey); 
    }

    public static String decodedBase64Key(String encryptedSecretKey) {
        return decodeKey(encryptedSecretKey);
    }

    public static String aesEncryptedSecretKey() {
        return EncryptDecryptImpl.encrypt(mySecretKey, encodedBase64Key());
    }

    public static String aesDecryptedSecretKey() {
        return EncryptDecryptImpl.decrypt(aesEncryptedSecretKey(), encodedBase64Key());
    }
}
</code></pre>
<p>Test:</p>
<pre><code>String encryptedSecretKey = EncryptDecryptImpl.aesEncryptedSecretKey(); // cipher text
</code></pre>
<p>JavaScript:</p>
<pre><code>export const getSecretKey = () =&gt; {
  const encryptedBase64Key = 'bXVzdEJlMTZCeXRlc0tleQ==';
  const parsedBase64Key = enc.Base64.parse(encryptedBase64Key);
  const encryptedCipherText = getSessionStorageItem('uselessKey');
  let decryptedData = '';
  if (encryptedCipherText !== null) {
    decryptedData = AES.decrypt(encryptedCipherText, parsedBase64Key, {
      mode: mode.ECB, // need to use CBC
      padding: pad.Pkcs7
    })
  }
  return decryptedData.toString(enc.Utf8).toString();
}
</code></pre>
"	NULL	NULL	NULL	08:22.9	NULL	NULL	NULL	NULL	NULL	14823347	0	1	1	<javascript><java>	Use Crypto JS CBC mode for decrypting and equivalent encrypting in Java	303	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66742361	66742985	1	"<p>I would like to know that How can I use openssl_decrypt in JAVA?</p>
<p>Here is PHP code</p>
<pre><code>&lt;?php
    $textToDecrypt = hex2bin(&quot;db3700cd861aee8215b3db514adde6c9&quot;); // input is hexadecimal format
    $key = &quot;MbQeThWmZq4t7w1z&quot;;
    $decrypted = openssl_decrypt($textToDecrypt, 'AES-128-CBC', $aesKey, OPENSSL_NO_PADDING);
    echo &quot;decrypt data is &quot;. $decrypted
?&gt;
</code></pre>
<p>And here is my JAVA code</p>
<pre><code>byte[] textToDecrypt = inp.getBytes();

SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), &quot;AES&quot;);

Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);

cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);


byte[] original = cipher.doFinal(textToDecrypt);

result = new String((original));
</code></pre>
<p>The PHP code can decrypt correctly but in JAVA I got the error &quot;<strong>Parameters missing</strong>&quot;</p>
<p>How can I solve this.</p>
<p>Thanks.</p>
"	NULL	5	NULL	15:20.6	0	58:47.3	24:53.8	NULL	10481878	10481878	0	1	1	<java><php><encryption><openssl><php-openssl>	How can I use openssl_decrypt as a JAVA?	272	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66770634	0	0	"<p>I want to create secretKey(symmetricKey) using my EC privateKey and publicKey from backend(Java)
and decrypt message using that secretKey. How to achieve this? Here is implementation:</p>
<p><strong>This is how backend creates sharedKey:</strong></p>
<pre><code>KeyAgreement keyAgreement = KeyAgreement.getInstance(&quot;ECDH&quot;, &quot;BC&quot;);
        keyAgreement.init(privateKey);
        keyAgreement.doPhase(publicKey, true);
        return keyAgreement.generateSecret(&quot;AES&quot;);
</code></pre>
<p><strong>Here is how iOS creates sharedSecret-&gt;SymmetricKey</strong> not sure if this is right because comparing secretKeys with backend my key is different (by definition of ECDH should be same)</p>
<pre><code>let serverPubKey = try P256.KeyAgreement.PublicKey(pemRepresentation: serverPublicKeyPEM)
            let shared = try privateKey.sharedSecretFromKeyAgreement(with: serverPubKey)
            
            let symetricKey = shared.hkdfDerivedSymmetricKey(using: SHA256.self,
                                                             salt: &quot;&quot;.data(using: .utf8)!,
                                                             sharedInfo: Data(),
                                                             outputByteCount: 32)
</code></pre>
<p><strong>here is how backend encrypts</strong></p>
<pre><code>byte[] plain = Base64.getEncoder().encodeToString(plainString.getBytes(StandardCharsets.UTF_8)).getBytes();
        SecretKey key = generateSharedSecret(decodePrivateKey(sessionKey), decodePublicKey( devicePublicKey));
        Cipher encryptor = Cipher.getInstance(&quot;AES/CTR/NoPadding&quot;, BouncyCastleProvider.PROVIDER_NAME);
        IvParameterSpec ivSpec = new IvParameterSpec(INITIALIZATION_VECTOR);
        encryptor.init(Cipher.ENCRYPT_MODE, key, ivSpec);
        return Base64.getEncoder().encodeToString(encryptor.doFinal(plain, 0, plain.length));
</code></pre>
<p><strong>and here is how iOS trying to decrypt</strong></p>
<pre><code>guard let payloadData = Data(base64Encoded: payload) else { return }
        do {
            //I know that sealedBox is wrong, should be just box? I'm not sure of this step
            let sealedBox = try AES.GCM.SealedBox(combined: payloadData)
            let decrypted = try AES.GCM.open(sealedBox, using: symmetricKey)
    //here I'm getting authenticationFailure

        } catch {
            print(&quot;error: \(error)&quot;)
        }
</code></pre>
"	NULL	3	NULL	59:35.1	0	13:24.8	13:24.8	NULL	589259	6898424	0	1	0	<java><encryption><aes><elliptic-curve><diffie-hellman>	Decrypt message in swift encrypted in java using AES/GCM/NoPadding	271	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66785433	0	1	"<p>everyone.</p>
<p>I am trying to encrypt and decrypt a string with an AES symmetric key, generated with a password. My current code for generating this follows below:</p>
<pre><code>public class AESUtils {

    public static SecretKey getKeyFromPassword(String password, String salt)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(), 65536, 256);
        return new SecretKeySpec(factory.generateSecret(spec)
                .getEncoded(), &quot;AES&quot;);
    }

    public static IvParameterSpec generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }

    public static String encryptPasswordBased(String plainText, SecretKey key, IvParameterSpec iv)
            throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        return Base64.getEncoder().encodeToString(cipher.doFinal(plainText.getBytes()));
    }

    public static String decryptPasswordBased(String cipherText, SecretKey key, IvParameterSpec iv)
            throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException,
            InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        return new String(cipher.doFinal(Base64.getDecoder().decode(cipherText)));
    }

}
</code></pre>
<p>The code to generate the encrypted string:</p>
<pre><code>AESUtils.encryptPasswordBased(string_content_plain, AESUtils.getKeyFromPassword(&quot;password&quot;, &quot;salt&quot;), AESUtils.generateIv());
</code></pre>
<p>The code to generate the decrypted string:</p>
<pre><code>AESUtils.decryptPasswordBased(string_content_encrypted, AESUtils.getKeyFromPassword(&quot;password&quot;, &quot;salt&quot;), AESUtils.generateIv());
</code></pre>
<p>The <code>encryptPasswordBased</code> works fine, but when I use the <code>decryptPasswordBased</code>, it always raises javax.crypto.BadPaddingException with the message: <code>Given final block not properly padded. Such issues can arise if a bad key is used during decryption.</code></p>
<p>What can I do? The generated key is always the same. I have compared it with both byte arrays.</p>
<p>Thanks</p>
"	NULL	1	NULL	35:26.3	0	47:45.4	NULL	NULL	0	9061585	0	1	0	<java><security><cryptography><java-security>	Password based AES Encryption and Decryption - BadPaddingException	592	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66880426	0	NULL	"<p>I am trying to use an attribute converter to convert two fields in my classes. I followed these tutorials pretty faithfully, but am still getting this weird error.  <a href=""https://sultanov.dev/blog/database-column-level-encryption-with-spring-data-jpa/"" rel=""nofollow noreferrer"">https://sultanov.dev/blog/database-column-level-encryption-with-spring-data-jpa/</a> <a href=""https://beingcrazydev.com/spring-data-jpa-database-column-encryption/"" rel=""nofollow noreferrer"">https://beingcrazydev.com/spring-data-jpa-database-column-encryption/</a> <a href=""https://thorben-janssen.com/how-to-use-jpa-type-converter-to/"" rel=""nofollow noreferrer"">https://thorben-janssen.com/how-to-use-jpa-type-converter-to/</a></p>
<p>Here is a shortened version of the error message I keep getting:</p>
<pre><code>Error attempting to apply AttributeConverter; nested exception is javax.persistence.PersistenceException: Error attempting to apply AttributeConverter
org.springframework.orm.jpa.JpaSystemException: Error attempting to apply AttributeConverter; nested exception is javax.persistence.PersistenceException: Error attempting to apply AttributeConverter
    at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:408)
    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:235)
    at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:551)
    at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61)
    at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:242)
    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:152)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
    at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:174)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)
    at com.sun.proxy.$Proxy88.save(Unknown Source)
    at swe.bookstore.controller.RegisterController.createAccount(RegisterController.java:58)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:197)
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:141)
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:894)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)

Caused by: javax.persistence.PersistenceException: Error attempting to apply AttributeConverter
    at org.hibernate.type.descriptor.converter.AttributeConverterSqlTypeDescriptorAdapter$2.doConversion(AttributeConverterSqlTypeDescriptorAdapter.java:148)
    at org.hibernate.type.descriptor.converter.AttributeConverterSqlTypeDescriptorAdapter$2.extract(AttributeConverterSqlTypeDescriptorAdapter.java:121)
    at org.hibernate.type.AbstractStandardBasicType.nullSafeGet(AbstractStandardBasicType.java:257)
    at org.hibernate.type.AbstractStandardBasicType.nullSafeGet(AbstractStandardBasicType.java:253)
    at org.hibernate.type.AbstractStandardBasicType.nullSafeGet(AbstractStandardBasicType.java:243)
    at org.hibernate.type.AbstractStandardBasicType.hydrate(AbstractStandardBasicType.java:329)

Caused by: java.lang.IllegalArgumentException: Last unit does not have enough valid bits
    at java.base/java.util.Base64$Decoder.decode0(Base64.java:766)
    at java.base/java.util.Base64$Decoder.decode(Base64.java:538)
    at java.base/java.util.Base64$Decoder.decode(Base64.java:561)
    at swe.bookstore.entity.AttributeEncryptor.convertToEntityAttribute(AttributeEncryptor.java:44)
    at swe.bookstore.entity.AttributeEncryptor.convertToEntityAttribute(AttributeEncryptor.java:14)
    at org.hibernate.metamodel.model.convert.internal.JpaAttributeConverterImpl.toDomainValue(JpaAttributeConverterImpl.java:45)
    at org.hibernate.type.descriptor.converter.AttributeConverterSqlTypeDescriptorAdapter$2.doConversion(AttributeConverterSqlTypeDescriptorAdapter.java:140)
    ... 134 more
</code></pre>
<p>Here is my code:</p>
<pre><code>@Component
public class AttributeEncryptor implements AttributeConverter&lt;String, String&gt; {
    private static final String AES = &quot;AES&quot;;
    private static final byte[] encryptionKey = &quot;123-a-secret-key&quot;.getBytes(); // do not change this!!

    private final Key key;
    private final Cipher encryptCipher;
    private final Cipher decryptCipher;

    public AttributeEncryptor() throws Exception {
        key = new SecretKeySpec(encryptionKey, AES);

        encryptCipher = Cipher.getInstance(AES);
        decryptCipher = Cipher.getInstance(AES);
    }

    @Override
    public String convertToDatabaseColumn(String attribute) {
        try {
            encryptCipher.init(Cipher.ENCRYPT_MODE, key);
            return Base64.getEncoder().encodeToString(encryptCipher.doFinal(attribute.getBytes()));
        } catch (InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            throw new IllegalArgumentException(e);
        }
    }

    @Override
    public String convertToEntityAttribute(String dbData) {
        try {
            decryptCipher.init(Cipher.DECRYPT_MODE, key);
            return new String(decryptCipher.doFinal(Base64.getDecoder().decode(dbData)));
        } catch (InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
            throw new IllegalArgumentException(e);
        }
    }

}
</code></pre>
<p>And how I applied it in the persistent fields:</p>
<pre><code>@Column(name = &quot;cardNumber&quot;, nullable = false)
@Convert(converter = AttributeEncryptor.class)
private String cardNumber;

@Column(name = &quot;`password`&quot;, nullable = false, length = 20)
@Convert(converter = AttributeEncryptor.class)
private String password;
</code></pre>
<p>I don't understand where I am going wrong, as I followed the steps in the tutorials I read.</p>
"	NULL	NULL	NULL	26:11.3	NULL	NULL	NULL	NULL	NULL	8327295	0	1	0	<java><hibernate><encryption><spring-data-jpa><base64>	Error attempting to apply AttributeConverter; Last unit does not have enough valid bits	1230	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
66953606	0	1	"<p>I have an issue to upgrade an AES 128 bit encryption to AES 256 in ECB mode. But I'm unable to find any solution for that. Mostly solutions are there for AES 256 CBC mode. Any help is highly appreciated.</p>
<p>The exception that I got was due to bad padding</p>
<p>PS : I'm aware of the vulnerability of ECB mode in AES but this is what I need to implement at the moment.</p>
<pre><code>import org.apache.tomcat.util.codec.binary.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.security.GeneralSecurityException;

public class Decrypt {
    public static String decryptPayload(String payload) throws Exception {
        byte[] keyBytes = {
                0x74, 0x68, 0x69, 0x73, 0x49, 0x73, 0x43, 0x53, 0x75, 0x63, 0x72, 0x65, 0x44, 0x4b, 0x55, 0x79
        };
        try {
            payload = payload.replace(' ', '+');
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
            final SecretKeySpec secretKey = new SecretKeySpec(keyBytes, &quot;AES&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            return new String(cipher.doFinal(
                    Base64.decodeBase64(payload)));
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
<p>The implementation of AES 256 ECB I tried was as follows:</p>
<pre><code>    public static String decrypt(String strToDecrypt, String secretKey) {
        try
        {
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
            KeySpec spec = new PBEKeySpec(secretKey.toCharArray(), salt.getBytes(), 65536, 256);
            SecretKey tmp = factory.generateSecret(spec);
            SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivspec);
            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        }
        catch (Exception e) {
            System.out.println(&quot;Error while decrypting: &quot; + e.toString());
        }
        return null;
    }
</code></pre>
"	NULL	10	NULL	09:59.3	0	29:46.0	22:39.6	NULL	4116874	4116874	0	1	0	<java><cryptography><aes>	Java AES 128 ECB to AES 256 ECB conversion	927	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
67189862	67190826	1	"<p>I have been trying to figure this out for days now. Encryption method works fine, but during the decryption tests I am getting the exception below. Especially I am using: <code>AES/GCM/NoPadding</code> . As far as I know <code>T_LEN</code> should be <code>IV_LENGTH*8</code> as a byte array representation. The error truly shows at ExampleCryptografer.java decryption method:     <code>byte[] decryptedText = cipher.doFinal(decoded);</code></p>
<pre><code>javax.crypto.AEADBadTagException: Tag mismatch!

at java.base/com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:623)
at java.base/com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1116)
at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1053)
at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2202)
at com.example.ExampleCryptografer.decrypt(ExampleCryptografer.java:61)
at com.example.ExampleCryptograferTest.decrypt_givenEncryptedExample_ShouldSucceed(ExampleCryptograferTest.java:21)
</code></pre>
<p>This is how my tests looks like:</p>
<pre><code>public class ExampleCryptographerTest {

private ExampleCryptographer objectUnderTest = new ExampleCryptographer(&quot;knownKeyForTest=&quot;);

@Test
public void decrypt_givenEncryptedExample_ShouldSucceed() {
    String example = &quot;afasfdafafa=&quot;;
    String encodedExample = objectUnderTest.encrypt(example);

    String result = objectUnderTest.decrypt(encodedExample);

    assertThat(result).isNotNull();
    assertThat(result.length()).isEqualTo(48);
}

@Test
public void encrypt_givenExample_ShouldSucceed() {
    String example = &quot;afasfdafafa=&quot;;

    String result = objectUnderTest.encrypt(example);

    assertThat(result).isNotNull();
    assertThat(result.length()).isEqualTo(48);
}

@Test
public void decrypt_givenEncryptedExampleWithOtherKey_ShouldFail() {
    String example = &quot;afasfdafafa=&quot;;
    String encodedExample = new ExampleCryptographer(&quot;otherKeyForTest=&quot;).encrypt(example);

    Throwable throwable = catchThrowable(() -&gt; objectUnderTest.decrypt(encodedExample));

    assertThat(throwable)
        .isInstanceOf(IllegalArgumentException.class);
}

@Test(expected = InvalidKeyException.class)
public void encrypt_givenInvalidKey_ShouldFail() {
    new ExampleCryptographer(&quot;invalid&quot;).encrypt(&quot;test&quot;);
}
</code></pre>
<p>}</p>
<p>and finally the actual code:</p>
<pre><code>public class ExampleCryptographer {

private static final String ALGORITHM = &quot;AES&quot;;

private final Key key;
private static final int T_LEN = 96;
private static final int IV_LENGTH = 12;
private final Base64 base64 = new Base64(76, null, true);

@SneakyThrows
public ExampleCryptographer(@Value(&quot;${myKey}&quot;) String secretKey) {
    this.key = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);
}

@SneakyThrows
public String encrypt(@NonNull String text) {
    byte[] iv = new byte[IV_LENGTH];
    (new SecureRandom()).nextBytes(iv);

    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    GCMParameterSpec ivSpec = new GCMParameterSpec(T_LEN, iv);
    cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);

    byte[] ciphertext = cipher.doFinal(text.getBytes(UTF_8));
    byte[] encrypted = new byte[iv.length + ciphertext.length];
    System.arraycopy(iv, 0, encrypted, 0, iv.length);
    System.arraycopy(ciphertext, 0, encrypted, iv.length, ciphertext.length);

    return base64.encodeAsString(encrypted);
}

@SneakyThrows
public String decrypt(@NonNull String encryptedText) {
    byte[] decoded = base64.decode(encryptedText);

    byte[] iv = Arrays.copyOfRange(decoded, 0, IV_LENGTH);

    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    GCMParameterSpec ivSpec = new GCMParameterSpec(T_LEN, iv);
    cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

    byte[] decryptedText = cipher.doFinal(decoded);

    return new String(decryptedText);
}
</code></pre>
<p>}</p>
<p>Can anyone help? I have been reading many about, and still cannot find anything wrong.</p>
"	NULL	0	NULL	40:34.3	0	24:09.6	26:02.1	NULL	6237822	6237822	0	1	1	<java><encryption><aes-gcm>	javax.crypto.AEADBadTagException: Tag mismatch for AES/GCM/No Padding encryptor/decryptor	9382	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
67222092	0	0	"<p>I'm trying to rewrite AES code i found on internet. Trying to change modes from ECB to CBC. Code doesn't give me any errors while encrypting or decrypting, yet it return incorrect decrypted plaintext. You can see output <a href=""https://imgur.com/a/AYDyEdd"" rel=""nofollow noreferrer"">Here</a>.</p>
<pre><code>public static String encrypt(String strToEncrypt, SecretKey secret) throws InvalidKeyException{
    
    try{
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, secret); //without this line, iv = null
        byte[] iv = cipher.getIV();
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(iv));
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        
        byteArrayOutputStream.write(iv, 0, iv.length);
        byte[] cipherT = cipher.doFinal(strToEncrypt.getBytes());
        byteArrayOutputStream.write(cipherT, 0, cipherT.length);
        cipherT = byteArrayOutputStream.toByteArray();
        
        return Base64.getEncoder().encodeToString(cipher.doFinal(cipherT));
    }catch (Exception e){
        e.printStackTrace();
    }
    return null;
} 
     
public static String decrypt(String strToDecrypt, SecretKey secret) throws NoSuchAlgorithmException, NoSuchPaddingException{
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    byte[] iv = new byte[16];
    byte[] CipherByte = Base64.getDecoder().decode(strToDecrypt);
    iv = Arrays.copyOfRange(CipherByte, 0, iv.length);

    CipherByte = Arrays.copyOfRange(CipherByte, 16, CipherByte.length);
    try{
        cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
        return new String(cipher.doFinal(CipherByte));
    
    }catch(Exception e){
        e.printStackTrace();
        return null;
    }
}
</code></pre>
<p>I tried making iv to be all zero, so i wouldn't need to add it to cipher text</p>
<pre><code>byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
</code></pre>
<p>and read it while decrypting, but the output is the same. I can't figure it out, i don't understand, is it encryption problem or decryption.</p>
"	NULL	7	NULL	35:14.2	0	46:52.4	38:59.9	NULL	68587	7764155	0	1	0	<java><encryption><aes>	AES decrypting incorrectly	69	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
67375995	0	1	"<p>I am trying to sign and encrypt the SOAP message, but I am getting this error -</p>
<p><em>The signature or decryption was invalid; nested exception is:
javax.crypto.BadPaddingException: <strong>unknown block type</strong></em></p>
<p>Since there is no explicitly mentioned padding in the signature method, I am assuming it is an error in the encryption method.</p>
<p>This is my key encryption method:</p>
<pre><code>private String encryptKey(PublicKey pubKey, SecretKey symKey) {
    try {
        final Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/OAEPWithSHA-256AndMGF1Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        final byte[] encryptedKey = cipher.doFinal(symKey.getEncoded());
        BASE64Encoder b64 = new BASE64Encoder();
        return b64.encode(encryptedKey);
    } ...
</code></pre>
<p>and the encryption of the body works similar (String s is soap body converted to string)</p>
<pre><code>private String createEncryptedData(Key key, String s) {
    try {
        final Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        final byte[] encryptedData = cipher.doFinal(s.getBytes(StandardCharsets.UTF_8));
        BASE64Encoder b64 = new BASE64Encoder();
        return b64.encode(encryptedData);
    }
    catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {
        e.printStackTrace();
        throw new IllegalStateException(
                &quot;Java runtime does not support AES/CBC/PKCS5Padding (128)&quot;, e);
    }
}
</code></pre>
<p>I found this post - <a href=""https://stackoverflow.com/questions/14109626/javax-crypto-badpaddingexception-unknown-block-type"">javax.crypto.BadPaddingException: unknown block type</a> where conversion to string is mentioned as an issue, but I am not sure how to send byte[] in message instead...I have tried with</p>
<pre><code>byte[] encodedData = Base64.getEncoder().encode(encryptedData);
</code></pre>
<p>and then I passed that byte[] in my soap message (looks like this [B@6bf256fa) and it gives me another error <em><strong>decoding.divisible.four</strong></em>. So I guess that is not appropriate way to do it.</p>
<p>PFB my full request</p>
<pre><code>      &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
    xmlns:cdb=&quot;http://cdb.services.np.aek.seavus.com/&quot;
    xmlns:sch=&quot;http://www.devoteam.com/a1/mk/np/schema&quot;&gt;
    &lt;soapenv:Header xmlns=&quot;http://www.w3.org/2005/08/addressing&quot;&gt;
        &lt;wsse:Security xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;
            xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;&gt;
            &lt;wsse:BinarySecurityToken EncodingType=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary&quot; ValueType=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3&quot; wsu:Id=&quot;X509Token&quot;&gt;MIIBwDCCASmgAwIBAgIENDDwzTANBgkqhkiG9w0BAQUFADATMREwDwYDVQQDDAh2aXBfdGVzdDAeFw0yMDA0MjEwODU1NTZaFw0zMDA0MTkwODU1NTZaMBMxETAPBgNVBAMMCHZpcF90ZXN0MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCe4AdGqUfUtsWfuwedrV8e0+rMC+nPM/kfeDcdvqXYEijIf5+BEKL/MU/WEq5LhQKPrOk1LIJPCwTT1lUwmBLQ9Q1aOd1ZrFVDTkk+RbUmeu6lst+FskJZm8G6rqAvERQEDR2TUCmNpeCHQ8nX80/ZpnUKAtIafSlw2BDoszrS4wIDAQABoyEwHzAdBgNVHQ4EFgQUrSuQYeUEdhMQrdbLHAfb/uBwhxMwDQYJKoZIhvcNAQEFBQADgYEANWPBnmmfbVgYlKr5TS53NT4CJZjry9bVivEcBCkopYdDZo2vg9N/HgSGPULGRYgcQM61+3l2cv1s+5XyNpceXaDHBcT7CQQa8kOR5WSd3vybQybgECwm1MWQZBxZqzD/piI1wDdbn1oUNlCL4bK61vjcoxah5VhRZwvsAum5jBQ=&lt;/wsse:BinarySecurityToken&gt;
            &lt;wsu:Timestamp wsu:Id=&quot;TS-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;&gt;
                &lt;wsu:Created&gt;2021-05-05T15:08:37&lt;/wsu:Created&gt;
                &lt;wsu:Expires&gt;2021-05-05T15:09:07&lt;/wsu:Expires&gt;
            &lt;/wsu:Timestamp&gt;
            &lt;xenc:EncryptedKey xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot; Id=&quot;EK-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;&gt;
                &lt;xenc:EncryptionMethod Algorithm=&quot;http://www.w3.org/2001/04/xmlenc#rsa-1_5&quot;/&gt;
                &lt;ds:KeyInfo xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
                    &lt;wsse:SecurityTokenReference&gt;
                        &lt;ds:X509Data&gt;
                            &lt;ds:X509IssuerSerial&gt;
                                &lt;ds:X509IssuerName&gt;CN=CDB&lt;/ds:X509IssuerName&gt;
                                &lt;ds:X509SerialNumber&gt;1376307457&lt;/ds:X509SerialNumber&gt;
                            &lt;/ds:X509IssuerSerial&gt;
                        &lt;/ds:X509Data&gt;
                    &lt;/wsse:SecurityTokenReference&gt;
                &lt;/ds:KeyInfo&gt;
                &lt;xenc:CipherData&gt;
                    &lt;xenc:CipherValue&gt;FaGhWE+rwBMqUnpMe5qh2n9X3bQYy8CDYCWjRFbfFsYBHso5jYSmwlX/Se4q3nFGABxkKcQlVY1ziiqxDoW2igw5W3M4mu2mk/togAPblhj+ZiAOXVBBYCc+HIbcWdipi96tSRCR0qLSd81obNA39hm6dZ4dvFOeBFzEjWFC9r8=&lt;/xenc:CipherValue&gt;
                &lt;/xenc:CipherData&gt;
                &lt;xenc:ReferenceList&gt;
                    &lt;xenc:DataReference URI=&quot;#ED-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;/&gt;
                &lt;/xenc:ReferenceList&gt;
            &lt;/xenc:EncryptedKey&gt;
            &lt;ds:Signature xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
                &lt;ds:SignedInfo&gt;
                    &lt;ds:CanonicalizationMethod Algorithm=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;/&gt;
                    &lt;ds:SignatureMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#rsa-sha1&quot;/&gt;
                    &lt;ds:Reference URI=&quot;#TS-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;&gt;
                        &lt;ds:Transforms&gt;
                            &lt;ds:Transform Algorithm=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;/&gt;
                        &lt;/ds:Transforms&gt;
                        &lt;ds:DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&gt;
                        &lt;ds:DigestValue&gt;dLT1OJDkyihjpBWglsiV3ScW/l0=&lt;/ds:DigestValue&gt;
                    &lt;/ds:Reference&gt;
                    &lt;ds:Reference URI=&quot;#Body-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;&gt;
                        &lt;ds:Transforms&gt;
                            &lt;ds:Transform Algorithm=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;/&gt;
                        &lt;/ds:Transforms&gt;
                        &lt;ds:DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&gt;
                        &lt;ds:DigestValue&gt;736yosC1DeVBYsHfDiiSlfQOBGg=&lt;/ds:DigestValue&gt;
                    &lt;/ds:Reference&gt;
                &lt;/ds:SignedInfo&gt;
                &lt;ds:SignatureValue&gt;kiPjx+N9WUJgXWtxPeFFM0GsK8AaQttpxC0hrZPFjGUYLj8S5fM0Eqp5DZPbRigRgbBw5GOmvZkV5wnrdu1IicRajxSYFbo3QVk8A/p5gb6u8E8F/igE0Vrsmg+krdHISWwplmSBzC2yFawh8A4YdLV2g0Ig3z0E7RBHjl2nay0=&lt;/ds:SignatureValue&gt;
                &lt;ds:KeyInfo&gt;
                    &lt;wsse:SecurityTokenReference&gt;
                        &lt;wsse:Reference URI=&quot;#X509Token&quot;/&gt;
                    &lt;/wsse:SecurityTokenReference&gt;
                &lt;/ds:KeyInfo&gt;
            &lt;/ds:Signature&gt;
            &lt;wsa:Action xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
                xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; soap:mustUnderstand=&quot;1&quot;&gt;http://cdb.services.np.aek.seavus.com/AssignedSubscriberNumber_WS/GetAllAssignedSeries&lt;/wsa:Action&gt;
            &lt;wsa:MessageID xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
                xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; soap:mustUnderstand=&quot;1&quot;&gt;uuid:048add69-81ff-4112-9798-7dbca65b39bb&lt;/wsa:MessageID&gt;
            &lt;wsa:To xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot;
                xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; soap:mustUnderstand=&quot;1&quot;&gt;http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous&lt;/wsa:To&gt;
        &lt;/wsse:Security&gt;
    &lt;/soapenv:Header&gt;
    &lt;soapenv:Body xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot; wsu:Id=&quot;Body-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;&gt;
        &lt;xenc:EncryptedData xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot; Id=&quot;ED-1beccd19-ec76-4011-b72c-4c204c6439b5&quot; Type=&quot;http://www.w3.org/2001/04/xmlenc#Content&quot;&gt;
            &lt;xenc:EncryptionMethod Algorithm=&quot;http://www.w3.org/2001/04/xmlenc#aes128-cbc&quot;/&gt;
            &lt;ds:KeyInfo xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&gt;
                &lt;wsse:SecurityTokenReference xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;
                    xmlns:wsse11=&quot;http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd&quot; wsse11:TokenType=&quot;http://docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKey&quot;&gt;
                    &lt;wsse:Reference URI=&quot;#EK-1beccd19-ec76-4011-b72c-4c204c6439b5&quot;/&gt;
                &lt;/wsse:SecurityTokenReference&gt;
            &lt;/ds:KeyInfo&gt;
            &lt;xenc:CipherData&gt;
                &lt;xenc:CipherValue&gt;Vk8ZqEmybLVqf4nd/gbw0KKss60BgbgNZHCg8/NSijU=&lt;/xenc:CipherValue&gt;
            &lt;/xenc:CipherData&gt;
        &lt;/xenc:EncryptedData&gt;
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>
<p>Thank you in advance!</p>
"	NULL	2	NULL	23:58.1	0	32:16.0	08:42.6	NULL	7740339	7740339	0	1	2	<java><xml><encryption><soap><badpaddingexception>	SOAP encryption - javax.crypto.BadPaddingException: unknown block type	182	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
67429570	67429972	1	"<p>From the php encryption function below:</p>
<pre><code>$data = &quot;1212312121447&quot;;
$cipher = &quot;aes-256-ofb&quot;;
$secretKey = &quot;aNdRgUjXn2r5u8x/A?D(G+KbPeShVmYp&quot;;
$ivLength = openssl_cipher_iv_length($cipher);
$keyOfb = substr(hash('sha256', $secretKey, true), 0, 32);
$ivOfb = substr($keyOfb, 0, $ivLength);
$encryptedOfb = openssl_encrypt($data, $cipher, $keyOfb, OPENSSL_RAW_DATA, $ivOfb);
echo &quot;ofb-encrypted: &quot; . base64_encode($ivOfb . $encryptedOfb);
</code></pre>
<p>the result of encryption is <code>MyFTCJx8RPzOx7h8QNxEtQgeiNIRwnrJ+uc0V70=</code></p>
<p>And I have try to write this function in Java like this:</p>
<pre><code>public static SecretKeySpec hashKey(String key){
        String keyPass = key;
        SecretKeySpec result = null;
        try{
                MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);
                md.update(keyPass.getBytes());
                byte[] AesKeyData = Arrays.copyOfRange(md.digest(), 0, 32);
                SecretKeySpec keySpec = new SecretKeySpec(AesKeyData, &quot;AES&quot;);
                result = keySpec;
                
        }
        catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        return result;
    }

public static String encryptedOFB(String inp){
        String result = &quot;&quot;;
        String key = &quot;aNdRgUjXn2r5u8x/A?D(G+KbPeShVmYp&quot;;
        SecretKeySpec keyHashed = hashKey(key);
        try{
            byte[] initVectorSize = Arrays.copyOfRange(keyHashed.toString().getBytes(), 0, 16);
            Cipher cipher = Cipher.getInstance(&quot;AES/OFB/NoPadding&quot;);
            
            IvParameterSpec iv = new IvParameterSpec(initVectorSize, 0, cipher.getBlockSize());
            cipher.init(Cipher.ENCRYPT_MODE, keyHashed, iv);
            
            byte[] encrypted = cipher.doFinal(inp.getBytes());
            
            ByteArrayOutputStream conc = new ByteArrayOutputStream();
            conc.write(initVectorSize);
            conc.write(encrypted);
            byte[] concEnc = conc.toByteArray();

            result = new String(Base64.getEncoder().encode(concEnc));
            
        }
        catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        return result;
    }
</code></pre>
<p>The result is <code>amF2YXguY3J5cHRvLnNwZYUmrJNv8ycvLua0O9g=</code></p>
<p>Why my java function return the different result from php?</p>
<p>And how do I fix the java function to get the same result with php?</p>
<p>Thank you.</p>
"	NULL	0	NULL	47:26.9	0	28:14.9	NULL	NULL	0	10481878	0	1	2	<java><php><encryption><openssl><php-openssl>	openssl_encrypt aes 256 with hash in java	296	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
67825360	0	0	"<p>I am trying to write a code equivalent of following c# code to decrypt a string in Java.</p>
<pre class=""lang-cs prettyprint-override""><code>public string Decrypt(string cipherText) 
{ 
     if (!IsBase64String(cipherText)) 
         throw new Exception(&quot;The cipherText input parameter is not base64  encoded&quot;); 
     string text; 
     var key = new Rfc2898DeriveBytes(EncryptionKey, SALT); 
     var aesAlg = new RijndaelManaged(); 
     aesAlg.Key = key.GetBytes(aesAlg.KeySize / 8); 
     aesAlg.IV = key.GetBytes(aesAlg.BlockSize / 8); 
     var decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);  var cipher = Convert.FromBase64String(cipherText); 
     using (var msDecrypt = new MemoryStream(cipher)) 
     { 
         using (var csDecrypt = new CryptoStream(msDecrypt, decryptor,  CryptoStreamMode.Read)) 
         { 
             using (var srDecrypt = new StreamReader(csDecrypt)) 
             {
                 // Internal 
                 text = srDecrypt.ReadToEnd(); 
             } 
         } 
     } 
     return text; 
 } 
</code></pre>
<p>Here is what I tried:</p>
<pre class=""lang-java prettyprint-override""><code>final String password = &quot;password&quot;;
byte[] salt = []; //salt provided here

String string = &quot;something&quot;;
System.out.println(string.length());
SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1000, 256);
SecretKey tmp = factory.generateSecret(spec);

SecretKeySpec secret = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);

byte[] data = Base64.getDecoder().decode(string);
System.out.println(data.length);
// skip first 4 bytes (the length of IV) and get IV byte array
byte[] iv = Arrays.copyOfRange(data, 16, 32);

Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
// skip IV length (4 bytes) and IV (16 bytes)
cipher.update(data, 32, data.length - 32);
String plaintext = new String(cipher.doFinal(), &quot;UTF-8&quot;);
System.out.println(plaintext);
</code></pre>
<p>Getting the following Exception:
<strong>javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.</strong></p>
<p>Not sure where I went wrong</p>
"	NULL	3	NULL	33:41.8	0	07:07.7	07:07.7	NULL	9014097	16117378	0	1	0	<java><c#><cryptography><aes>	Decryption in Java for String Encrypted in C# using AES	78	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68003124	0	0	"<p>I'm using the same key and iv for both encrypt and decrypt cipher. This is an intermittent issue. What am I doing wrong?</p>
<p>I'm keeping the key and iv in DB and it is loaded at the time of service startup. encrytCipher and DecryptCipher are initialized with these values.</p>
<p>Data loading and initialization happen once and later the ciphers are reused</p>
<pre><code>public class TestEncrypter {

    EncrypterUtil util;

    
    private Cipher encryptCipher = null;
    private Cipher decryptCipher = null;
    @Override
    public String encrypt(String strToEncrypt) throws Exception {
        if (strToEncrypt == null || strToEncrypt.isEmpty()) {
            return StringUtils.EMPTY;
        }
        try {
            initCiphers();
            String encrypterStr = Base64.getEncoder()
                    .encodeToString(encryptCipher.doFinal(strToEncrypt.getBytes(StandardCharset.UTF_8)));
       
            return encrypterStr;
        } catch (Exception e) {
            throw new RuntimeException(&quot;Exception while encryption  : &quot; + e.getMessage());
        }

    }

    @Override
    public String decrypt(String strToDecrypt) throws Exception {
        if (strToDecrypt == null || strToDecrypt.isEmpty()) {
            return StringUtils.EMPTY;
        }
        try {
            initCiphers();
            String decryptedStr = new String(decryptCipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
       
            return decryptedStr;
        } catch (Exception e) {
            throw new RuntimeException(&quot;Exception while decryption  : &quot; + e.getMessage());
        }

    }

    /**
     * Initialize the common encrypter.
     * 
     * @param myKey
     * @throws GeneralSecurityException
     */
    public void initCiphers() throws GeneralSecurityException {
        if (encryptCipher == null || decryptCipher == null) {

            String secret = util.get(&quot;KEY&quot;); // reading key from DB
            byte[] key = secret.getBytes(StandardCharset.UTF_8);
            key = MessageDigest.getInstance(&quot;SHA-256&quot;).digest(key);
            key = Arrays.copyOf(key, 16);
            SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);

            byte[] i = Arrays.copyOf(util.get(&quot;IV&quot;).getBytes(), 16); // reading iv from DB
            IvParameterSpec iv = new IvParameterSpec(i);

            encryptCipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            encryptCipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);

            decryptCipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            decryptCipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
        }

    }

</code></pre>
"	NULL	3	NULL	57:47.4	0	46:07.9	46:07.9	NULL	3164518	3164518	0	1	0	<java><encryption><aes>	Getting this exception : Given final block not properly padded. Such issues can arise if a bad key is used during decryption	235	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68175633	68186296	NULL	"<p>I want to do a simple encryption from SecureGMC java to be decrypted in PHP using AES/GCM/PKCS5Padding. The data I'm suppose to be decrypting derives from the local bank, which emphasizes on IV_SIZE=96 and TAG_BIT_LENGTH=128; they recommended me this <a href=""https://github.com/1MansiS/java_crypto/blob/master/cipher/SecuredGCMUsage.java"" rel=""nofollow noreferrer"">link</a> as reference. From what I read, <em><strong>openssl_decrypt()</strong></em> seems to be the best option, however, I can't find any $tag variable available for me to send over when decrypting it Java. Is <em><strong>openssl_decrypt()</strong></em> even recommended for this ?</p>
<p>cipher.java</p>
<pre class=""lang-java prettyprint-override""><code>public class SecuredGCMUsage {

    public static int AES_KEY_SIZE = 256 ;
    public static int IV_SIZE = 96 ;
    public static int TAG_BIT_LENGTH = 128 ;
    public static String ALGO_TRANSFORMATION_STRING = &quot;AES/GCM/PKCS5Padding&quot; ;

    public static void main(String args[]) {
            String messageToEncrypt = &quot;Testing message to decrypt&quot; ;
            
            byte[] aadData = &quot;&quot;.getBytes() ; // Any random data can be used as tag. Some common examples could be domain name...

            // Use different key+IV pair for encrypting/decrypting different parameters

            // Generating Key
            SecretKey aesKey = null ;
            try {
                KeyGenerator keygen = KeyGenerator.getInstance(&quot;AES&quot;) ; // Specifying algorithm key will be used for 
                keygen.init(AES_KEY_SIZE) ; // Specifying Key size to be used, Note: This would need JCE Unlimited Strength to be installed explicitly 
                aesKey = keygen.generateKey() ;
            } catch(NoSuchAlgorithmException noSuchAlgoExc) { System.out.println(&quot;Key being request is for AES algorithm, but this cryptographic algorithm is not available in the environment &quot;  + noSuchAlgoExc) ; System.exit(1) ; }

            // Generating IV
            byte iv[] = new byte[IV_SIZE];
            SecureRandom secRandom = new SecureRandom() ;
            secRandom.nextBytes(iv); // SecureRandom initialized using self-seeding
            

            // Initialize GCM Parameters
            GCMParameterSpec gcmParamSpec = new GCMParameterSpec(TAG_BIT_LENGTH, iv) ;      
            
            byte[] encryptedText = aesEncrypt(messageToEncrypt, aesKey,  gcmParamSpec, aadData) ;          
            
            System.out.println(&quot;Encrypted Text = &quot; + Base64.getEncoder().encodeToString(encryptedText) ) ;

            byte[] decryptedText = aesDecrypt(encryptedText, aesKey, gcmParamSpec, aadData) ; // Same key, IV and GCM Specs for decryption as used for encryption.

            System.out.println(&quot;Decrypted text &quot; + new String(decryptedText)) ;

            // Make sure not to repeat Key + IV pair, for encrypting more than one plaintext.
            secRandom.nextBytes(iv);
    }


    public static byte[] aesEncrypt(String message, SecretKey aesKey, GCMParameterSpec gcmParamSpec, byte[] aadData) {
            Cipher c = null ;

            try {
                    c = Cipher.getInstance(ALGO_TRANSFORMATION_STRING); // Transformation specifies algortihm, mode of operation and padding
            }catch(NoSuchAlgorithmException noSuchAlgoExc) {System.out.println(&quot;Exception while encrypting. Algorithm being requested is not available in this environment &quot; + noSuchAlgoExc); System.exit(1); }
             catch(NoSuchPaddingException noSuchPaddingExc) {System.out.println(&quot;Exception while encrypting. Padding Scheme being requested is not available this environment &quot; + noSuchPaddingExc); System.exit(1); }

            
            try {
                c.init(Cipher.ENCRYPT_MODE, aesKey, gcmParamSpec, new SecureRandom()) ;
            } catch(InvalidKeyException invalidKeyExc) {System.out.println(&quot;Exception while encrypting. Key being used is not valid. It could be due to invalid encoding, wrong length or uninitialized &quot; + invalidKeyExc) ; System.exit(1); }
             catch(InvalidAlgorithmParameterException invalidAlgoParamExc) {System.out.println(&quot;Exception while encrypting. Algorithm parameters being specified are not valid &quot; + invalidAlgoParamExc) ; System.exit(1); }

           try { 
                c.updateAAD(aadData) ; // add AAD tag data before encrypting
            }catch(IllegalArgumentException illegalArgumentExc) {System.out.println(&quot;Exception thrown while encrypting. Byte array might be null &quot; +illegalArgumentExc ); System.exit(1);} 
            catch(IllegalStateException illegalStateExc) {System.out.println(&quot;Exception thrown while encrypting. CIpher is in an illegal state &quot; +illegalStateExc); System.exit(1);} 
            catch(UnsupportedOperationException unsupportedExc) {System.out.println(&quot;Exception thrown while encrypting. Provider might not be supporting this method &quot; +unsupportedExc); System.exit(1);} 
           
           byte[] cipherTextInByteArr = null ;
           try {
                cipherTextInByteArr = c.doFinal(message.getBytes()) ;
           } catch(IllegalBlockSizeException illegalBlockSizeExc) {System.out.println(&quot;Exception while encrypting, due to block size &quot; + illegalBlockSizeExc) ; System.exit(1); }
             catch(BadPaddingException badPaddingExc) {System.out.println(&quot;Exception while encrypting, due to padding scheme &quot; + badPaddingExc) ; System.exit(1); }

           return cipherTextInByteArr ;
    }


    public static byte[] aesDecrypt(byte[] encryptedMessage, SecretKey aesKey, GCMParameterSpec gcmParamSpec, byte[] aadData) {
           Cipher c = null ;
    
           try {
               c = Cipher.getInstance(ALGO_TRANSFORMATION_STRING); // Transformation specifies algortihm, mode of operation and padding
            } catch(NoSuchAlgorithmException noSuchAlgoExc) {System.out.println(&quot;Exception while decrypting. Algorithm being requested is not available in environment &quot; + noSuchAlgoExc); System.exit(1); }
             catch(NoSuchPaddingException noSuchAlgoExc) {System.out.println(&quot;Exception while decrypting. Padding scheme being requested is not available in environment &quot; + noSuchAlgoExc); System.exit(1); }  

            try {
                c.init(Cipher.DECRYPT_MODE, aesKey, gcmParamSpec, new SecureRandom()) ;
            } catch(InvalidKeyException invalidKeyExc) {System.out.println(&quot;Exception while encrypting. Key being used is not valid. It could be due to invalid encoding, wrong length or uninitialized &quot; + invalidKeyExc) ; System.exit(1); }
             catch(InvalidAlgorithmParameterException invalidParamSpecExc) {System.out.println(&quot;Exception while encrypting. Algorithm Param being used is not valid. &quot; + invalidParamSpecExc) ; System.exit(1); }

            try {
                c.updateAAD(aadData) ; // Add AAD details before decrypting
            }catch(IllegalArgumentException illegalArgumentExc) {System.out.println(&quot;Exception thrown while encrypting. Byte array might be null &quot; +illegalArgumentExc ); System.exit(1);}
            catch(IllegalStateException illegalStateExc) {System.out.println(&quot;Exception thrown while encrypting. CIpher is in an illegal state &quot; +illegalStateExc); System.exit(1);}
            
            byte[] plainTextInByteArr = null ;
            try {
                plainTextInByteArr = c.doFinal(encryptedMessage) ;
            } catch(IllegalBlockSizeException illegalBlockSizeExc) {System.out.println(&quot;Exception while decryption, due to block size &quot; + illegalBlockSizeExc) ; System.exit(1); }
             catch(BadPaddingException badPaddingExc) {System.out.println(&quot;Exception while decryption, due to padding scheme &quot; + badPaddingExc) ; System.exit(1); }

            return plainTextInByteArr ;
    }
}
</code></pre>
<p>cipher.java will produce</p>
<pre class=""lang-none prettyprint-override""><code>ENCRYPTED- WHcLaJZWwTTKD1fVkmOoH0KpShZRn/LIDQwp9Djz+0MG7bp+gO+4pHCmGw==
KEY- 4A5wU7DQ0orJv91J8eZu2yMcr6sHyuAiKaNe5KdM7iw=
IV- cG8zFrxyYSeXvwx7bxQrCp6LxaZ8GQhxUcrGJkZTzfKJaErLztV9dy/iz123cw/4wEz44IMtpNR0OZSz2SA+zZLfsge3m/WJlS9xwNSYjatzYMm123hpyStcFKedi+A8
DECRYPTED TEXT- Testing message to dencrypt
</code></pre>
<p>decryption.java (only decrypt) - I've isolated into a new class for handling only decryptions data to simulate production.</p>
<pre class=""lang-java prettyprint-override""><code>public class SecuredGCMUsage {

    public static int AES_KEY_SIZE = 256 ;
    public static int IV_SIZE = 96 ;
    public static int TAG_BIT_LENGTH = 128 ;
    public static String ALGO_TRANSFORMATION_STRING = &quot;AES/GCM/PKCS5Padding&quot; ;

    public static void main(String args[]) {
            // ARGS DETAILS 
            String payloadText = &quot;WHcLaJZWwTTKD1fVkmOoH0KpShZRn/LIDQwp9Djz+0MG7bp+gO+4pHCmGw==&quot;;
            String payloadKey = &quot;4A5wU7DQ0orJv91J8eZu2yMcr6sHyuAiKaNe5KdM7iw=&quot;;
            String payloadIv = &quot;cG8zFrxyYSeXvwx7bxQrCp6LxaZ8GQhxUcrGJkZTzfKJaErLztV9dy/iz123cw/4wEz44IMtpNR0OZSz2SA+zZLfsge3m/WJlS9xwNSYjatzYMm123hpyStcFKedi+A8&quot;;

            byte[] aadData2 = &quot;testing.com&quot;.getBytes() ; 
            byte[] encryptedText2 = Base64.getDecoder().decode(payloadText);
            byte[] decodedKey = Base64.getDecoder().decode(payloadKey);
            byte[] iv  = Base64.getDecoder().decode(payloadIv);
            

            GCMParameterSpec gcmParamSpec2 = new GCMParameterSpec(TAG_BIT_LENGTH, iv) ;      
            SecretKey aesKey2 = new SecretKeySpec(decodedKey, 0, decodedKey.length, &quot;AES&quot;); 
            
            byte[] decryptedText2 = aesDecrypt(
                encryptedText2, 
                aesKey2, 
                gcmParamSpec2, 
                aadData2
            ) ; // Same key, IV and GCM Specs for decryption as used for encryption.
            System.out.println(&quot;DECRYPTED TEXT- &quot; + new String(decryptedText2)) ;
    }


    public static byte[] aesDecrypt(byte[] encryptedMessage, SecretKey aesKey, GCMParameterSpec gcmParamSpec, byte[] aadData) {
           Cipher c = null ;
    
           try {
               c = Cipher.getInstance(ALGO_TRANSFORMATION_STRING); // Transformation specifies algortihm, mode of operation and padding
            } catch(NoSuchAlgorithmException noSuchAlgoExc) {System.out.println(&quot;Exception while decrypting. Algorithm being requested is not available in environment &quot; + noSuchAlgoExc); System.exit(1); }
             catch(NoSuchPaddingException noSuchAlgoExc) {System.out.println(&quot;Exception while decrypting. Padding scheme being requested is not available in environment &quot; + noSuchAlgoExc); System.exit(1); }  

            try {
                c.init(Cipher.DECRYPT_MODE, aesKey, gcmParamSpec, new SecureRandom()) ;
            } catch(InvalidKeyException invalidKeyExc) {System.out.println(&quot;Exception while encrypting. Key being used is not valid. It could be due to invalid encoding, wrong length or uninitialized &quot; + invalidKeyExc) ; System.exit(1); }
             catch(InvalidAlgorithmParameterException invalidParamSpecExc) {System.out.println(&quot;Exception while encrypting. Algorithm Param being used is not valid. &quot; + invalidParamSpecExc) ; System.exit(1); }

            try {
                // c.updateAAD(aadData) ; // Add AAD details before decrypting
            }catch(IllegalArgumentException illegalArgumentExc) {System.out.println(&quot;Exception thrown while encrypting. Byte array might be null &quot; +illegalArgumentExc ); System.exit(1);}
            catch(IllegalStateException illegalStateExc) {System.out.println(&quot;Exception thrown while encrypting. CIpher is in an illegal state &quot; +illegalStateExc); System.exit(1);}
            
            byte[] plainTextInByteArr = null ;
            try {
                plainTextInByteArr = c.doFinal(encryptedMessage) ;
            } catch(IllegalBlockSizeException illegalBlockSizeExc) {System.out.println(&quot;Exception while decryption, due to block size &quot; + illegalBlockSizeExc) ; System.exit(1); }
             catch(BadPaddingException badPaddingExc) {System.out.println(&quot;Exception while decryption, due to padding scheme &quot; + badPaddingExc) ; System.exit(1); }

            return plainTextInByteArr ;
    }
}
</code></pre>
<p>result (successs)</p>
<pre class=""lang-none prettyprint-override""><code>DECRYPTED TEXT- Testing message to dencrypt
</code></pre>
<p>However my struggle is in decryption.php where is constantly fails.</p>
<pre class=""lang-php prettyprint-override""><code>public static function decrypt_aes_gcm_pkcs5padding ($data)
{
    $ciphertext = $data[&quot;encryptedPayload&quot;];
    $key = $data[&quot;encryptedSessionKey&quot;];
    $iv = $data[&quot;iv&quot;];
    // $aad = &quot;&quot;;

    $encrypt = base64_decode($ciphertext);
    $ivlen = openssl_cipher_iv_length($cipher = &quot;aes-256-gcm&quot;);
    $tag_length = 16;
    $iv = substr($encrypt, 0, $ivlen);
    $tag = substr($encrypt, -$tag_length);
    $ciphertext = substr($encrypt, $ivlen, -$tag_length);

    $ciphertext_raw = openssl_decrypt($ciphertext, $cipher, $key, OPENSSL_NO_PADDING, $iv, $tag);
    return $ciphertext_raw;
}
</code></pre>
<p>result (fail)</p>
"	NULL	NULL	NULL	03:13.5	NULL	NULL	NULL	NULL	NULL	7144745	0	1	0	<java><php><encryption><aes-gcm><language-interoperability>	Decrypt AES/GCM/PKCS5Padding in PHP from Java payload	1491	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68206180	0	NULL	"<p>I have program encrypt/decrypt using PHP and want to replace it with JAVA programming.</p>
<p>I have tried to convert but somehow the result didn't the same. have been searching in google and this forum for this problem but the result not match.</p>
<p>Here's the code PHP:</p>
<pre><code>    protected function aes_encode($plain_text) {
    $secret_key = 'TWOFC_ODSACCOUNT';
    $ivBytes = chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0).chr(0);
    return base64_encode(openssl_encrypt($plain_text, &quot;AES-128-CBC&quot;, $secret_key, true, $ivBytes));
}
</code></pre>
<hr />
<pre><code>$plain_text: {&quot;test&quot;:&quot;aaaaa&quot;}
Output : /BjE8Fmwcok7rBtD1pdYOO2YkHic7nqXAQQ1/SAsFF8=
</code></pre>
<hr />
<p>Here's the code JAVA:</p>
<pre><code>private static final String ALGORITHM = &quot;AES&quot;;
private static final byte[] SALT = &quot;TWOFC_ODSACCOUNT&quot;.getBytes();

static String getEncrypted(String plainText) {
    if (plainText == null) {
        return null;
    }

    Key salt = getSalt();

    try {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, salt);
        byte[] encodedValue = cipher.doFinal(plainText.getBytes());
        return Base64.getEncoder().encodeToString(encodedValue);
    } catch (Exception e) {
        e.printStackTrace();
    }
    throw new IllegalArgumentException(&quot;Failed to encrypt data&quot;);
}

static Key getSalt() {
    return new SecretKeySpec(SALT, ALGORITHM);
}
</code></pre>
<hr />
<pre><code> Output : /BjE8Fmwcok7rBtD1pdYOL6iFK9jqAYS86tEAbA/+io=


  
</code></pre>
"	NULL	NULL	NULL	41:08.5	NULL	NULL	NULL	NULL	NULL	3121281	0	1	1	<java><php><encryption>	Convert AES-128-CBC PHP to JAVA	183	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68308827	0	1	"<p>For algorithm test vector evaluation, I am trying to perform an AES in GCM mode for encryption and decryption with arbitrary tag length values such as 32 bits.</p>
<p>When I try to initialize my cipher with such an arbitrary tag length as follows:</p>
<pre><code>final Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
GCMParameterSpec parameterSpec = new GCMParameterSpec(tagLen, iv);
cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);
</code></pre>
<p>I am met with this error:</p>
<pre><code>java.security.InvalidAlgorithmParameterException: Unsupported TLen value; must be one of {128, 120, 112, 104, 96}
</code></pre>
<p>Normally, this would be a good thing, because you don't want a tag length of 32. However, for my purposes I do need this tag length.</p>
<p>Is there a way that I can override these restrictions to allow for arbitrary tag lengths?</p>
"	NULL	4	NULL	37:54.2	0	36:16.2	34:56.1	NULL	589259	13527218	0	1	5	<java><encryption><aes><aes-gcm>	AES-GCM with arbitrary tag length	819	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68346802	0	2	"<p>I am getting Invalid Key Size error when I try to use 256 bits key in AES encryption. I know I have to use JCE unlimited policy. I am using <em><strong>Jre1.8.0_181</strong></em>. So, I have set <em><strong>crypto.policy=unlimited</strong></em> in java.security file. I have also checked that I am using the correct jvm.</p>
<p>Even I am getting <em><strong>&quot;unlimited&quot;</strong></em> value whenever I use this code.</p>
<p><code>String value = System.getProperties(&quot;crypto.policy&quot;); //getting value = &quot;unlimited&quot;</code></p>
<p>But after this, I am getting key size to <em><strong>128 bits.</strong></em></p>
<pre><code>Cipher.getMaxAllowedKeyLength(&quot;AES&quot;);
</code></pre>
<p>I have followed this code from the following site:
<a href=""https://howtodoinjava.com/java/java-security/aes-256-encryption-decryption/"" rel=""nofollow noreferrer"">https://howtodoinjava.com/java/java-security/aes-256-encryption-decryption/</a></p>
<p><em><strong>Code Added</strong></em></p>
<pre><code>  public static void main(String[] args) {
    String originalString = &quot;howtodoinjava.com&quot;;
 
    String encryptedString = AES256.encrypt(originalString);
    String decryptedString = AES256.decrypt(encryptedString);
 
    System.out.println(originalString);
    System.out.println(encryptedString);
    System.out.println(decryptedString);
  }
}
public class AES256 {
  private static final String SECRET_KEY = &quot;my_super_secret_key_ho_ho_ho&quot;;
  private static final String SALT = &quot;ssshhhhhhhhhhh!!!!&quot;;
 
  public static String decrypt(String strToDecrypt) {
    try {
      byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
      IvParameterSpec ivspec = new IvParameterSpec(iv);
 
      SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
      KeySpec spec = new PBEKeySpec(SECRET_KEY.toCharArray(), SALT.getBytes(), 65536, 256);
      SecretKey tmp = factory.generateSecret(spec);
      SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);
 
      Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
      cipher.init(Cipher.DECRYPT_MODE, secretKey, ivspec);
      return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
    } catch (Exception e) {
      System.out.println(&quot;Error while decrypting: &quot; + e.toString());
    }
    return null;
  }
public static String encrypt(String strToEncrypt) {
    try {
      byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
      IvParameterSpec ivspec = new IvParameterSpec(iv);
 
      SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
      KeySpec spec = new PBEKeySpec(SECRET_KEY.toCharArray(), SALT.getBytes(), 65536, 256);
      SecretKey tmp = factory.generateSecret(spec);
      SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);
 
      Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
      cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
      return Base64.getEncoder()
          .encodeToString(cipher.doFinal(strToEncrypt.getBytes(StandardCharsets.UTF_8)));
    } catch (Exception e) {
      System.out.println(&quot;Error while encrypting: &quot; + e.toString());
    }
    return null;
  }

}
</code></pre>
"	NULL	8	NULL	42:53.3	0	30:41.3	32:49.4	NULL	16431173	16431173	0	1	1	<java><encryption><aes>	Java - AES Encryption Invalid Key Size Error	800	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68361863	0	0	"<p>I'm using some encryption functions in C# and Java whose output doesn't seem to match. I've been fighting with this for a few days and thought I'd finally turn here for help.</p>
<p><strong>Input string</strong>: &quot;a&quot;</p>
<p>Here is a snippet of the java implementation:</p>
<blockquote>
<p>CryptoAesGcmService.getInstance().encryptData(&quot;a&quot;, aes_key)</p>
</blockquote>
<pre><code>    import javax.crypto.Cipher;
    import javax.crypto.spec.GCMParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    
    import java.nio.charset.StandardCharsets;
    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;
    import java.util.Base64;
    
    public class CryptoAesGcmService {
    
        private static CryptoAesGcmService instance;
        private static final int GCM_TAG_LENGTH = 16;
        private static final int GCM_IV_LENGTH = 12;
    
        public static CryptoAesGcmService getInstance() {
            if (instance == null) {
                instance = new CryptoAesGcmService();
            }
            return instance;
    
        }
        
        public String encryptData(String plaintext, String key) throws Exception {
            return encrypt2(plaintext, key, createGCMParameter());
        }
        
        private static String encrypt(String plaintext, String key, GCMParameterSpec gcmParameterSpec) throws Exception {
    //      return plaintext;
            try {
                byte[] plainTextByte = plaintext.getBytes(StandardCharsets.UTF_8);
                Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
                cipher.init(Cipher.ENCRYPT_MODE, createSecretKeySpec(key), gcmParameterSpec);
                byte[] cipherText = cipher.doFinal(plainTextByte);
                return Base64.getEncoder().encodeToString(cipherText);
            } catch (Exception e) {
                throw new Exception(&quot;Unexpected exception occur.&quot;, e);
            }
        }
    
        private static SecretKeySpec createSecretKeySpec(String secretKey) throws NoSuchAlgorithmException {
            MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);
            md.update(secretKey.getBytes(StandardCharsets.UTF_8));
            return new SecretKeySpec(md.digest(), &quot;AES&quot;);
        }
    
        private static GCMParameterSpec createGCMParameter() {
            return new GCMParameterSpec(GCM_TAG_LENGTH * 8, new byte[GCM_IV_LENGTH]);
        }
        
    }

</code></pre>
<p><strong>Output: fix</strong> <code>3UhjsGLxeoCyP/cd7c7p++I=</code></p>
<p>Here is a snippet of the .Net implementation:</p>
<blockquote>
<p>aes.Encrypt(&quot;a&quot;, aes_key);</p>
</blockquote>
<pre><code>
using System;
using System.Buffers.Binary;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Security;

namespace api.Class
{
    public class AESGCM
    {
        private const int KEY_BIT_SIZE = 256;
        private const int MAC_BIT_SIZE = 128;
        private const int NONCE_BIT_SIZE = 128;

        private readonly SecureRandom random;

        private static AESGCM instance;

        public static AESGCM Instance //property of this class. Create an instance if it is not created yet
        {
            get
            {
                if (instance == null)
                    instance = new AESGCM();
                return instance;
            }
        }

        public AESGCM()
        {
            random = new SecureRandom();
        }

        //encrypt with strings
        public string Encrypt(string text, string key, byte[] nonSecretPayload = null)
        {
            if (string.IsNullOrEmpty(text))
                throw new ArgumentException(&quot;Text required!&quot;, &quot;text&quot;);
            //var decodedKey = Convert.FromBase64String(key);
            var decodedKey = Encoding.UTF8.GetBytes(key);
            var plainText = Encoding.UTF8.GetBytes(text);
            var cipherText = EncryptWithKey(plainText, decodedKey, nonSecretPayload);
            return Convert.ToBase64String(cipherText);
        }

        //encrypt with byte array
        private byte[] EncryptWithKey(byte[] text, byte[] key, byte[] nonSecretPayload = null)
        {
            if (key == null || key.Length != KEY_BIT_SIZE / 8)
                throw new ArgumentException(String.Format(&quot;Key needs to be {0} bit!&quot;, KEY_BIT_SIZE), &quot;key&quot;);

            nonSecretPayload = nonSecretPayload ?? new byte[] { };
            var nonce = new byte[NONCE_BIT_SIZE / 8];
            random.NextBytes(nonce, 0, nonce.Length);
            var cipher = new GcmBlockCipher(new AesEngine());
            var parameters = new AeadParameters(new KeyParameter(key), MAC_BIT_SIZE, nonce, nonSecretPayload);
            cipher.Init(true, parameters);
            var cipherText = new byte[cipher.GetOutputSize(text.Length)];
            var len = cipher.ProcessBytes(text, 0, text.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);
            using (var combinedStream = new MemoryStream())
            {
                using (var binaryWriter = new BinaryWriter(combinedStream))
                {
                    binaryWriter.Write(nonSecretPayload);
                    binaryWriter.Write(nonce);
                    binaryWriter.Write(cipherText);
                }
                return combinedStream.ToArray();
            }
        }
    }
}

</code></pre>
<p><strong>Output: always changing</strong></p>
<p>example 1
<code>4BNEStJ12YZIQsaFhOcufy1rgXW2/H5kBmPyBSVdf2qP</code></p>
<p>example 2
<code>z4xNJgr6YLg+lsCA2jUn0HKorN8UXrVm0QtKl10w/Yba</code></p>
<p>example 3
<code>0IxfAp2vIOmj3fvsJ25VVINHpnaxtZ5KNl89Qk7MNFcn</code></p>
<p>I want output .net same java. I don't know enough about encryption nor Java to know where to turn next. Any guidance would be greatly appreciated</p>
<p><strong>UPDATE</strong></p>
<p>I try to follow the advice but not working.</p>
<pre><code>using System;
using System.Text;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;

namespace api.Class
{
    public class AESGCM
    {
        private const int KEY_BIT_SIZE = 256;
        private const int MAC_BIT_SIZE = 128;

        //encrypt with strings
        public string Encrypt(string text, string key)
        {
            if (string.IsNullOrEmpty(text))
                throw new ArgumentException(&quot;Text required!&quot;, &quot;text&quot;);

            var decodedKey = Encoding.UTF8.GetBytes(key);
            var plainText = Encoding.UTF8.GetBytes(text);
            var cipherText = EncryptWithKey(plainText, decodedKey);
            return Convert.ToBase64String(cipherText);
        }

        //encrypt with byte array
        private byte[] EncryptWithKey(byte[] text, byte[] key)
        {
            if (key == null || key.Length != KEY_BIT_SIZE / 8)
                throw new ArgumentException(String.Format(&quot;Key needs to be {0} bit!&quot;, KEY_BIT_SIZE), &quot;key&quot;);

            var nonce = new byte[12];
            var cipher = new GcmBlockCipher(new AesEngine());
            var parameters = new AeadParameters(new KeyParameter(key), MAC_BIT_SIZE, nonce);
            cipher.Init(true, parameters);
            var cipherText = new byte[cipher.GetOutputSize(text.Length)];
            var len = cipher.ProcessBytes(text, 0, text.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
        }
    }
}
</code></pre>
<p><strong>Output: fix</strong> <code>7szCRlNpTMM+93eTi332Gdw=</code></p>
<p><strong>FINAL CODE</strong></p>
<pre><code>using System;
using System.Security.Cryptography;
using System.Text;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;

namespace api.Class
{
    public class AESGCM
    {
        private const int KEY_BIT_SIZE = 256;
        private const int MAC_BIT_SIZE = 128;

        //encrypt with strings
        public string Encrypt(string text, string key)
        {
            if (string.IsNullOrEmpty(text))
                throw new ArgumentException(&quot;Text required!&quot;, &quot;text&quot;);

            var decodedKey = sha256_hash(key);
            var plainText = Encoding.UTF8.GetBytes(text);
            var cipherText = EncryptWithKey(plainText, decodedKey);
            return Convert.ToBase64String(cipherText);
        }

        //encrypt with byte array
        private byte[] EncryptWithKey(byte[] text, byte[] key)
        {
            if (key == null || key.Length != KEY_BIT_SIZE / 8)
                throw new ArgumentException(String.Format(&quot;Key needs to be {0} bit!&quot;, KEY_BIT_SIZE), &quot;key&quot;);

            var nonce = new byte[12];
            var cipher = new GcmBlockCipher(new AesEngine());
            var parameters = new AeadParameters(new KeyParameter(key), MAC_BIT_SIZE, nonce);
            cipher.Init(true, parameters);
            var cipherText = new byte[cipher.GetOutputSize(text.Length)];
            var len = cipher.ProcessBytes(text, 0, text.Length, cipherText, 0);
            cipher.DoFinal(cipherText, len);

            return cipherText;
        }

        private byte[] sha256_hash(string value)
        {
            Byte[] result;

            using (var hash = SHA256.Create())
            {
                Encoding enc = Encoding.UTF8;
                result = hash.ComputeHash(enc.GetBytes(value));
            }

            return result;
        }
    }
}
</code></pre>
<p><strong>Output: same the java</strong></p>
<p>Thank you very much, @user9014097</p>
"	NULL	10	NULL	52:11.4	0	27:05.1	27:05.1	NULL	16367569	16367569	0	1	0	<java><c#><encryption><aes><aes-gcm>	AES/GCM/NoPadding JAVA encryption doesn't match C# encryption	1705	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68389403	68390682	1	"<p>So i make a simple program that encrypt people text as string and write it to file.txt
and if someone want to read the data, the program will get file.txt as string
and decrypt the data</p>
<p>this is the backend program
where user type/input text or read the text is at web (just simple textarea)</p>
<p>everything is fine and good in testing even in production,
but error happen when someone start to insert Chinese text</p>
<p>the odd thing is, is not always error</p>
<p>i mean user when writing document and use some Chinese text, it going ok, he save it, not change it, keep adding new text
he still can read the text, save it, read it and writing the other day
but one day he can't read the Chinese text, only the Chinese text
mostly he writing English text document, maybe someone name in Chinese he can't write in English, so he use Chinese text</p>
<p>i even try to loop encrypt decrypt data process, about 100 times and it still succeeded to encrypt and decrypt back to Chinese text</p>
<p>so i don't really know what cause the error</p>
<p>here's my code</p>
<pre><code>
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class DecriptEncript {

    public static void main(String[] args) {

        final String secretKey = &quot;zxc&quot;;

        //String originalString = &quot;i&quot;;
        String originalString = &quot;???&quot;;
         
         
        for(int i = 0 ; i &lt;100;i++) { // when i test try 100 times

            String encryptedString = DecriptEncript.encrypt(originalString, secretKey) ;
            String decryptedString = DecriptEncript.decrypt(encryptedString, secretKey) ;
            System.out.println(originalString);
            System.out.println(encryptedString);
            System.out.println(decryptedString);
        }
    }
    
    private static SecretKeySpec secretKey;
    private static byte[] key;
 
    public static void setKey(String myKey) 
    {
        MessageDigest sha = null;
        try {
            key = myKey.getBytes(&quot;UTF-8&quot;);
            sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); 
            secretKey = new SecretKeySpec(key, &quot;AES&quot;);
        } 
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } 
        catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
 
    public static String encrypt(String strToEncrypt, String secret) 
    {
        try
        {
            setKey(secret);
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while encrypting: &quot; + e.toString());
        }
        return null;
    }
 
    public static String decrypt(String strToDecrypt, String secret) 
    {
        try
        {
            setKey(secret);
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while decrypting: &quot; + e.toString());
        }
        return null;
    }
}

</code></pre>
<p>the error is when the program want to bring back to Chinese text
&quot;not always error&quot; and when error happen the program showing text like</p>
<p>Ãâ¦Ã¢¡ÃÂ¬ÃâÃ¢â (just randomly take from all the error)</p>
<p>i don't know how to bring back user data to text Chinese from this text error
and i don't know the Chinese text he input</p>
<p>BTW this is my first time use Cipher decrypt encrypted
so if you ask me why choose &quot;SHA-1&quot; or &quot;UTF-8&quot; or Arrays.copyOf(key, 16);
honestly i just copy from someone code at the internet</p>
<p>thank you for help</p>
"	NULL	9	NULL	11:53.2	0	48:33.8	31:25.2	NULL	10343130	10343130	0	1	1	<java><encryption>	"JAVA Cipher decrypt encrypted Chinese text, sometimes fail to bring back to Chinese text again and get error like ÃÆÃ"	196	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68418038	68419750	1	"<p>I'm trying to port this nodejs code to java</p>
<pre><code>const crypto = require(&quot;crypto&quot;);

const encrypt = (data, key) =&gt; {
    const cipher = crypto.createCipher('aes192', key)

    let crypted = cipher.update(data, 'utf8', 'hex')
    crypted += cipher.final('hex')

    return crypted;
}
</code></pre>
<p>I've tried to use this solution:</p>
<pre><code>import org.springframework.security.crypto.codec.Hex;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public String encrypt(String data, String key) {
    try {
        var cipher = Cipher.getInstance(&quot;AES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key.getBytes(), &quot;AES&quot;));

        var cipherText = cipher.update(data.getBytes());
        cipherText = ArrayUtils.addAll(cipherText, cipher.doFinal());

        return new String(Hex.encode(cipherText));
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>Cons:</p>
<ol>
<li><p><code>encrypt</code> method for Java returns a different value than the method for nodejs (for the same data and key).</p>
</li>
<li><p>In nodejs, I can put a short key (5 characters long), at the same time in java I'm catching an exception e.g. &quot;java.security.InvalidKeyException: Invalid AES key length: 5 bytes&quot;</p>
</li>
</ol>
<p>Could you suggest the right solution or point on a mistake in the existing one? Thank you in advance!</p>
<p>Note: I'm unable to change encrypt/decrypt method in nodejs, so I need to port this to java correctly.</p>
"	NULL	1	NULL	36:12.7	0	48:24.8	NULL	NULL	0	9792458	0	1	-1	<java><node.js><encryption><aes>	How to port encrypt (AES192) method from nodejs to java correctly?	146	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68420294	0	1	"<p>I'm trying to Encrypt and decrypt a string in java using the following code:</p>
<pre><code>public byte[] encrypt(String message) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);
    final byte[] digestOfPassword = md.digest(&quot;MYKEY12345&quot;
            .getBytes(&quot;utf-8&quot;));
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, &quot;DESede&quot;);
//        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
    cipher.init(Cipher.ENCRYPT_MODE, key);

    final byte[] plainTextBytes = message.getBytes(&quot;utf-8&quot;);
    final byte[] cipherText = cipher.doFinal(plainTextBytes);
    // final String encodedCipherText = new sun.misc.BASE64Encoder()
    // .encode(cipherText);



    Log.d(&quot;base64&quot;, Base64.getEncoder().encodeToString(cipherText));

    return cipherText;
}


public String decrypt(byte[] message) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);
    final byte[] digestOfPassword = md.digest(&quot;MYKEY12345&quot;
            .getBytes(&quot;utf-8&quot;));
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, &quot;DESede&quot;);
//    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher decipher = Cipher.getInstance(&quot;DESede/ECB/PKCS5Padding&quot;);
    decipher.init(Cipher.DECRYPT_MODE, key);

    // final byte[] encData = new
    // sun.misc.BASE64Decoder().decodeBuffer(message);
    final byte[] plainText = decipher.doFinal(message);

    return new String(plainText, &quot;UTF-8&quot;);
}
</code></pre>
<p>usage:</p>
<pre><code>byte[] codedtext = new Common().encrypt(&quot;HELLOWORLD!&quot;); // Function to get the Encrption
</code></pre>
<p>Output:</p>
<pre><code> base64: Ya9zBTukyOmdOh5/5vCaGA== // encrypted string converted to base64
 Encrypted : [B@d41c149 
</code></pre>
<p>ToDecrypt:</p>
<pre><code> String decodedtext = new Common().decrypt(codedtext); // To decrypt String
</code></pre>
<p>Output:</p>
<pre><code>Decrypted : HELLOWORLD!  // from Encrypted string
</code></pre>
<p>Now if i use the same Key and String to get the encryption key online i get different values.</p>
<p><a href=""https://encode-decode.com/des-ecb-encrypt-online/"" rel=""nofollow noreferrer"">Using this link</a> to verify my encryption/decryption.</p>
<p>I'm just starting in encryption/decryption so any help is appreciated about any thing that i'm doing wrong here.</p>
"	NULL	4	NULL	57:11.2	0	36:37.5	NULL	NULL	0	7877409	0	1	0	<java><encryption><des><tripledes>	DESede-ECB Encryption-Decryption	402	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68441702	0	1	"<p>I had a previously asked question answered <a href=""https://stackoverflow.com/questions/68363423/aes-encryption-in-java-working-but-decryption-in-javascript-not-working/68365135?noredirect=1#comment120882159_68365135"">here</a> about implementing encryption in Java and decrypting using CryptoJS. I was advised in the comments of that question to implement some sort of key derivation function instead of directly using a &quot;secret&quot;. This was also advised in my CheckMarx report to use salt to make the encryption more secure. This is how I'm encrypting from the Java side, concatenating the bytes of myKey and the salt:</p>
<pre><code>package aes;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;
 
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AesEncryption {

    private static SecretKeySpec secretKey;
    private static byte[] key;
 
    public static void setKey(String myKey) {
        MessageDigest sha = null;
        try {
            byte[] salt = generateSalt(16);
            key = Bytes.concat(myKey.getBytes(), salt);
            sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); 
            secretKey = new SecretKeySpec(key, &quot;AES&quot;);
        } 
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } 
    }

    public static String encrypt(String strToEncrypt, String secret) {
        try {
            setKey(secret);
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while encrypting: &quot; + e.toString());
        }
        return null;
    }
    
    private static byte[] generateSalt(int length) {
        Random r = new SecureRandom();
        byte[] salt = new byte[length];
        r.nextBytes(salt);
        return salt;
    }
}

</code></pre>
<p>The trouble I am having now is how to correctly decrypt with newly added salt. This is the decrypt function called from the JavaScript side:</p>
<pre><code>aesDecrypt: (encryptedValue, aesSecret) =&gt; {
        var sha1Hash = CryptoJS.SHA1(aesSecret)
        var secretAesKey = CryptoJS.lib.WordArray.create(sha1Hash.words.slice(0, 16 / 4));
        var bytes = CryptoJS.AES.decrypt(encryptedValue, secretAesKey, {
          mode: CryptoJS.mode.ECB,
          padding: CryptoJS.pad.Pkcs7
        })
        var originalValue = bytes.toString(CryptoJS.enc.Utf8);
        return originalValue
}
</code></pre>
<p>How can I derive just the secretAesKey from the byte array now that the salt is added?</p>
"	NULL	11	NULL	53:24.1	0	30:55.9	00:01.2	NULL	10773441	10773441	0	1	0	<javascript><java><encryption><aes>	How to add salt to AES Encryption/Decryption?	1005	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68498358	0	NULL	"<p>So, we are using AES GCM encryption &amp; decryption in nodejs as follows,
We need to use this in Java. So one can encrypt in Java and decrypt in nodeJs and vice versa.</p>
<p>here is encrypt decrypt function in node</p>
<pre class=""lang-js prettyprint-override""><code>const encrypt = (text, masterkey) =&gt; {
    // random initialization vector
    const iv = crypto.randomBytes(16);

    // random salt
    const salt = crypto.randomBytes(64);

    // derive encryption key: 32 byte key length
    // in assumption the masterkey is a cryptographic and NOT a password there is no need for
    // a large number of iterations. It may can replaced by HKDF
    // the value of 2145 is randomly chosen!
    const key = crypto.pbkdf2Sync(masterkey, salt, 2145, 32, 'sha512');

    // AES 256 GCM Mode
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);

    // encrypt the given text
    const encrypted = Buffer.concat([
        cipher.update(text, 'utf8'),
        cipher.final()
    ]);

    // extract the auth tag
    const tag = cipher.getAuthTag();

    // generate output
    return Buffer.concat([salt, iv, tag, encrypted]).toString('base64');
};

const decrypt = (encdata, masterkey) =&gt; {
    // base64 decoding
    const bData = Buffer.from(encdata, 'base64');

    // convert data to buffers
    const salt = bData.slice(0, 64);
    const iv = bData.slice(64, 80);
    const tag = bData.slice(80, 96);
    const text = bData.slice(96);

    // derive key using; 32 byte key length
    const key = crypto.pbkdf2Sync(masterkey, salt, 2145, 32, 'sha512');

    // AES 256 GCM Mode
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(tag);

    // encrypt the given text
    return decipher.update(text, 'binary', 'utf8') + decipher.final('utf8');
};
</code></pre>
<p>Here's What I have done in Java, but getting <code>input too short</code> exception.
I have also tried to mock above nodeJs encrypt function, but it seems to be not working.
I have got initialization vector(IV), salt, key as same as nodejs (in java it is signed 128 bits)</p>
<pre><code>public static String decrypt(String encData, String masterKey)
    {
        var cipherText = Base64.getDecoder().decode(encData.getBytes(StandardCharsets.UTF_8));
        var salt = Arrays.copyOfRange(cipherText, 0, 64);
        var iv = Arrays.copyOfRange(cipherText, 64, 80);
        var tag = Arrays.copyOfRange(cipherText, 80, 96);
        var ciphertext = Arrays.copyOfRange(cipherText, 96, cipherText.length);
        var key = getKeyFromPassword(masterKey, salt);
    //GCM_TAG_LENGTH = 16
        return helper(&quot;AES/GCM/NoPadding&quot;, ciphertext, tag, key, new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv));
    }

public static SecretKey getKeyFromPassword(String masterKey, byte[] salt) {

        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA512&quot;);
        KeySpec spec = new PBEKeySpec(masterKey.toCharArray(), salt, 2145, 256);
        SecretKey secret = new SecretKeySpec(factory.generateSecret(spec)
                .getEncoded(), &quot;AES&quot;);
        return secret;
    }

    public static String helper(String algorithm, byte[] cipherText, SecretKey key,
                                 GCMParameterSpec gcmParameterSpec){
          Cipher cipher = Cipher.getInstance(algorithm);
          cipher.init(Cipher.DECRYPT_MODE, key, gcmParameterSpec);
          cipher.update(cipherText);
          byte[] plainText = cipher.doFinal(tag);
          return new String(plainText, StandardCharsets.UTF_8);
    }

</code></pre>
<p>UPDATE: above code works for decryption in java</p>
<p>But now need to encrypt in java</p>
<p>here's what i am doing, but getting <code>Tag mismatch!</code>  exception while decryption.I also change the order of tag &amp; cipherText but still same error occured.</p>
<pre><code>public static String encrypt(String text, String masterKey)
    {
        var iv = generateIv(16);
        var salt = generateIv(64);
        var key = getKeyFromPassword(masterKey, salt);
        var cipher = helper1(&quot;AES/GCM/NoPadding&quot;, text, key,  new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv));
        var outputStream = new ByteArrayOutputStream();
        var tag = Arrays.copyOfRange(cipher, 0, 16);
        var ciphertext = Arrays.copyOfRange(cipher, 16, cipher.length);
        outputStream.write(salt);
        outputStream.write(iv);
        outputStream.write(tag);
        outputStream.write(ciphertext);
        return Base64.getEncoder().encodeToString(outputStream.toByteArray());
    }

public static byte[] generateIv(int N) {
        byte[] iv = new byte[N];
        new SecureRandom().nextBytes(iv);
        return iv;
    }
    
public static byte[] helper1(String algorithm, String input, SecretKey key,
                                 GCMParameterSpec gcmParameterSpec){

        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, key, gcmParameterSpec);
        return cipher.doFinal(input.getBytes());
    }

public static SecretKey getKeyFromPassword(String masterKey, byte[] salt) {

        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA512&quot;);
        KeySpec spec = new PBEKeySpec(masterKey.toCharArray(), salt, 2145, 256);
        SecretKey secret = new SecretKeySpec(factory.generateSecret(spec)
                .getEncoded(), &quot;AES&quot;);
        return secret;
    }

</code></pre>
"	NULL	NULL	NULL	20:05.4	NULL	NULL	NULL	NULL	NULL	15527436	0	1	1	<java><node.js><encryption><aes-gcm><node-crypto>	AES GCM encryption decryption in nodejs & Java	4002	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68638140	68639060	1	"<p>I'm fresh bee for writing Java AES GCM encryption and decryption.</p>
<p>I have the need to encrypt the given password using Java AES GCM and stored in config file. Then, decrypt them later and get the same password to get the security clearance.</p>
<p>Using the below program from the <a href=""https://www.javainterviewpoint.com/java-aes-256-gcm-encryption-and-decryption/"" rel=""nofollow noreferrer"">link</a></p>
<p>It perfectly works for encryption and decryption if we use the same SecretKey at the same time.</p>
<p>But, I wanted to do encryption very first time and decryption later as many time should yield the same text got encrypted.</p>
<p>Can you please help to get the program works for the decryption for later time?</p>
<pre><code>package com.javainterviewpoint;

import java.security.SecureRandom;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AES_GCM_Example
{
    static String plainText = &quot;This is a plain text which need to be encrypted by Java AES 256 GCM Encryption Algorithm&quot;;
    public static final int AES_KEY_SIZE = 256;
    public static final int GCM_IV_LENGTH = 12;
    public static final int GCM_TAG_LENGTH = 16;

    public static void main(String[] args) throws Exception
    {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(AES_KEY_SIZE);
       
        // Generate Key
        SecretKey key = keyGenerator.generateKey();
        byte[] IV = new byte[GCM_IV_LENGTH];
        SecureRandom random = new SecureRandom();
        random.nextBytes(IV);

        System.out.println(&quot;Original Text : &quot; + plainText);
        
        byte[] cipherText = encrypt(plainText.getBytes(), key, IV);
        System.out.println(&quot;Encrypted Text : &quot; + Base64.getEncoder().encodeToString(cipherText));
        
        String decryptedText = decrypt(cipherText, key, IV);
        System.out.println(&quot;DeCrypted Text : &quot; + decryptedText);
    }

    public static byte[] encrypt(byte[] plaintext, SecretKey key, byte[] IV) throws Exception
    {
        // Get Cipher Instance
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        
        // Create SecretKeySpec
        SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), &quot;AES&quot;);
        
        // Create GCMParameterSpec
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, IV);
        
        // Initialize Cipher for ENCRYPT_MODE
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmParameterSpec);
        
        // Perform Encryption
        byte[] cipherText = cipher.doFinal(plaintext);
        
        return cipherText;
    }

    public static String decrypt(byte[] cipherText, SecretKey key, byte[] IV) throws Exception
    {
        // Get Cipher Instance
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        
        // Create SecretKeySpec
        SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), &quot;AES&quot;);
        
        // Create GCMParameterSpec
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, IV);
        
        // Initialize Cipher for DECRYPT_MODE
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmParameterSpec);
        
        // Perform Decryption
        byte[] decryptedText = cipher.doFinal(cipherText);
        
        return new String(decryptedText);
    }
}
</code></pre>
"	NULL	0	NULL	42:17.5	0	41:13.4	NULL	NULL	0	5878821	0	1	0	<java><security><encryption><aes>	How do I decrypt the text which is already encrypted in the past using Java AES 256 Decryption?	763	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68668154	0	NULL	"<p>Hi I am facing a decryption problem. The decrypted value is not matching the original one.</p>
<p>Here is my logic for <code>encryption</code> :</p>
<pre><code>public byte[] encrypt(String plainText) {

    byte iv[] = new byte[ENCRYPTION_PARAM_SIZE];
    SecureRandom secRandom = new SecureRandom();
    secRandom.nextBytes(iv);
    
    Cipher cipher = Cipher.getInstance(ENCRYPTION_INSTANCE);
    SecretKeySpec key = new SecretKeySpec(fixSecret(encryptionKey), ENCRYPTION_ALGORITHM);
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
    return cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
}
</code></pre>
<p>And this is my logic for <code>Decryption</code></p>
<pre><code>public String decrypt(byte[] cipherText) {

    byte iv[] = new byte[ENCRYPTION_PARAM_SIZE];
    SecureRandom secRandom = new SecureRandom();
    secRandom.nextBytes(iv);
    
    Cipher cipher = Cipher.getInstance(ENCRYPTION_INSTANCE);
    SecretKeySpec key = new SecretKeySpec(fixSecret(encryptionKey), ENCRYPTION_ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    return new String(cipher.doFinal(cipherText), StandardCharsets.UTF_8);

}
</code></pre>
<p>Encryption options :</p>
<pre><code>ENCRYPTION_ALGORITHM = &quot;DESede&quot;;
ENCRYPTION_INSTANCE = &quot;DESede/CBC/PKCS5Padding&quot;;
Integer ENCRYPTION_PARAM_SIZE = 8;
</code></pre>
<p>This is how I am trying to verify :</p>
<pre><code>public static void main(String[] args){    
    Long value = 9123456L;
    String strval = value.toString();
    byte[] encryptedVal = encrypt(strval);
    String decryptedVal = decrypt(encryptedVal);
    
    System.out.println(&quot;Original  value : &quot; +strval);
    System.out.println(&quot;Encrypted value : &quot; +encryptedVal.toString());
    System.out.println(&quot;Decrypted value : &quot; +decryptedVal);
    System.out.println(&quot;Final     value : &quot; +Long.parseLong(decryptedVal));
}
</code></pre>
<p>What I need to do here to make it work.</p>
<p>Note : The above code is working fine if I use the below logic without SecureRandom :</p>
<pre><code>cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(new byte[ENCRYPTION_PARAM_SIZE]));
</code></pre>
"	NULL	NULL	NULL	05:52.1	NULL	NULL	NULL	NULL	NULL	5846981	0	1	0	<java><encryption><cryptography>	Encryption Decryption issue with Cipher in java	251	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68767013	0	1	"<p>I am using cipher to encrypt and decrypt byte arrays in android to send to a server. I am not using strings but I still receive the illegal block size exception.</p>
<pre><code>                try {
                    byte[] cipherNameText = {};

                    KeyGenerator keygen = null;
                    keygen = KeyGenerator.getInstance(&quot;AES&quot;);
                    keygen.init(256);
                    SecretKey key= keygen.generateKey();

                    String name = nameEdit.getText().toString();

                    Cipher cipher = null;
                    cipher = Cipher.getInstance(&quot;AES_256/CBC/NoPadding&quot;);
                    SecureRandom iv = new SecureRandom();
                    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
                    cipherNameText = cipher.doFinal(name.getBytes(StandardCharsets.UTF_8));
                    byte[] iv1 = cipher.getIV();

                    HashMap&lt;String, byte[]&gt; map = new HashMap&lt;&gt;();
                    map.put(&quot;name&quot;,key.toString().getBytes(StandardCharsets.UTF_8));

                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (NoSuchPaddingException e) {
                    e.printStackTrace();
                } catch (BadPaddingException e) {
                    e.printStackTrace();
                } catch (IllegalBlockSizeException e) {
                    e.printStackTrace();
                } catch (InvalidKeyException e) {
                    e.printStackTrace();
                } catch (UnsupportedEncodingException e) {
                    e.printStackTrace();
                }
</code></pre>
<blockquote>
<p>2021-08-12 20:55:17.606 15222-15222/com.example.package W/System.err: javax.crypto.IllegalBlockSizeException: error:1e00006a:Cipher functions:OPENSSL_internal:DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH</p>
</blockquote>
<blockquote>
<p>2021-08-12 21:51:47.322 15606-15606/com.example.package W/System.err:     at com.example.servertutorial.MainActivity$4.onClick(MainActivity.java:212)</p>
</blockquote>
<p>^this points to &quot;cipherNameText = cipher.doFinal(name.getBytes(StandardCharsets.UTF_8));&quot;</p>
"	NULL	1	NULL	01:54.9	1	24:54.1	NULL	NULL	0	12394750	0	1	1	<java><android><encryption>	Error while encrypting/decrypting byte arrays: IllegalBlockSizeException:DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH	612	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
68843171	0	0	"<p>I am new at flutter development, I am trying to use send ENCRYPTED data on server using a public key in flutter .
I have .cer certificate and i have RSA public key in flutter. Now in Java I'm using for Encrypt the Plain Text using RSA public  key i have done this
successfully . How can i do this in flutter ?</p>
<pre><code>public String encrypt(String string, final X509Certificate x509Certificate) throws NoSuchAlgorithmException, NoSuchPaddingException, IOException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {
    Cipher a = Cipher.getInstance(&quot;RSA&quot;);
    final KeyGenerator instance;
    (instance = KeyGenerator.getInstance(&quot;AES&quot;)).init(256);
    byte[] b = instance.generateKey().getEncoded();
    System.out.println(&quot;print encoded key&quot;+b);
    printUnsignedBytes(b);
    aesKey = b;
    new SecretKeySpec(b, &quot;AES&quot;);
    a.init(1, x509Certificate.getPublicKey());
    final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    final CipherOutputStream cipherOutputStream;
    (cipherOutputStream = new CipherOutputStream(byteArrayOutputStream, a)).write(b);
    cipherOutputStream.close();
    byte[] c = byteArrayOutputStream.toByteArray();
    final byte[] array = new byte[16];
    new SecureRandom().nextBytes(array);
    final Cipher instance2;
    (instance2 = Cipher.getInstance(&quot;AES/CBC/NOPADDING&quot;)).init(1, new SecretKeySpec(b, &quot;AES&quot;),
            new IvParameterSpec(array));
    byte[] bytes = s.getBytes();
    int remainder = 16 - (bytes.length % 16);
    byte[] remainderFilledWithSpaces = new byte[remainder];
    for (int i = 0; i &lt; remainderFilledWithSpaces.length; i++) {
        remainderFilledWithSpaces[i] = &quot; &quot;.getBytes()[0];
    }
    int totalLength = bytes.length + remainder;
    ByteBuffer bb = ByteBuffer.allocate(totalLength);
    bb.put(bytes);
    bb.put(remainderFilledWithSpaces);
    bb.position(0);
    byte[] blockToEncrypt = new byte[16];
    ByteBuffer encrypted = ByteBuffer.allocate(totalLength);
    while (bb.hasRemaining()) {
        bb.get(blockToEncrypt);
        byte[] update = instance2.update(blockToEncrypt);
        encrypted.put(update);
    }
    instance2.doFinal();
    final ByteArrayOutputStream byteArrayOutputStream2 = new ByteArrayOutputStream();
    final byte[] array2;
    (array2 = new byte[4])[0] = 0;
    array2[1] = 1;
    array2[3] = (array2[2] = 0);
    byteArrayOutputStream2.write(array2, 0, 4);
    array2[0] = 16;
    array2[1] = 0;
    array2[3] = (array2[2] = 0);
    byteArrayOutputStream2.write(array2, 0, 4);
    byteArrayOutputStream2.write(c, 0, 256);
    byteArrayOutputStream2.write(array, 0, 16);
    byteArrayOutputStream2.write(encrypted.array());
    return s = new String(Base64.getMimeEncoder().encode(byteArrayOutputStream2.toByteArray()));
}
</code></pre>
<p>Now , I want this same solution in Dart .Please help,thanks a lot.</p>
"	NULL	1	NULL	45:46.6	0	10:58.4	10:58.4	NULL	9763244	9763244	0	1	2	<java><flutter><dart><aes><rsa>	Plain text encryption using RSA Public Key in Dart	410	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
69063883	0	0	"<p>I am trying to encrypt the password by AES at frontend using JavaScript. Want to do the same thing as below in JAVA Language.</p>
<pre><code>public static SecretKey getKeyFromPassword() throws NoSuchAlgorithmException, InvalidKeySpecException {

    SECURITY_KEY = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    SALT = new byte[]{0, 0, 0, 0, 0, 0};
    SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
    KeySpec spec = new PBEKeySpec(new String(SECURITY_KEY).toCharArray(), SALT, 65536, 256);
    SecretKey tmp = factory.generateSecret(spec);
    return new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);
}

public static String encrypt(String input) throws
        NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException,
        IllegalBlockSizeException, InvalidKeySpecException, InvalidAlgorithmParameterException, UnsupportedEncodingException {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    cipher.init(Cipher.ENCRYPT_MODE, getKeyFromPassword(), generateIv());
    return Base64.encodeToString(cipher.doFinal(input.getBytes()), Base64.DEFAULT);

}

public static String decrypt(String cipherText) throws NoSuchPaddingException, NoSuchAlgorithmException,
        InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidKeySpecException,
        InvalidAlgorithmParameterException {

    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    cipher.init(Cipher.DECRYPT_MODE, getKeyFromPassword(), generateIv());
    byte[] decryptedValue64 = Base64.decode(cipherText, Base64.DEFAULT);
    byte[] plainText = cipher.doFinal(decryptedValue64);
    return new String(plainText);
}

public static IvParameterSpec generateIv() {
    byte[] iv = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    return new IvParameterSpec(iv);
}
</code></pre>
<p>This is the code I wrote so far.</p>
<pre><code>const crypto = require('crypto-js');


const digest = 'sha256';
const key = bin2String(SECURITY_KEY);
const iv = bin2String(iv_array);


function Encrypt (text) {
  return crypto.AES.encrypt(text, crypto.enc.Utf8.parse(key), {
    iv: crypto.enc.Utf8.parse(iv),
    mode: crypto.mode.CBC,
    padding: crypto.pad.Pkcs7
  }).toString()
}

console.log(Encrypt(&quot;password11&quot;));


function bin2String(array) {
  var result = &quot;&quot;;
  for (var i = 0; i &lt; array.length; i++) {
    result += String.fromCharCode(parseInt(array[i], 10));
  }
  return result;
}

console.log(&quot;SECURITY_KEY: &quot;+bin2String(SECURITY_KEY))
console.log(&quot;SALT: &quot;+bin2String(SALT))
</code></pre>
<p>But the result does not match. I think thie problem is IvParameterSpec. Is there any idea about how I can make it right for this code, please? :)</p>
<p>Thanks a lot.</p>
"	NULL	2	NULL	38:21.1	0	38:21.1	NULL	NULL	0	16835220	0	1	0	<javascript><java><cryptojs><password-encryption>	AES encyption from JAVA to javascript	45	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
69094658	69095123	1	"<p>I'm trying to implement following code from <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer""><strong>crypto-js</strong></a> in java for encryption</p>
<pre class=""lang-js prettyprint-override""><code>let toEncrypt= &quot;my data&quot;;
cryptoJs.AES.encrypt(toEncrypt,&quot;apasswordblabla&quot;).toString();
</code></pre>
<p>here is my implementation (AES/CBC/PKCS7Padding):</p>
<pre class=""lang-java prettyprint-override""><code>public String encrypt(Map&lt;String,Object&gt; param){
try {
            String toEncrypt= objectMapper.writeValueAsString(param);
            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
            byte[] saltData = Arrays.copyOfRange(stringToEncrypt.getBytes(StandardCharsets.UTF_8), 8, 16);
            final byte[][] keyAndIV = generateKeyAndIV(32, 16, 1, saltData, &quot;apasswordblabla&quot;.getBytes(StandardCharsets.UTF_8), md5);
            SecretKeySpec skeySpec = new SecretKeySpec(keyAndIV[0], &quot;AES&quot;);
            IvParameterSpec iv = new IvParameterSpec(keyAndIV[1]);
            Cipher cipher;
            cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;,BouncyCastleProvider.PROVIDER_NAME);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec,iv);
            byte[] base64Encoded = Base64.getEncoder().encode(cipher.doFinal(toEncrypt.getBytes(StandardCharsets.UTF_8)));
            return new String(base64Encoded);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException
                | BadPaddingException | InvalidKeyException
                | JsonProcessingException | NoSuchProviderException | InvalidAlgorithmParameterException e) {
            e.printStackTrace();
            

        }
}
</code></pre>
<p>Implementation of generateIV(int ,int ,int ,byte[] , byte[], MessageDigest):</p>
<ul>
<li>This method is equivalent to <strong>OpenSSL's EVP_BytesToKey</strong> function, as I see in cryptojs source code ( <em>crypto-js@4.1.1 on file cipher-core.js line 658</em> ), the default formatter for AES is the OpenSSLFormatter</li>
</ul>
<pre class=""lang-java prettyprint-override""><code>public static byte[][] generateKeyAndIV(int keyLength, int ivLength, int iterations, byte[] salt, byte[] password, MessageDigest md) {

        int digestLength = md.getDigestLength();
        int requiredLength = (keyLength + ivLength + digestLength - 1) / digestLength * digestLength;
        byte[] generatedData = new byte[requiredLength];
        int generatedLength = 0;

        try {
            md.reset();

            // Repeat process until sufficient data has been generated
            while (generatedLength &lt; keyLength + ivLength) {

                // Digest data (last digest if available, password data, salt if available)
                if (generatedLength &gt; 0)
                    md.update(generatedData, generatedLength - digestLength, digestLength);
                md.update(password);
                if (salt != null)
                    md.update(salt, 0, 8);
                md.digest(generatedData, generatedLength, digestLength);

                // additional rounds
                for (int i = 1; i &lt; iterations; i++) {
                    md.update(generatedData, generatedLength, digestLength);
                    md.digest(generatedData, generatedLength, digestLength);
                }

                generatedLength += digestLength;
            }

            // Copy key and IV into separate byte arrays
            byte[][] result = new byte[2][];
            result[0] = Arrays.copyOfRange(generatedData, 0, keyLength);
            if (ivLength &gt; 0)
                result[1] = Arrays.copyOfRange(generatedData, keyLength, keyLength + ivLength);

            return result;

        } catch (DigestException e) {
            throw new RuntimeException(e);

        } finally {
            // Clean out temporary data
            Arrays.fill(generatedData, (byte)0);
        }
    }
</code></pre>
<p>and then I try to decrypt it <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">Here</a>
using</p>
<pre class=""lang-js prettyprint-override""><code>let toDecrypt=&quot;[MY ENCRYPTED DATA IN BASE64]&quot;
let decrypted = cryptoJs.AES.decrypt(toDecrypt, &quot;apasswordblabla&quot;).toString(cryptoJs.enc.Utf8).toString(); 
console.log(decrypted);
</code></pre>
<p>And its always fail to decrypt, with error <strong>&quot;Malformed utf-8 data&quot;</strong>. Hence, my java implementation is wrong</p>
<p>What did I got wrong here? or if there is any ready library to solve this issues
please suggest</p>
"	NULL	0	NULL	20:48.5	0	44:07.7	30:22.1	NULL	6324746	6324746	0	1	0	<javascript><java><encryption><aes><cryptojs>	How to implement CryptoJS.AES.encrypt function in Java?	1633	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
69415547	69476902	1	"<p>I'm trying to use AES/GCM/NoPadding within the Java code for decryption. Below is the code</p>
<pre><code>public static byte[] decryptRes(final byte[] sessionKey, final String symetricKeyAlg,
        final String pkiProvider, final String encXML, final String msgRefNo)
        throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException,
        BadPaddingException, NoSuchProviderException, InvalidAlgorithmParameterException {
    Security.addProvider(new BouncyCastleProvider());
    final StringBuilder strBuilder = new StringBuilder(msgRefNo);
    strBuilder.append(&quot;0000&quot;);
    final SecretKeySpec symmKeySpec = new SecretKeySpec(sessionKey, &quot;AES&quot;);
    final Cipher symmCipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;, &quot;BC&quot;);
    symmCipher.init(2, symmKeySpec, new IvParameterSpec(strBuilder.toString().getBytes()));
    final byte[] xmlData = symmCipher.doFinal(base64Decode(encXML));
    return xmlData;
}
</code></pre>
<p>Now, when this code is invoked, it throws</p>
<blockquote>
<p>Exception : java.security.NoSuchAlgorithmException: No such algorithm: AES/GCM/NoPadding</p>
</blockquote>
<p>and not</p>
<blockquote>
<p>NoSuchProviderException.</p>
</blockquote>
<p>The necessary providers is already added but I still get the above mentioned exception.</p>
<blockquote>
<p>Java version 7 being used.</p>
</blockquote>
<p>Jars Used :</p>
<ol>
<li>
<blockquote>
<p>bcprov-jdk15to18-169.jar</p>
</blockquote>
</li>
<li>
<blockquote>
<p>bcprov-ext-jdk15to18-169.jar</p>
</blockquote>
</li>
</ol>
<p>The above jars are available in the application lib folder.</p>
"	NULL	0	NULL	16:40.2	0	15:56.6	25:07.6	NULL	7578474	7578474	0	1	-1	<java><aes-gcm>	No Such Algorithm : AES/GCM/NoPadding	1011	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70158977	0	0	"<p>I am having fun creating a small java app to automate tasks on my PC. Some tasks need credentials informations.
During my POC I was keeping these credentials in plain-text on two different .txt files (very bad practice I know, but it's nothing really sensible).</p>
<p>Now I want to do something &quot;clean&quot;. I have checked a few solutions to encrypt my informations before storing it.</p>
<p>Here is my quick code for encryption:</p>
<pre><code>public class AESEncryptor {

    private static final String key = &quot;adH5cD1rG1pJSgYm&quot;;
    
    public static void main( String[] args ) {
         try 
            {
                String text = &quot;Hello World&quot;;
                // Create key and cipher
                String d = encrypt(text);
                decrypt(d);
            }
            catch(Exception e) 
            {
                e.printStackTrace();
            }
    }
    
    public static String encrypt(String text) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {
        byte[] encrypted = getCipher(false).doFinal(text.getBytes());
        StringBuilder sb = new StringBuilder();
        for (byte b: encrypted) {
            sb.append((char)b);
        }
        String enc = sb.toString();
        System.out.println(&quot;encrypted:&quot; + enc);
        return enc;
    }
    
    public static String decrypt(String encryptedText) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {
        byte[] bb = new byte[encryptedText.length()];
        for (int i=0; i&lt;encryptedText.length(); i++) {
            bb[i] = (byte) encryptedText.charAt(i);
        }
        String decrypted = new String(getCipher(true).doFinal(bb));
        System.err.println(&quot;decrypted:&quot; + decrypted);
        return decrypted;
    }
    
    private static Cipher getCipher(boolean decryptMode) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        Key aesKey = new SecretKeySpec(key.getBytes(), &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        if(decryptMode) {
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
        } else {
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
        }
        return cipher;
    }
}
</code></pre>
<p>I was wondering if it is a bad practice to have this &quot;key&quot; as a hard coded constant. If it is, what are my solutions? I need to be able to encrypt my input (credentials) and to store it. Then when I launch the app later, to be able to get back the credentials.</p>
<p>Which leads to my second question: I read about java.util.prefs. Is it ok to use it to store the encrypted credentials?</p>
<p>It seems that I will always have to keep a key somewhere... Maybe if I chose asymmetric encryption with the private key being a password the user has to remember?</p>
<p>Thanks</p>
"	NULL	10	NULL	40:01.0	0	40:01.0	NULL	NULL	0	9812146	0	1	0	<java><encryption><cryptography><aes>	Is a hard coded key (to create a SecretKeySpec) a bad pratice for javax.crypto AES and usage of java.util.prefs	372	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70160625	0	0	"<p>Im working on a custom protocol that works via UDP. The packets sent across the network are encoded with AES/CBC/NOPADDING algorithm in a JAVA client.</p>
<p>Im using a python3 client, so i need to decrypt this packets. My question is if there is any implementation of AES/CBC/NOPADDING in python3.</p>
<p>Im currently using this to decode in python:</p>
<pre><code>def decrypt(key, data):
    from Crypto.Hash.MD5 import MD5Hash
    if data is None:
        return None
    cipher = AES.new(key.encode('utf8'), AES.MODE_CBC, bytes([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]))
    return cipher.decrypt(data)
</code></pre>
<p>But the data return is random and not well decoded.</p>
<p>However, i can succesfuly decode the packets in java like this:</p>
<pre><code>            Cipher cipher;

        try {
            cipher = Cipher.getInstance(&quot;AES/CBC/NOPADDING&quot;);
            try {
                cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));
                try {
                    cipher.doFinal(buffer, *** ...);            
                } catch (ShortBufferException | IllegalBlockSizeException | BadPaddingException e) {
                    e.printStackTrace();
                }
            } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
                e.printStackTrace();
            }
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }
</code></pre>
<p>Here i put a working example:
Firstr, i encrypt on java:</p>
<pre><code>import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.io.UnsupportedEncodingException;
import java.util.List;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class MyClass {
    public static void main(String args[]) {
        String keyBytes = &quot;UfrGUmAJq86pVtkd&quot;;
        String text_to_encrypt = &quot;topotatopotatota&quot;;

        SecretKey aesKey = new SecretKeySpec(keyBytes.getBytes(), &quot;AES&quot;);
        byte [] iv = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        Cipher cipher;
        try {
            cipher = Cipher.getInstance(&quot;AES/CBC/NOPADDING&quot;);
            try {
                cipher.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(iv));
                try {
                    String test = Base64.getEncoder().encodeToString(cipher.doFinal(text_to_encrypt.getBytes(&quot;UTF-8&quot;)));    
                    System.out.println(test);
                } catch (IllegalBlockSizeException | UnsupportedEncodingException | BadPaddingException e ) {
                    e.printStackTrace();
                }
            } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
                e.printStackTrace();
            }
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>Late i decode in python:</p>
<pre><code>from hashlib import md5
from base64 import b64decode
from base64 import b64encode

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad


class AESCipher:
    def __init__(self, key):
        self.key = md5(key.encode('utf8')).digest()

    def decrypt(self, data):
        raw = b64decode(data)
        self.cipher = AES.new(self.key, AES.MODE_CBC, bytes([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]))
        return self.cipher.decrypt(raw)

if __name__ == '__main__':
    key = &quot;UfrGUmAJq86pVtkd&quot;
    expectedt_result = &quot;topotatopotatota&quot;
    encrypted_data = &quot;ynCF3bJejxlLn1aAk8vcAw==&quot;
    cipher = AESCipher(key)
    decrypted_data = cipher.decrypt(encrypted_data)
    print(decrypted_data)
</code></pre>
"	NULL	5	NULL	58:08.0	0	10:15.5	10:15.5	NULL	6300573	6300573	0	1	0	<java><python-3.x><cryptography><aes><pycrypto>	Java AES/CBC/NOPADDING equivalent in Python3	267	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70581622	0	0	"<p>I have been stuck in a long time. I am using <a href=""https://www.npmjs.com/package/hybrid-crypto-js"" rel=""nofollow noreferrer"">Hybrid Crypto</a> library in React Native to encrypt the message. Both public and private key are in PEM format.</p>
<pre><code>let crypt = new Crypt({rsaStandard: 'RSA-OAEP'});  
let encrypted = crypt.encrypt(publicKey, &quot;This is a message&quot;);  
return JSON.parse(encrypted).cipher;  
</code></pre>
<p>This is the code I use to decrypt in Java. I followed this <a href=""https://www.txedo.com/blog/java-read-rsa-keys-pem-file/"" rel=""nofollow noreferrer"">tutorial</a> to read private key from pem file using bouncycastle library.</p>
<pre><code>String str = &quot;M2vFz/28sWhwAK4rGmnFAPRORRTlfa+XYpHFWQsi0bo=&quot;;
Security.addProvider(new BouncyCastleProvider());
KeyFactory factory = KeyFactory.getInstance(&quot;RSA&quot;);
PrivateKey privateKey = generatePrivateKey(factory, RESOURCES_DIR + &quot;private-key.pem&quot;);

Cipher decryptCipher = Cipher.getInstance(&quot;RSA&quot;);
decryptCipher.init(Cipher.DECRYPT_MODE, privateKey);

byte[] decryptOut = decryptCipher.doFinal(Base64.getDecoder().decode(str));
System.out.println(new String(decryptOut));
</code></pre>
<p>I've been trying many ways, the private key works fine when I decrypt in React but with Java I keep getting javax.crypto.BadPaddingException: Decryption error.</p>
<hr />
<p><strong>Updated Solution</strong><br />
Because I'm using hybrid crypto so it will include RSA + AES<br />
Flow in frondend: Using AES key to encrypt text =&gt; Using public RSA key to encrypt AES key. Then you send everything you need to decrypt (encrypted AES key, Iv, and cipher text)</p>
<pre><code>let crypt = new Crypt({rsaStandard: 'RSAES-PKCS1-V1_5',aesIvSize: 16});
let encrypted = crypt.encrypt(publicKey, str);
const encryptedObj = JSON.parse(encrypted);
return Object.values(encryptedObj.keys)[0] + ',' + encryptedObj.iv + ',' + encryptedObj.cipher;
</code></pre>
<p>Flow in java: Using RSA private key to decrypt AES key =&gt; Using AES key + Iv to decrypt cipher text</p>
<pre><code>PrivateKey privateKey = generatePrivateKey();
Cipher decryptCipher=Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
decryptCipher.init(Cipher.DECRYPT_MODE, privateKey);
    
byte[] keyb = decryptCipher.doFinal(Base64.getDecoder().decode(AESkey));
SecretKeySpec skey = new SecretKeySpec(keyb, &quot;AES&quot;);
IvParameterSpecivspec = new IvParameterSpec(Base64.getDecoder().decode(iv));
    
decryptCipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
decryptCipher.init(Cipher.DECRYPT_MODE, skey, ivspec);
byte[] decryptOut = decryptCipher.doFinal(Base64.getDecoder().decode(cipherText));
return new String(decryptOut);
</code></pre>
"	NULL	5	NULL	00:03.9	0	42:20.5	42:20.5	NULL	17832858	17832858	0	1	1	<javascript><java><encryption>	Hybrid Encrypt in React and Decrypt in Java	398	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70597005	70630860	1	"<p>I am trying to replicate the following PHP class in Java to decrypt a string that was encrypted using openssl_encrypt in PHP.</p>
<pre><code>class Encryption {
    /* Encryption method */
    protected $method = 'aes-128-ctr';
    /* Encryption key */
    private $key;

    /* Property constructor */
    public function __construct($key = FALSE, $method = FALSE){
        /* Check if custom key provided */
        if(!$key) {
            /* Set default encryption if none provided */
            $key = '1234567891234567';
        }
        /* Check for control characters in key */
        if(ctype_print($key)) {
            /* Convert ASCII keys to binary format */
            $this-&gt;key = openssl_digest($key, 'SHA256', true);
            
        } else {
            $this-&gt;key = $key;
        }
        $this-&gt;key = $key;
        /* Check for custom method */
        if($method) {
            /* If it is a valid openssl cipher method, use it */
            if(in_array(strtolower($method), openssl_get_cipher_methods())) {
                $this-&gt;method = $method;
            /* If it is not, unrecognised method */
            } else {
                die(__METHOD__ . &quot;: unrecognised cipher method: {$method}&quot;);
            }
        }
    }
    /* Get iv bytes length */
    protected function iv_bytes(){
        /* Get length of encryption cipher initialisation vector */
        return openssl_cipher_iv_length($this-&gt;method);
    }

    /* Encryption method */
    public function encrypt($data) {
        /* Get initialisation vector binary */
        $iv = openssl_random_pseudo_bytes($this-&gt;iv_bytes());
        /* Return IV hex &amp; encryption string */
        return bin2hex($iv) . openssl_encrypt($data, $this-&gt;method, $this-&gt;key, OPENSSL_ZERO_PADDING, $iv);
    }

    /* Decrypt encrypted string */
    public function decrypt($data){
        /* Get IV string length */
        $iv_strlen = 2  * $this-&gt;iv_bytes();
        /* Parse out the encryption string and unpack the IV and encrypted string. $regs is passed by reference in preg_match() */
        if(preg_match(&quot;/^(.{&quot; . $iv_strlen . &quot;})(.+)$/&quot;, $data, $regs)) {

            list(, $iv, $crypted_string) = $regs;
            print_R($regs);
            /* If there are character representing a hex and the IV string length is divisible by 2 */
            if(ctype_xdigit($iv) &amp;&amp; (strlen($iv) % 2 == 0)) {
                /* Decrypt the unpacked encrypted string */
                return openssl_decrypt($crypted_string, $this-&gt;method, $this-&gt;key, OPENSSL_ZERO_PADDING, hex2bin($iv));
            }
        }

        return FALSE; // failed to decrypt
    }

}
</code></pre>
<p>Here is my current sandbox class for the decryptor in Java</p>
<pre><code>public class PHPDecryptor {
    
    private static String removeIVHash(String data) {
        /* IV string length is 128 bit (16 bytes) * 2 */
        int iv_strlen = 2 * 16;
        /* Remove IV hash */
        String encrypted_string = data.substring(iv_strlen);

        return encrypted_string;
    }
    
    
    public static String decrypt(String data) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException  {
        
        String encrypted_string = removeIVHash(data);
        
        /* Get bytes for string and key */
        byte[] text_to_decrypt = encrypted_string.getBytes(StandardCharsets.UTF_8);
        String key_string = &quot;1234567891234567&quot;;
        byte[] key = key_string.getBytes(StandardCharsets.UTF_8);
        
        /* Get secret key and iv */
        SecretKeySpec secret_key = new SecretKeySpec(key, &quot;AES&quot;);
        IvParameterSpec iv = new IvParameterSpec(new byte[16]);
        
        /* Init cipher */
        Cipher cipher = Cipher.getInstance(&quot;AES/CTR/PKCS5Padding&quot;);
        cipher.init(Cipher.DECRYPT_MODE, secret_key, iv);
        
        /* Decrypt and cast to string */
        byte[] decrypted = cipher.doFinal(text_to_decrypt);
        String result = new String(decrypted, StandardCharsets.UTF_8);

        return result;
    }
    
    public static void main(String[] arg) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        String text_to_decrypt = &quot;203790144a345320d98fb773795d518e/ioQTApeVMV/4g==&quot;; // Encrypted by PHP
        System.out.println(decrypt(text_to_decrypt));
    }
}
</code></pre>
<p>However, I am not getting an accurate decryption - in fact the return result from the Java class is utter nonsense with invalid UTF-8 characters.</p>
<p>Are there any obvious errors here?</p>
"	NULL	2	NULL	20:33.9	0	54:32.0	NULL	NULL	0	16488921	0	1	0	<java><php><encryption><php-openssl>	How to decrypt string from openssl_encrypt (PHP) in Java?	70	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70598634	0	0	"<p>I want to encrypt while saving and decrypt after saving 3 fields namely</p>
<ol>
<li>first_name</li>
<li>last_name</li>
<li>email</li>
</ol>
<p>from <strong>profile</strong> collection</p>
<p>Encryption works fine and decryption also works fine for</p>
<ol>
<li>first_name</li>
<li>last_name</li>
</ol>
<p>Problem is decryption fails when it tries to decrypt email</p>
<p>Below is the error i get</p>
<p>Error while decrypting: javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption</p>
<p>Below is my code snippet</p>
<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class EncryptionUtil {

    private static SecretKeySpec secretKey;
    private static byte[] key;
 
    @EventListener(ApplicationReadyEvent.class)
    public static void setKey() 
    {
        MessageDigest sha = null;
        try {
            String myKey = &quot;2234r4r4frvdcdffrfe3455bt5tk6y678kkjnb8wss3e434&quot;;
            key = myKey.getBytes(&quot;UTF-8&quot;);
            sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); 
            secretKey = new SecretKeySpec(key, &quot;AES&quot;);
        } 
        catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
 
    public static String encrypt(String strToEncrypt) 
    {
        try
        {
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while encrypting: &quot; + e.toString());
        }
        return null;
    }
 
    public static String decrypt(String strToDecrypt) 
    {
        try
        {
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while decrypting: &quot; + e.toString());
        }
        return null;
    }
}

</code></pre>
<pre><code>
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.mapping.event.BeforeConvertCallback;
import org.springframework.stereotype.Component;

import com.juv.common.util.EncryptionUtil;

@Component
public class MongoDBBeforeConvertCallBack implements BeforeConvertCallback&lt;Profile&gt; {

    private final Class clazz = getClass();

    private final String className = clazz.getSimpleName();

    private final Logger log = LoggerFactory.getLogger(clazz);

    @Autowired
    private EncryptionUtil encryptionUtil;

    @Override
    public Profile onBeforeConvert(Profile profile, String collection) {

        if(profile != null) {

            profile.setFirstName(this.encryptionUtil.encrypt(profile.getFirstName()));
            profile.setLastName(this.encryptionUtil.encrypt(profile.getLastName()));
            profile.setEmail(this.encryptionUtil.encrypt(profile.getEmail()));

        }

        return profile;
    }
}


</code></pre>
<pre><code>
import org.bson.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.mapping.event.AfterSaveCallback;
import org.springframework.stereotype.Component;

import com.juv.common.secondary.dao.Profile;
import com.juv.common.util.EncryptionUtil;

@Component
public class MongoDBAfterSaveCallback implements AfterSaveCallback&lt;Profile&gt; {

    private final Class clazz = getClass();

    private final String className = clazz.getSimpleName();

    private final Logger log = LoggerFactory.getLogger(clazz);

    @Autowired
    private EncryptionUtil encryptionUtil;

    @Override
    public Profile onAfterSave(Profile profile, Document document, String collection) {

        if(profile != null) {
            System.out.println(&quot;--------first_name----------: &quot;+profile.getFirstName());
            System.out.println(&quot;-------decrypt-firstName----------: &quot;+this.encryptionUtil.decrypt(profile.getFirstName()));
            profile.setFirstName(this.encryptionUtil.decrypt(profile.getFirstName()));
            System.out.println(&quot;--------last_name----------: &quot;+profile.getLastName());
            System.out.println(&quot;-------decrypt-lastName----------: &quot;+this.encryptionUtil.decrypt(profile.getLastName()));
            profile.setLastName(this.encryptionUtil.decrypt(profile.getLastName()));
            System.out.println(&quot;--------email----------: &quot;+profile.getEmail());
            System.out.println(&quot;-------decrypt-email----------: &quot;+this.encryptionUtil.decrypt(profile.getEmail()));
            profile.setEmail(this.encryptionUtil.decrypt(profile.getEmail()));

        }

        return profile;
    }

    

}


</code></pre>
<p>Below is the screenshot of the logs</p>
<p><a href=""https://i.stack.imgur.com/M3Dv9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/M3Dv9.png"" alt=""enter image description here"" /></a></p>
<p>What should i do to also able to decrypt email with minimal code changes of the one i have posted</p>
"	NULL	0	NULL	31:42.2	0	37:51.3	37:51.3	NULL	5913975	5913975	0	1	1	<mongodb><spring-boot><aes><spring-mongo>	AES Decryption doesnt decrypt email but decrypts normal text	69	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70616504	70626854	1	"<p>NodeJs:
I am trying decrypt text using AES CBC PKCS7 in NodeJs and PKCS5 in java. I am getting error: <em><code>Given final block not properly padded. Such issues can arise if a bad key is used during decryption.</code></em></p>
<p><strong>UPDATED</strong></p>
<pre><code>encrypt() {
  var key = 'ThirtyTwoBytes3$ThirtyTwoBytes3$';     
  var iv = CryptoJS.enc.Utf8.parse(CryptoJS.lib.WordArray.random(128 / 8));
  let utf8Pass = CryptoJS.enc.Utf8.parse(&quot;Hello&quot;);
  let encVal = CryptoJS.AES.encrypt(utf8Pass.toString(), key, {mode: 
               CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: iv});
  return iv.concat(encVal.ciphertext).toString(CryptoJS.enc.Base64);
  }
</code></pre>
<p>Java:</p>
<pre><code>byte[] keyB = &quot;ThirtyTwoBytes3$ThirtyTwoBytes3$&quot;.getBytes(StandardCharsets.UTF_8);
IvParameterSpec ivParameterSpec = new IvParameterSpec(encryptedText.getBytes(), 0, 16);
SecretKeySpec key = new SecretKeySpec(keyB, &quot;AES&quot;);

Cipher aesCBC = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
aesCBC.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
byte[] decryptedData = Base64.getDecoder().decode(encryptedText);           
decryptedText = new String(Hex.decodeHex(new String(aesCBC.doFinal(decryptedData), StandardCharsets.UTF_8).toCharArray()));
</code></pre>
<p>Fixed IV is working fine</p>
<p>NodeJs</p>
<pre><code>var encKey = CryptoJS.enc.Utf8.parse(&quot;ThirtyTwoBytes3$ThirtyTwoBytes3$&quot;);
var encKeyIv = CryptoJS.enc.Utf8.parse(&quot;$1SixteenBytes6$&quot;);
let utf8Pass = CryptoJS.enc.Utf8.parse(&quot;Hello&quot;);
let encVal = CryptoJS.AES.encrypt(utf8Pass.toString(), encKey, {mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: encKeyIv});
encVal.ciphertext.toString();
</code></pre>
<p>Java:</p>
<pre><code>SecretKey key = new SecretKeySpec(&quot;ThirtyTwoBytes3$ThirtyTwoBytes3$&quot;.getBytes(), &quot;AES&quot;);
AlgorithmParameterSpec iv = new IvParameterSpec(&quot;$1SixteenBytes6$&quot;.getBytes());
byte[] decodeBase64 = Base64.decode(encVal);
Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
cipher.init(Cipher.DECRYPT_MODE, key, iv);
decString = new String(Hex.decodeHex(new String(cipher.doFinal(decodeBase64), &quot;UTF-8&quot;).toCharArray()));
</code></pre>
"	NULL	5	NULL	07:57.8	0	08:07.9	08:07.9	NULL	4910936	4910936	0	1	2	<node.js><encryption><aes><java-11>	AES CBC nodejs encryption and Java decryption	676	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
70907748	70908385	1	"<p>Good afternoon. Interested in the question someone tried to decrypt data in Java that was encrypted in Ruby.
I'm trying to encrypt a word in Ruby (using the Marshal module) and decrypt in Java. If the Marshal module is used, can it be transferred to other languages ??or not?</p>
<p>This is my test in Ruby:</p>
<pre><code>let(:key) { &quot;12345678901234567890123456789012&quot; }
let(:str) { &quot;Serhii&quot; }

it &quot;encrypt_content&quot; do
  crypt = ActiveSupport::MessageEncryptor.new(key, cipher: 'aes-256-cbc')
  encrypted_content = crypt.encrypt_and_sign(str)
  encrypted_content
end
    
</code></pre>
<p>The code methods are:</p>
<pre><code>def encrypt_and_sign(value, expires_at: nil, expires_in: nil, purpose: nil)
  verifier.generate(_encrypt(value, expires_at: expires_at, expires_in: expires_in, purpose: purpose))
end

def _encrypt(value, **metadata_options)
  cipher = new_cipher
  cipher.encrypt
  cipher.key = @secret

  iv = cipher.random_iv
  cipher.auth_data = &quot;&quot; if aead_mode?

  encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), metadata_options))
  encrypted_data &lt;&lt; cipher.final

  blob = &quot;#{::Base64.strict_encode64 encrypted_data}--#{::Base64.strict_encode64 iv}&quot;`enter code here`
  blob = &quot;#{blob}--#{::Base64.strict_encode64 cipher.auth_tag}&quot; if aead_mode?
  blob
end
    
</code></pre>
<p>The decrypt Java is:</p>
<pre><code>private static final String key = &quot;12345678901234567890123456789012&quot;;

@SneakyThrows
public static String decrypt(String encrypted) {
    byte[] firstByte = Base64.getDecoder().decode(encrypted.replaceAll(&quot;\n&quot;, &quot;&quot;).getBytes(StandardCharsets.UTF_8));
    String first = new String(firstByte);
    String[] parts = first.split(&quot;--&quot;);
    byte[] secondByte = Base64.getDecoder().decode(parts[0].getBytes(StandardCharsets.UTF_8));
    String second = new String(secondByte);
    String[] parts2 = second.split(&quot;--&quot;);

    byte[] encryptedData = Base64.getDecoder().decode(parts2[0].getBytes(StandardCharsets.UTF_8));

    SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);

    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(new byte[16]));
    byte[] result = cipher.doFinal(encryptedData);

    return new String(result);
}

public static void main(String[] args) throws Exception {
    String encrypted = &quot;S3l0cVEybDRUM2sxU1hFMk5YVlhOa3A2VXpRNFEyZFFibTVwZVdRMVdEUlpN\n&quot; +
            &quot;bkkxUzBaUGNsbFJaejB0TFRWWlVtVkNVWEJXZWxselJuWkVhbFJyWlU5VmNr\n&quot; +
            &quot;RTlQUT09LS0yZDA5M2FhZTg0OTJjZmIyZjdiNDA0ZWVkNGU2ZmQ4NDQ1ZTM4\n&quot; +
            &quot;ZjIx&quot;;
    System.out.println(&quot;Decrypted: &quot; + decrypt(encrypted));
    }
}
</code></pre>
<p>Result  ?'??m?Q????
What could be the reason?</p>
"	NULL	4	NULL	00:38.4	0	26:55.8	26:55.8	NULL	11022024	11022024	0	1	0	<java><ruby><encryption>	Encrypt Ruby decrypt Java	133	Yes	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
73915165	0	NULL	"<p>In my code, I specify</p>
<p><code>       val cipher = Cipher.getInstance(&quot;AES_128/GCM/NoPadding&quot;)</code></p>
<p>and when I do the following code to supply my own IV</p>
<pre><code>        cipher.init(Cipher.ENCRYPT_MODE, secretKey, IvParameterSpec(nonceByteArray, 0, 16))
</code></pre>
<p>I get the following error saying it has to be of length 12, but I I thought the IV should be 16 if we choose AES_128?</p>
<pre><code>Caused by: java.security.InvalidAlgorithmParameterException: Expected IV length of 12 but was 16
</code></pre>
"	NULL	NULL	NULL	06:29.2	NULL	NULL	NULL	NULL	NULL	3718584	0	1	0	<android><encryption><bouncycastle>	How to add IV to Cipher in Android?	89	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
73940873	0	NULL	"<p>I have an <code>EncryptionManager</code> class that is used to encrypt and decrypt data using the Android KeyStore. The implementation works fine for 99% of users, but for some of them we are seeing occasional obscure crashes such as</p>
<pre><code>Fatal Exception: java.security.InvalidKeyException: Keystore operation failed
   at android.security.KeyStore.getInvalidKeyException(KeyStore.java:1693)
   at android.security.KeyStore.getInvalidKeyException(KeyStore.java:1750)
   at android.security.keystore.KeyStoreCryptoOperationUtils.getInvalidKeyExceptionForInit(KeyStoreCryptoOperationUtils.java:54)
   at android.security.keystore.KeyStoreCryptoOperationUtils.getExceptionForCipherInit(KeyStoreCryptoOperationUtils.java:89)
   at android.security.keystore.AndroidKeyStoreCipherSpiBase.ensureKeystoreOperationInitialized(AndroidKeyStoreCipherSpiBase.java:265)
   at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineInit(AndroidKeyStoreCipherSpiBase.java:109)
   at javax.crypto.Cipher.tryTransformWithProvider(Cipher.java:2984)
   at javax.crypto.Cipher.tryCombinations(Cipher.java:2891)
   at javax.crypto.Cipher$SpiAndProviderUpdater.updateAndGetSpiAndProvider(Cipher.java:2796)
   at javax.crypto.Cipher.chooseProvider(Cipher.java:773)
   at javax.crypto.Cipher.init(Cipher.java:1143)
   at javax.crypto.Cipher.init(Cipher.java:1084)
   at com.app.encryption.implementation.EncryptionManager.encryptData(EncryptionManager.kt:39)
Caused by android.security.KeyStoreException: Key not found
   at android.security.KeyStore.getKeyStoreException(KeyStore.java:1555)
   at android.security.KeyStore.getInvalidKeyException(KeyStore.java:1750)
   at android.security.keystore.KeyStoreCryptoOperationUtils.getInvalidKeyExceptionForInit(KeyStoreCryptoOperationUtils.java:54)
   at android.security.keystore.KeyStoreCryptoOperationUtils.getExceptionForCipherInit(KeyStoreCryptoOperationUtils.java:89)
   at android.security.keystore.AndroidKeyStoreCipherSpiBase.ensureKeystoreOperationInitialized(AndroidKeyStoreCipherSpiBase.java:265)
   at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineInit(AndroidKeyStoreCipherSpiBase.java:109)
   at javax.crypto.Cipher.tryTransformWithProvider(Cipher.java:2984)
   at javax.crypto.Cipher.tryCombinations(Cipher.java:2891)
   at javax.crypto.Cipher$SpiAndProviderUpdater.updateAndGetSpiAndProvider(Cipher.java:2796)
   at javax.crypto.Cipher.chooseProvider(Cipher.java:773)
   at javax.crypto.Cipher.init(Cipher.java:1143)
   at javax.crypto.Cipher.init(Cipher.java:1084)
   at com.app.encryption.implementation.EncryptionManager.encryptData(EncryptionManager.kt:39)
</code></pre>
<p>and</p>
<pre><code>Fatal Exception: javax.crypto.BadPaddingException
   at android.security.keystore2.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:609)
   at javax.crypto.Cipher.doFinal(Cipher.java:2056)
   at com.app.encryption.implementation.EncryptionManager.decryptData(EncryptionManager.kt:68)
Caused by android.security.KeyStoreException: Invalid argument
   at android.security.KeyStore2.getKeyStoreException(KeyStore2.java:356)
   at android.security.KeyStoreOperation.handleExceptions(KeyStoreOperation.java:78)
   at android.security.KeyStoreOperation.finish(KeyStoreOperation.java:127)
   at android.security.keystore2.KeyStoreCryptoOperationChunkedStreamer$MainDataStream.finish(KeyStoreCryptoOperationChunkedStreamer.java:228)
   at android.security.keystore2.KeyStoreCryptoOperationChunkedStreamer.doFinal(KeyStoreCryptoOperationChunkedStreamer.java:181)
   at android.security.keystore2.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:603)
   at javax.crypto.Cipher.doFinal(Cipher.java:2056)
   at com.app.encryption.implementation.EncryptionManager.decryptData(EncryptionManager.kt:68)
</code></pre>
<p>It also seems to happen only on less common devices like the Motorola Edge Plus, the Moto G Pure, the Nokia X100, and other misc devices. I haven't seen these crashes happen on a Pixel or any other widely popular device.</p>
<p>My <code>EncryptionManager</code> class looks like this:</p>
<pre><code>class EncryptionManager {

  private val cipher by lazy {
      Cipher.getInstance(TRANSFORMATION_PATTERN)
  }

  private val charset by lazy {
      charset(CHARSET_NAME)
  }

  private val keyStore by lazy {
      KeyStore.getInstance(KEY_STORE_TYPE).apply {
          load(null)
      }
  }

  private val keyGenerator by lazy {
      KeyGenerator.getInstance(KEY_ALGORITHM_AES, KEY_STORE_TYPE)
  }

  fun encryptData(keyAlias: String, data: String): String {
      return cipher.run {
          init(Cipher.ENCRYPT_MODE, generateSecretKey(keyAlias))

          val ivString = Base64.encodeToString(iv, Base64.DEFAULT)
          var stringToEncrypt = ivString + IV_SEPARATOR
          val bytes = doFinal(data.toByteArray(charset))

          stringToEncrypt += Base64.encodeToString(bytes, Base64.DEFAULT)
          stringToEncrypt
      }
  }

  fun decryptData(keyAlias: String, encryptedData: String): String {
      return cipher.run {
          val split = encryptedData.split(IV_SEPARATOR.toRegex())

          if (split.size != 2) {
              throw IllegalArgumentException(IV_ERROR_MESSAGE)
          }

          val ivString = split[0]
          val encryptedString = split[1]
          val ivSpec = IvParameterSpec(Base64.decode(ivString, Base64.DEFAULT))

          init(
              Cipher.DECRYPT_MODE,
              getSecretKey(keyAlias),
              ivSpec,
          )

          val decryptedData = doFinal(Base64.decode(encryptedString, Base64.DEFAULT))
          String(decryptedData)
      }
  }

  fun deleteAllData() {
      val aliases = keyStore.aliases().iterator()
      aliases.forEach {
          try {
              keyStore.deleteEntry(it)
          } catch (e: Exception) {
              Timber.e(e)
          }
      }
  }

  private fun generateSecretKey(keyAlias: String): SecretKey {
      return keyGenerator.apply {
          init(
              KeyGenParameterSpec
                  .Builder(keyAlias, PURPOSE_ENCRYPT or PURPOSE_DECRYPT)
                  .setBlockModes(BLOCK_MODE_CBC)
                  .setEncryptionPaddings(ENCRYPTION_PADDING_PKCS7)
                  .build(),
          )
      }.generateKey()
  }

  private fun getSecretKey(keyAlias: String): SecretKey {
      return (keyStore.getEntry(keyAlias, null) as KeyStore.SecretKeyEntry).secretKey
  }

  companion object {
      private const val TRANSFORMATION_PATTERN = &quot;AES/CBC/PKCS7Padding&quot;
      private const val KEY_STORE_TYPE = &quot;AndroidKeyStore&quot;
      private const val CHARSET_NAME = &quot;UTF-8&quot;
      private const val IV_SEPARATOR = &quot;]&quot;
      private const val IV_ERROR_MESSAGE = &quot;Passed data is incorrect. There was no IV specified with it.&quot;
  }
}
</code></pre>
<p>I've spent the last week searching other KeyStore related issues, but I haven't been able to find anything that might explain why the crashes are only happening to a small subset of users. Is there something wrong with my <code>EncryptionManager</code> implementation? Something else I'm missing?</p>
"	NULL	NULL	NULL	10:58.9	NULL	NULL	NULL	NULL	NULL	6042392	0	1	2	<android><encryption><android-keystore>	Obscure KeyStoreException errors when encrypting and decrypting data	146	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
73995194	0	NULL	"<p>I'm using &quot;AES/ECB/PKCS5Padding&quot; and trying to decrypt the message in Android Kotlin. I received the error message as &quot;Cipher functions:OPENSSL_internal:WRONG_FINAL_BLOCK_LENGTH&quot;. The same code I have used in Android Java and it is working fine, when I tried to convert the same to kotlin, I received error message.</p>
<pre><code>fun decryptMsg(cipherText: ByteArray?, secret: SecretKey?): String? {
        var cipher: Cipher? = null
        cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;)
        cipher.init(Cipher.DECRYPT_MODE, secret)
        return String(cipher.doFinal(cipherText), charset(&quot;UTF-8&quot;))
    }

</code></pre>
<p>Please let me know my above syntax of coding is correct in kotlin aspect of view.</p>
"	NULL	NULL	NULL	30:37.9	NULL	NULL	NULL	NULL	NULL	11567506	0	1	0	<android><kotlin><encryption>	Getting message - Cipher functions:OPENSSL_internal:WRONG_FINAL_BLOCK_LENGTH in android kotlin	31	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74011121	0	NULL	"<p>I am having some issues with decoding AES256. I do some experimentation with couple of micro services that talk to each other.</p>
<pre><code>import base64

from Crypto.Cipher import AES
from Crypto.Hash import SHA512
from Crypto.Random import get_random_bytes
import secrets
import random
import string
from Crypto.Util import Counter


def generateKey():
    key = base64.b64encode(secrets.token_bytes(16))
    iv = secrets.token_bytes(16)
    return key.decode(&quot;utf-8&quot;), iv


def encryptAES(key, iv, raw):
    raw_2 = raw.encode(&quot;utf-8&quot;)
    cipher = AES.new(key.encode(&quot;utf-8&quot;), AES.MODE_CFB, iv, segment_size=128)
    encrypted = base64.b64encode(iv + cipher.encrypt(raw_2))
    return encrypted.decode(&quot;utf-8&quot;)


def decryptAES(msg, key):
    raw_2 = msg.encode(&quot;ascii&quot;)
    iv = raw_2[:16]
    cipher = AES.new(key.encode(&quot;utf-8&quot;), AES.MODE_CFB, iv, segment_size=128)
    cipher_decrypt = cipher.decrypt(raw_2[16:])
    cipher_decrypt_b64 = base64.b64encode(cipher_decrypt)
    return cipher_decrypt_b64.decode(&quot;utf-8&quot;)


initial_data = &quot;Empty string&quot;
keys = generateKey()
encrypted_data = encryptAES(keys[0], keys[1], initial_data)
print(encrypted_data)
print(decryptAES(msg=encrypted_data, key=keys[0]))
</code></pre>
<p>What is confusing for me that other Java service decrypts this</p>
<pre><code> public String decrypt(String encrypted_encoded_string, String KEY){

        String plain_text = &quot;&quot;;
        try{
            byte[] encrypted_decoded_bytes = Base64.getDecoder().decode(encrypted_encoded_string);
            String encrypted_decoded_string = new String(encrypted_decoded_bytes);
            String iv_string = encrypted_decoded_string.substring(0,16); //IV is retrieved correctly.

            IvParameterSpec iv = new IvParameterSpec(Arrays.copyOf(encrypted_decoded_bytes, 16));
            SecretKeySpec skeySpec = new SecretKeySpec(KEY.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CFB/NoPadding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            plain_text = new String(cipher.doFinal(Arrays.copyOfRange(encrypted_decoded_bytes, 16, encrypted_decoded_bytes.length)));//Returns garbage characters
            return plain_text;

        }  catch (Exception e) {
            Log.i(TAG, e.getMessage());
        }
        return plain_text;
    }
</code></pre>
<p>Only python part seems not good :(
Is it about iv ?</p>
<p>I done some research, couldn't find an answer.</p>
<p>Thanks :)</p>
<p>EDIT working solution from answer:</p>
<pre><code>def decryptAES(msg, key):
    raw_2 = base64.b64decode(msg)

    # raw_2 = msg.encode(&quot;ascii&quot;)
    iv = raw_2[:16]
    cipher = AES.new(key.encode(&quot;utf-8&quot;), AES.MODE_CFB, iv, segment_size=128)
    cipher_decrypt = cipher.decrypt(raw_2[16:])
    # cipher_decrypt_b64 = base64.b64encode(cipher_decrypt)
    return cipher_decrypt.decode(&quot;utf-8&quot;)
</code></pre>
"	NULL	NULL	NULL	49:47.6	NULL	NULL	NULL	NULL	NULL	10807018	0	1	0	<python><aes>	Python AES256 not decoding correctly	68	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74014629	74015720	NULL	"<pre><code>const forge = require('node-forge');

    const json = { number: '9246753466',
            lob:'Prepaid',
            firstName:'Mr. XYZ',
            leadId:'yLWJjN2YtYWVlM2',
            address:
            {
                addressLine1: 'address line 1',
                addressLine2: 'address line 2 ',
                city: 'Delhi',
                pincode: '123456',
            },
        };
    let pk = 'SEC_PRV_KEY';
         let iv = forge.random.getBytesSync(16);
    
    // // (other modes include: ECB, CFB, OFB, CTR, and GCM)
    // // Note: CBC and ECB modes use PKCS#7 padding as default
        const AES_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;
        let cipher = forge.cipher.createCipher('AES-CBC', pk.toString('utf-8'));
        cipher.start({ iv });
        //cipher.update(forge.util.createBuffer(AES_PADDING));
        cipher.update(forge.util.createBuffer(JSON.stringify(json), 'utf-8'));
        cipher.finish();
        let encrypted = cipher.output;
    // outputs encrypted hex
        console.log(forge.util.encode64(Buffer.from(cipher.output.data).toString('utf-8')));
        console.log('done');
</code></pre>
<p>The above code is for the encryption logic.
Below is the decryption logic in java :-</p>
<pre><code>public static final String UTF8 = &quot;UTF-8&quot;;
    private static final String AES_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;
    public static final String AES = &quot;AES&quot;;
    public static String decrypt(String encryptedString, String privateKey) {
            try {
                Cipher cipher = Cipher.getInstance(AES_PADDING);
                cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(privateKey.getBytes(StandardCharsets.
                                UTF_8), AES),
                        new IvParameterSpec(new byte[16]));
                byte[] decryptedText = cipher.doFinal(Base64.decodeBase64(encryptedString));
                return new String(decryptedText);
            } catch (NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException |
                    NoSuchAlgorithmException
                    | InvalidKeyException | InvalidAlgorithmParameterException e) {
                System.out.println(e.getMessage());
                return null;
            }
        }
</code></pre>
<p>The first few characters of the decrypted string are not matching with initial input. Can anyone help me figure out what is wrong ? I can't change the java code, but I can change the node js code.</p>
"	NULL	NULL	NULL	00:42.4	NULL	NULL	NULL	NULL	NULL	2819720	0	1	-1	<java><node.js><aes><cbc-mode><node-forge>	Java code not able to decrypt the encrypted string of node js	45	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74022882	0	NULL	"<pre><code>package com.example;

import org.apache.commons.codec.binary.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * &lt;h3&gt;aestools&lt;/h3&gt;
 *
 * @author wangzhe
 * @version 1.0.2
 * @createTime 2022/8/23 15:30
 */
public class App {

    private static final String TOKEN = &quot;6e4292f87a5c4c34&quot;;

    public static void main(String[] args) {
        try {
            String encrypt = encrypt(&quot;2000.0&quot;, TOKEN);
            System.out.println(encrypt);

            String decrypt = decrypt(encrypt, TOKEN);
            System.out.println(decrypt);

        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }
    }


    /**
     * encrypt
     * @param content 
     * @param token 
     * @return 
     */
    public static String encrypt(String content,String token)
            throws NoSuchAlgorithmException, NoSuchPaddingException,
            UnsupportedEncodingException, InvalidKeyException,
            InvalidAlgorithmParameterException, IllegalBlockSizeException,
            BadPaddingException{
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
        byte[] raw = token.getBytes(StandardCharsets.UTF_8);
        SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);
        IvParameterSpec iv = new IvParameterSpec(raw);
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
        byte[] encrypted = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8));
        byte[] encodeBase64 = Base64.encodeBase64URLSafe(encrypted);
        return new String(encodeBase64, StandardCharsets.UTF_8) ;
    }

    /**
     * decrypt
     * @param content
     * @param token
     * @return
     */
    public static String decrypt(String content,String token)
            throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, InvalidAlgorithmParameterException,
            UnsupportedEncodingException, IllegalBlockSizeException,
            BadPaddingException{
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
        byte[] raw = token.getBytes(StandardCharsets.UTF_8);
        IvParameterSpec iv = new IvParameterSpec(raw);
        SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;);
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
        byte[] encrypted = cipher.doFinal(Base64.decodeBase64(content));
        return new String(encrypted, StandardCharsets.UTF_8);
    }

}
</code></pre>
<p>run the java code, the encryption result is &quot;zVRUDe0VY-0CdMFJXcOJ3A&quot;,
decryption result is '2000.0'</p>
<p>the following i use encryption method in openresty using lua:</p>
<pre><code>local function AES128CBC_Encrypt(price, key, iv)
        local aes128cbc, _ = aes:new(key, nil, aes.cipher(128, 'cbc'), {iv = string.rep(string.char(0), 16)})
        return aes128cbc:encrypt(aes128cbc, price)

end
</code></pre>
<p>but the encrption result is &quot;-^c?6???|??=&quot; which is diff from the java code result. i guess should do some processing on the token first. but i dont know.</p>
<p>and, i attach aes.lua code in openresty:</p>
<pre><code>local asn1 = require &quot;resty.asn1&quot;
local ffi = require &quot;ffi&quot;
local ffi_new = ffi.new
local ffi_gc = ffi.gc
local ffi_str = ffi.string
local ffi_copy = ffi.copy
local C = ffi.C
local setmetatable = setmetatable
--local error = error
local type = type


local _M = { _VERSION = '0.11' }

local mt = { __index = _M }


ffi.cdef[[
typedef struct engine_st ENGINE;

typedef struct evp_cipher_st EVP_CIPHER;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;

typedef struct env_md_ctx_st EVP_MD_CTX;
typedef struct env_md_st EVP_MD;

const EVP_MD *EVP_md5(void);
const EVP_MD *EVP_sha(void);
const EVP_MD *EVP_sha1(void);
const EVP_MD *EVP_sha224(void);
const EVP_MD *EVP_sha256(void);
const EVP_MD *EVP_sha384(void);
const EVP_MD *EVP_sha512(void);

const EVP_CIPHER *EVP_aes_128_ecb(void);
const EVP_CIPHER *EVP_aes_128_cbc(void);
const EVP_CIPHER *EVP_aes_128_cfb1(void);
const EVP_CIPHER *EVP_aes_128_cfb8(void);
const EVP_CIPHER *EVP_aes_128_cfb128(void);
const EVP_CIPHER *EVP_aes_128_ofb(void);
const EVP_CIPHER *EVP_aes_128_ctr(void);
const EVP_CIPHER *EVP_aes_192_ecb(void);
const EVP_CIPHER *EVP_aes_192_cbc(void);
const EVP_CIPHER *EVP_aes_192_cfb1(void);
const EVP_CIPHER *EVP_aes_192_cfb8(void);
const EVP_CIPHER *EVP_aes_192_cfb128(void);
const EVP_CIPHER *EVP_aes_192_ofb(void);
const EVP_CIPHER *EVP_aes_192_ctr(void);
const EVP_CIPHER *EVP_aes_256_ecb(void);
const EVP_CIPHER *EVP_aes_256_cbc(void);
const EVP_CIPHER *EVP_aes_256_cfb1(void);
const EVP_CIPHER *EVP_aes_256_cfb8(void);
const EVP_CIPHER *EVP_aes_256_cfb128(void);
const EVP_CIPHER *EVP_aes_256_ofb(void);

EVP_CIPHER_CTX *EVP_CIPHER_CTX_new();
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);

int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
        ENGINE *impl, unsigned char *key, const unsigned char *iv);

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
        const unsigned char *in, int inl);

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
        ENGINE *impl, unsigned char *key, const unsigned char *iv);

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
        const unsigned char *in, int inl);

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

int EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
        const unsigned char *salt, const unsigned char *data, int datal,
        int count, unsigned char *key,unsigned char *iv);
]]

local hash
hash = {
    md5 = C.EVP_md5(),
    sha1 = C.EVP_sha1(),
    sha224 = C.EVP_sha224(),
    sha256 = C.EVP_sha256(),
    sha384 = C.EVP_sha384(),
    sha512 = C.EVP_sha512()
}
_M.hash = hash

local cipher
cipher = function (size, _cipher)
    local _size = size or 128
    local _cipher = _cipher or &quot;cbc&quot;
    local func = &quot;EVP_aes_&quot; .. _size .. &quot;_&quot; .. _cipher
    if C[func] then
        return { size=_size, cipher=_cipher, method=C[func]()}
    else
        return nil
    end
end
_M.cipher = cipher

function _M.new(self, key, salt, _cipher, _hash, hash_rounds)
    local encrypt_ctx = C.EVP_CIPHER_CTX_new()
    if encrypt_ctx == nil then
        return nil, &quot;no memory&quot;
    end

    ffi_gc(encrypt_ctx, C.EVP_CIPHER_CTX_free)

    local decrypt_ctx = C.EVP_CIPHER_CTX_new()
    if decrypt_ctx == nil then
        return nil, &quot;no memory&quot;
    end

    ffi_gc(decrypt_ctx, C.EVP_CIPHER_CTX_free)

    local _cipher = _cipher or cipher()
    local _hash = _hash or hash.md5
    local hash_rounds = hash_rounds or 1
    local _cipherLength = _cipher.size/8
    local gen_key = ffi_new(&quot;unsigned char[?]&quot;,_cipherLength)
    local gen_iv = ffi_new(&quot;unsigned char[?]&quot;,_cipherLength)

    if type(_hash) == &quot;table&quot; then
        if not _hash.iv or #_hash.iv ~= 16 then
          return nil, &quot;bad iv&quot;
        end

        if _hash.method then
            local tmp_key = _hash.method(key)

            if #tmp_key ~= _cipherLength then
                return nil, &quot;bad key length&quot;
            end

            ffi_copy(gen_key, tmp_key, _cipherLength)

        elseif #key ~= _cipherLength then
            return nil, &quot;bad key length&quot;

        else
            ffi_copy(gen_key, key, _cipherLength)
        end

        ffi_copy(gen_iv, _hash.iv, 16)

    else
        if salt and #salt ~= 8 then
            return nil, &quot;salt must be 8 characters or nil&quot;
        end

        if C.EVP_BytesToKey(_cipher.method, _hash, salt, key, #key,
                            hash_rounds, gen_key, gen_iv)
            ~= _cipherLength
        then
            return nil
        end
    end

    if C.EVP_EncryptInit_ex(encrypt_ctx, _cipher.method, nil,
      gen_key, gen_iv) == 0 or
      C.EVP_DecryptInit_ex(decrypt_ctx, _cipher.method, nil,
      gen_key, gen_iv) == 0 then
        return nil
    end

    return setmetatable({
      _encrypt_ctx = encrypt_ctx,
      _decrypt_ctx = decrypt_ctx
      }, mt)
end


function _M.encrypt(self, s)
    local s_len = #s
    local max_len = s_len + 16
    local buf = ffi_new(&quot;unsigned char[?]&quot;, max_len)
    local out_len = ffi_new(&quot;int[1]&quot;)
    local tmp_len = ffi_new(&quot;int[1]&quot;)
    local ctx = self._encrypt_ctx

    if C.EVP_EncryptInit_ex(ctx, nil, nil, nil, nil) == 0 then
        return nil
    end

    if C.EVP_EncryptUpdate(ctx, buf, out_len, s, s_len) == 0 then
        return nil
    end

    if C.EVP_EncryptFinal_ex(ctx, buf + out_len[0], tmp_len) == 0 then
        return nil
    end

    return ffi_str(buf, out_len[0] + tmp_len[0])
end


function _M.decrypt(self, s)
    local s_len = #s
    local buf = ffi_new(&quot;unsigned char[?]&quot;, s_len)
    local out_len = ffi_new(&quot;int[1]&quot;)
    local tmp_len = ffi_new(&quot;int[1]&quot;)
    local ctx = self._decrypt_ctx

    if C.EVP_DecryptInit_ex(ctx, nil, nil, nil, nil) == 0 then
      return nil
    end

    if C.EVP_DecryptUpdate(ctx, buf, out_len, s, s_len) == 0 then
      return nil
    end

    if C.EVP_DecryptFinal_ex(ctx, buf + out_len[0], tmp_len) == 0 then
        return nil
    end

    return ffi_str(buf, out_len[0] + tmp_len[0])
end


return _M
</code></pre>
"	NULL	NULL	NULL	08:39.1	NULL	NULL	NULL	NULL	NULL	20060465	0	1	0	<java><lua><openresty>	aes128cbc encryption method in java code switch to lua code but have difference	56	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74027196	0	NULL	"<p>I created a Java program that has to make a SSH connection and execute <code>ls</code> on an Linux archive.</p>
<p>It works fine when I run this code on a Linux system using JSch. However, I try to make the program run on a Windows machine, it exits without any message at <code>session.connect()</code>.</p>
<p>Using Log4j, the only thing I do know is, that it stops at the <code>session.connect()</code> line.</p>
<p>Is there a difference in using Jsch from Linux and Windows?</p>
<p>Below is the code for the connection.</p>
<pre class=""lang-java prettyprint-override""><code>public void openSession() {

    JSch jsch = new JSch();

    try {
        session = jsch.getSession(user, host, port);
        session.setPassword(password);
        session.setConfig(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);
        System.out.println(&quot;Establishing Connection...&quot;);
        logger.info(&quot;Establishing Connection...&quot;);
        session.connect();
        System.out.println(&quot;Connection established.&quot;);
        logger.info(&quot;Connection established.&quot;);
        System.out.println(&quot;Creating SFTP Channel.&quot;);
        logger.info(&quot;Connection established.&quot;);
        sftpChannel = (ChannelSftp) session.openChannel(&quot;sftp&quot;);
        sftpChannel.connect();
        System.out.println(&quot;SFTP Channel created.&quot;);
        logger.info(&quot;SFTP Channel created.&quot;);
    } catch (JSchException e) {
        StringWriter errors = new StringWriter();
        e.printStackTrace(new PrintWriter(errors));
        logger.error(errors);
        logger.error(e.getCause());
    }

}
</code></pre>
<p>Here is the exception, that seems to cause the issue:</p>
<pre class=""lang-none prettyprint-override""><code>Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError
        at java.base/javax.crypto.Cipher.getInstance(Cipher.java:548)
        at com.jcraft.jsch.jce.AES256CTR.init(AES256CTR.java:56)
        at com.jcraft.jsch.Session.checkCipher(Session.java:2497)
        at com.jcraft.jsch.Session.checkCiphers(Session.java:2474)
        at com.jcraft.jsch.Session.send_kexinit(Session.java:624)
        at com.jcraft.jsch.Session.connect(Session.java:307)
        at com.jcraft.jsch.Session.connect(Session.java:183)
        at controller.SshFileHandler.openSession(SshFileHandler.java:241)
        at controller.SshFileHandler.&lt;init&gt;(SshFileHandler.java:50)
        at controller.MainController.selectDataSource(MainController.java:69)
        at controller.MainController.run(MainController.java:42)
        at controller.Application.main(Application.java:22)
Caused by: java.lang.SecurityException: Can not initialize cryptographic mechanism
        at java.base/javax.crypto.JceSecurity.&lt;clinit&gt;(JceSecurity.java:119)
        ... 12 more
Caused by: java.lang.SecurityException: Can't read cryptographic policy directory: unlimited
        at java.base/javax.crypto.JceSecurity.setupJurisdictionPolicies(JceSecurity.java:333)
        at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:110)
        at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:107)
        at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
        at java.base/javax.crypto.JceSecurity.&lt;clinit&gt;(JceSecurity.java:106)
        ... 12 more
</code></pre>
"	NULL	NULL	NULL	13:28.0	NULL	NULL	NULL	NULL	NULL	17733143	0	1	0	<java><ssh><jsch>	"Why does JSch work on a Linux system, but not on Windows?"	155	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74028210	74042265	NULL	"<p>When I encrypt plain text using Dart,and encrypted text is decrypted from Java code, I get this error:</p>
<pre class=""lang-none prettyprint-override""><code>javax.crypto.BadPaddingException: pad block corrupted
  at org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher$BufferedGenericBlockCipher.doFinal(Unknown Source)
  at org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(Unknown Source)
  at javax.crypto.Cipher.doFinal(Cipher.java:2168)
  at AesUtil.doFinal(AesUtil.java:75)
  at AesUtil.decrypt(AesUtil.java:60)
  at Main.main(Main.java:18)
</code></pre>
<p>Same IV, salt and passphase value using Java side for key generation, but the generated key is different and also cipher test is different. I am using same method for key generation. I don't know what is missing in Dart code.</p>
<pre class=""lang-yaml prettyprint-override""><code>dependencies:
    encrypt: ^5.0.1
    hex: ^0.2.0
    password_hash_plus: ^4.0.0
</code></pre>
<p>Dart code is:</p>
<pre class=""lang-dart prettyprint-override""><code>var random = Random.secure();
var values = List&lt;int&gt;.generate(16, (i) =&gt; random.nextInt(255));

// final salt = aes.IV.fromSecureRandom(16);
final salt = hex.encode(values);
final generator = PBKDF2(hashAlgorithm: sha1);
final key = aes.Key.fromBase64(generator.generateBase64Key(&quot;1234567891234567&quot;, salt, 1000, 16));


final iv = aes.IV.fromSecureRandom(16);

final encrypter =
    aes.Encrypter(aes.AES(key, mode: aes.AESMode.cbc, padding: 'PKCS7'));
final encrypted = encrypter.encrypt(st.password!, iv: iv);

var str = '${iv.base16}::${salt}::${encrypted.base64}';
var bytes = utf8.encode(str);
var base64Str = base64.encode(bytes);


//final decrypt = encrypter.decrypt64(&quot;/vvAYMc3rgCvPvuSVU/qQw==&quot;, iv: iv);

print(
    '------------------------------,\n encrypt ${(encrypted.base64)}-----------'
     //'--\ndecrypted ${decrypt}-----------base64--------$base64Str-----'
    '\nkey = ${key.base64} array--\niv = ${iv.base16}--salt= {${salt}');
</code></pre>
<p>And Java code is:</p>
<pre class=""lang-java prettyprint-override""><code>class Main {
    public static void main(String[] args) {
        AesUtil aesUtil = new AesUtil();
        String encrypt = aesUtil.encrypt(&quot;b9266c74df614967d9acaa2878bff87c&quot;, &quot;6ab7c799d6411f9d0c8e048ad526eeee&quot;, &quot;1234567891234567&quot;, &quot;Jitu@123456&quot;);
        String a = aesUtil.decrypt(&quot;01e6a073a4255c92e704bd94d76d75c5&quot;, &quot;98a21e07ed34afc523c5f5938c9202db&quot;, &quot;1234567891234567&quot;, &quot;MumTfpnzZh9bk94yiTuA+g==&quot;);

        System.out.println(&quot;encrypt = &quot; + encrypt + &quot; \ndecrpty valaue----&quot; + a);
    }
}
</code></pre>
<p>Encryption code in Java:</p>
<pre class=""lang-java prettyprint-override""><code>import java.io.UnsupportedEncodingException;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;
import org.springframework.stereotype.Component;

public class AesUtil {
    private final int keySize;
    private final int iterationCount;
    private final Cipher cipher;

    public AesUtil() {
        this.keySize = 128;
        this.iterationCount = 1000;
        try {
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;, &quot;BC&quot;);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            e.printStackTrace();
            throw fail(e);
        } catch (NoSuchProviderException e) {
            throw new RuntimeException(e);
        }
    }

    public String encrypt(String salt, String iv, String passphrase, String plaintext) {
        try {
            SecretKey key = generateKey(salt, passphrase);
            System.out.println(&quot;encryption key-------= &quot; + base64(key.getEncoded()));
            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, key, iv, plaintext.getBytes(&quot;ISO-8859-1&quot;));
            return base64(encrypted);
        } catch (UnsupportedEncodingException e) {
            throw fail(e);
        }
    }

    public String decrypt(String salt, String iv, String passphrase, String ciphertext) {
        try {
            SecretKey key = generateKey(salt, passphrase);
            System.out.println(&quot;decrypt key-------= &quot; + base64(key.getEncoded()));
            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, key, iv, base64(ciphertext));
            return new String(decrypted, &quot;ISO-8859-1&quot;);
        } catch (UnsupportedEncodingException e) {
            return null;
        } catch (Exception e) {
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) {
        try {
            IvParameterSpec IivParameterSpec = new IvParameterSpec(hex(iv));
            System.out.println(&quot;----iv--= &quot; + hex(IivParameterSpec.getIV()));
            cipher.init(encryptMode, key, IivParameterSpec);
            return cipher.doFinal(bytes);
        } catch (InvalidKeyException
                 | InvalidAlgorithmParameterException
                 | IllegalBlockSizeException
                 | BadPaddingException e) {
            e.printStackTrace();
            return null;
        }
    }

    private SecretKey generateKey(String salt, String passphrase) {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            byte[] s = hex(salt);
            System.out.println(&quot;salt-= &quot; + hex(s));
            KeySpec spec = new PBEKeySpec(passphrase.toCharArray(), s, iterationCount, keySize);

            SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
            return key;
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            return null;
        }
    }

    public static String random(int length) {
        byte[] salt = new byte[length];
        new SecureRandom().nextBytes(salt);
        return hex(salt);
    }

    public static String base64(byte[] bytes) {
        return Base64.encodeBase64String(bytes);
    }

    public static byte[] base64(String str) {
        return Base64.decodeBase64(str);
    }

    public static String hex(byte[] bytes) {
        return Hex.encodeHexString(bytes);
    }

    public static byte[] hex(String str) {
        try {
            return Hex.decodeHex(str.toCharArray());
        } catch (DecoderException e) {
            throw new IllegalStateException(e);
        }
    }

    private IllegalStateException fail(Exception e) {
        return null;
    }

    public static byte[][] GenerateKeyAndIV(int keyLength, int ivLength, int iterations, byte[] salt, byte[] password, MessageDigest md) {

        int digestLength = md.getDigestLength();
        int requiredLength = (keyLength + ivLength + digestLength - 1) / digestLength * digestLength;
        byte[] generatedData = new byte[requiredLength];
        int generatedLength = 0;

        try {
            md.reset();

            // Repeat process until sufficient data has been generated
            while (generatedLength &lt; keyLength + ivLength) {

                // Digest data (last digest if available, password data, salt if available)
                if (generatedLength &gt; 0)
                    md.update(generatedData, generatedLength - digestLength, digestLength);
                md.update(password);
                if (salt != null)
                    md.update(salt, 0, 8);
                md.digest(generatedData, generatedLength, digestLength);

                // additional rounds
                for (int i = 1; i &lt; iterations; i++) {
                    md.update(generatedData, generatedLength, digestLength);
                    md.digest(generatedData, generatedLength, digestLength);
                }

                generatedLength += digestLength;
            }

            // Copy key and IV into separate byte arrays
            byte[][] result = new byte[2][];
            result[0] = Arrays.copyOfRange(generatedData, 0, keyLength);
            if (ivLength &gt; 0)
                result[1] = Arrays.copyOfRange(generatedData, keyLength, keyLength + ivLength);

            return result;

        } catch (DigestException e) {
            throw new RuntimeException(e);

        } finally {
            // Clean out temporary data
            Arrays.fill(generatedData, (byte) 0);
        }
    }
}
</code></pre>
"	NULL	NULL	NULL	32:10.7	NULL	NULL	NULL	NULL	NULL	9758013	0	1	0	<java><flutter><dart><encryption>	Plain text encrypt from Dart code but decrypt from Java code	118	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74069080	0	NULL	"<p>I have 2 different apps, the server side and the client side. Both of them include my &quot;encriptador&quot; class.
It works flawlessly without encryption, the problem comes when I try to consume my response as a SealedObject.
This is the error I'm having returned:</p>
<pre><code>Caused by: org.springframework.ws.soap.client.SoapFaultClientException: No adapter for endpoint [public javax.crypto.SealedObject com.pv.soap.servidor.UserEndpoint.getUser(io.spring.pv.servidor.GetUserRequest)]: Is your endpoint annotated with @Endpoint, or does it implement a supported interface like MessageHandler or PayloadEndpoint?
    at org.springframework.ws.soap.client.core.SoapFaultMessageResolver.resolveFault(SoapFaultMessageResolver.java:38) ~[spring-ws-core-3.1.3.jar:na]
</code></pre>
<p>However this shouldn't be true. My endpoint is annotated. This is the endpoint in my server side app.</p>
<pre><code>@Endpoint
public class UserEndpoint {
    private static final Encriptador encriptador = new Encriptador();
    private static final String NAMESPACE_URI = &quot;http://spring.io/guides/gs-producing-web-service&quot;;
    private UserRepository userRepository;

    @Autowired
    public UserEndpoint(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @PayloadRoot(namespace = NAMESPACE_URI, localPart = &quot;getUserRequest&quot;)
    @ResponsePayload
    //this method used to return &quot;GetUserResponse&quot;, but I needed to send the response encrypted.
    public SealedObject getUser(@RequestPayload GetUserRequest request) {
        GetUserResponse response = new GetUserResponse();
        response.setUser(userRepository.findUser(request.getId()));
        SealedObject sealed = encriptador.getObjectAES(response);
        return sealed;
    }
}
</code></pre>
<p>And here's the client class in my client side:</p>
<pre><code>public class UsersClient extends WebServiceGatewaySupport {
    private static final Logger log = LoggerFactory.getLogger(UsersClient.class);
    private static final Encriptador encriptador = new Encriptador();

    public GetUserResponse getUser(String user) {

        GetUserRequest request = new GetUserRequest();
        request.setId(user);

        log.info(&quot;LOADING &quot; + user);

   Object response = (getWebServiceTemplate()
              .marshalSendAndReceive(&quot;http://localhost:7000/ws/users&quot;, request,
                       new SoapActionCallback(
                               &quot;http://spring.io/guides/gs-producing-web-service/GetUserRequest&quot;)));

        GetUserResponse decryptedResponse = encriptador.getObjectAESDecrypt((SealedObject) response);
        return decryptedResponse;
    } 
}
</code></pre>
<p>And these are the methods in charge of the encryption itself, in case it is of any interest.</p>
<pre><code>public SealedObject getObjectAES(GetUserResponse data) {
        byte[] iv = new byte[16];
        try {
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            SealedObject sealedObject = new SealedObject(data, cipher);
            return sealedObject;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
    public GetUserResponse getObjectAESDecrypt(SealedObject data) {
        byte[] iv = new byte[16];
        try {
            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);
            Serializable unsealObject = (Serializable) data.getObject(cipher);
            return (GetUserResponse) unsealObject;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

    }
</code></pre>
<p>The request is not encrypted for now, only the response. What am I missing? Shouldn't I be receiving a generic object with the Marshaller to do as I please?</p>
"	NULL	NULL	NULL	16:25.6	NULL	NULL	NULL	NULL	NULL	19830240	0	1	0	<java><spring><encryption><soap>	SOAP Response encryption with Spring	66	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74093529	0	NULL	"<p>I had issue when converting AES encryption from java to php, it show different value result in php, that should show the exact value from java</p>
<p>Java</p>
<pre><code>public class AesUtil {
    private final Cipher cipher;
    public final static String passPhrase = &quot;&quot;;
    public final static String IV = &quot;&quot;; //32bit IV Lenght
    public final static  String SALT = &quot;&quot;;
    public final static int KEY_SIZE = 128;
    public final static int ITERATION_COUNT = 10000;

    public AesUtil() {
        try {
            cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        }
        catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            throw fail(e);
        }
    }
    //Call this function to encrypt some String
    public String encrypt(String passPhrase, String plaintext) {
        try {
            SecretKey key = generateKey(SALT, passPhrase);



            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, key, IV, plaintext.getBytes(&quot;UTF-8&quot;));
            return base64(encrypted);

        }
        catch (UnsupportedEncodingException e) {
            throw fail(e);
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) {
        try {
            cipher.init(encryptMode, key, new IvParameterSpec(hex(IV)));
            return cipher.doFinal(bytes);
        }
        catch (InvalidKeyException
                | InvalidAlgorithmParameterException
                | IllegalBlockSizeException
                | BadPaddingException e) {
            throw fail(e);
        }
    }

    private SecretKey generateKey(String salt, String passphrase) {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
                KeySpec spec = new PBEKeySpec(passphrase.toCharArray(), hex(salt), ITERATION_COUNT, KEY_SIZE);
            SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
            return key;
        }
        catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw fail(e);
        }
    }

    public static String random(int length) {
        byte[] salt = new byte[length];
        new SecureRandom().nextBytes(salt);
        return hex(salt);
    }

    public static String base64(byte[] bytes) {
        return new String(Base64.encodeBase64(bytes));
    }

    public static byte[] base64(String str) {
        return Base64.decodeBase64(str.getBytes());
    }

    public static String hex(byte[] bytes) {
        return Hex.encodeHexString(bytes);
    }

    public static byte[] hex(String str) {
        try {
            return Hex.decodeHex(str.toCharArray());
        }
        catch (DecoderException e) {
            throw new IllegalStateException(e);
        }
    }
    private IllegalStateException fail(Exception e) {
        return new IllegalStateException(e);
    }
}
</code></pre>
<p>this is my code in php version,</p>
<pre><code>&lt;?php
    $password = &quot;&quot;;
        $salt = &quot;&quot;;
        $iv = &quot;&quot;; //32bit IV Lenght
        $length = 16;
        $salt = &quot;&quot;;
        $interation = 10000;
    
        $key1 = mb_convert_encoding($password, &quot;UTF-8&quot;);
        $bytes = openssl_pbkdf2($key1, $salt, $length, $interation, &quot;sha1&quot;);
    
        $bytes2 = hash_pbkdf2(&quot;sha1&quot;, $password, $salt, $interation, $length, true);
    
    
        $ciphertext_b64 = base64_encode(openssl_encrypt($plaintext,&quot;aes-128-cbc&quot;, $bytes2,OPENSSL_RAW_DATA, $iv));

?&gt;
</code></pre>
<p>Please tell me how to solve this problem, if you have any suggestion in different programming language it's no problem, thank you</p>
"	NULL	NULL	NULL	57:00.2	NULL	NULL	NULL	NULL	NULL	9547896	0	1	0	<java><php><aes>	AES with salt from java to PHP get different result	81	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74144009	74144816	NULL	"<p>I have tried several attempts to port this code over to C# but I can not seem to get the outputs to match. Can someone help point me in the direction of what I am missing. I have included the actual code as well as links to online tools to run the samples and see the results.</p>
<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;
 
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
 
public class JavaEncryption {
 
    private static SecretKeySpec secretKey;
    private static byte[] key;

    private static void processEncryptionKey(String secret)
    {
        try
        {
            MessageDigest crypt = MessageDigest.getInstance(&quot;SHA-1&quot;);
            crypt.reset();
            crypt.update(secret.getBytes(&quot;UTF-8&quot;));
            byte[] base_hash = new byte[20];
            base_hash = crypt.digest();

            byte[] buffer = new byte[64];
            for (int i = 0; i &lt; 64; i++) buffer [i] = 0x36;
            for (int i = 0; i &lt; 20; i++) buffer [i] ^= base_hash[i];

            crypt.reset();
            crypt.update(buffer, 0, buffer.length);
            byte[] final_hash = new byte[20];
            final_hash = crypt.digest();
            key = Arrays.copyOf(final_hash, 16); 
             secretKey = new SecretKeySpec(key, &quot;AES&quot;);
        }
        catch(NoSuchAlgorithmException e)
        {
            e.printStackTrace();
        }
        catch(UnsupportedEncodingException e)
        {
            e.printStackTrace();
        }
    }

    public static String encrypt(String strToEncrypt, String secret) 
    {
        try
        {
            processEncryptionKey(secret);
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(new byte[16]));
            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while encrypting: &quot; + e.toString());
        }
        return null;
    }

    public static String decrypt(String strToDecrypt, String secret) 
    {
        try
        {
            processEncryptionKey(secret);
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(new byte[16]));
            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        } 
        catch (Exception e) 
        {
            System.out.println(&quot;Error while decrypting: &quot; + e.toString());
        }
        return null;
    }

  public static void main(String[] args){
    final String secretKey = &quot;YVr_wlp8_fFa&quot;;

    System.out.println(&quot;Secret = &quot; + secretKey);

    String originalString = &quot;testing&quot;;
    
    System.out.println(&quot;Clear text = &quot; + originalString);

    String encryptedString = JavaEncryption.encrypt(originalString, secretKey) ;
    System.out.println(&quot;Encrypted = &quot; + encryptedString);

    String decryptedString = JavaEncryption.decrypt(encryptedString, secretKey);
    System.out.println(&quot;Decrypted = &quot; + decryptedString);
  }
}
</code></pre>
<p>Here is the C# code I am trying to use but not getting the same result. I'm hoping it is just something small that I am missing:</p>
<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class CSharpEncryption
{
    public static void Main()
    {
        Console.WriteLine(new CSharpEncryption().EncryptText());
    }
    
        public string EncryptText()
        {
            using (var aes = new AesManaged())
            {
                aes.Key = CreateSecretKey();
                aes.IV = new byte[16];
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                byte[] encrypted = GetEncryptedBytes(&quot;testing&quot;, aes.Key, aes.IV);
                string encString = Convert.ToBase64String(encrypted);

                return encString;
            }
        }

        protected byte[] GetEncryptedBytes(string textToEncrypt, byte[] Key, byte[] IV)
        {
            byte[] encrypted;

            using (var rij = new RijndaelManaged())
            {
                rij.Key = Key;
                rij.IV = IV;

                ICryptoTransform encryptor = rij.CreateEncryptor(rij.Key, rij.IV);

                using (var msEncrypt = new MemoryStream())
                {
                    using (var cs = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (var sw = new StreamWriter(cs))
                        {
                            sw.Write(textToEncrypt);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
            }

            return encrypted;
        }

        private static byte[] CreateSecretKey()
        {
            var keyHash = CreateHashedKey();

            byte[] key = null;
            using (Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes(keyHash, new byte[16], 1))
            {
                key = rfc2898.GetBytes(16);
            }

            return key;
        }

        private static string CreateHashedKey()
        {
            var hashBase64 = String.Empty;
            using (SHA1Managed sha1 = new SHA1Managed())
            {
                byte[] hash = sha1.ComputeHash(Encoding.UTF8.GetBytes(&quot;YVr_wlp8_fFa&quot;));

                hashBase64 = CreateBase64Hash(hash, true);
            }
            return hashBase64;
        }

        private static string CreateBase64Hash(byte[] arr, bool withoutPadding)
        {
            var base64String = Convert.ToBase64String(arr);
            if (withoutPadding)
            {
                base64String = base64String.TrimEnd('=');
            }

            base64String += &quot;\n&quot;;

            return base64String;
        }
    }
</code></pre>
<p><a href=""https://dotnetfiddle.net/ktULKG"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/ktULKG</a></p>
"	NULL	NULL	NULL	27:08.2	NULL	NULL	NULL	NULL	NULL	379378	0	1	0	<java><c#><encryption><aes>	Java to C# Encryption Conversion	89	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74154283	0	NULL	"<p>My objective is to encrypt a selected file and save it in Documents Directory. I could have used Apple Encrypted Archive to encrypt but the file decryption has to be done on my server (Java).</p>
<p>The java code I'm using to encrypt on the android app.</p>
<pre><code>public static void performEncrypt(File inputFile, File outputFile) {
    try {
        String SECRET_KEY = &quot;MY_SECRETE_KEY&quot;;
        String SALT = &quot;MY_SALT_KEY&quot;;
        // Generating Secrete Key
        byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        IvParameterSpec ivspec = new IvParameterSpec(iv);
        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
        KeySpec spec = new PBEKeySpec(SECRET_KEY.toCharArray(), SALT.getBytes(), 65536, 256);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);
        
        //Reading Input File Bytes
        byte[] inputBytes = Files.readAllBytes(inputFile.toPath());
        
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
        // Performing Encryption
        byte[] outputBytes = cipher.doFinal(inputBytes);
        
        //Writing to output file
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        outputStream.write(outputBytes);
        outputStream.close();

    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<p>I've been trying to replicate the above function is Swift but I am having trouble finding the Swift alternative of these Java Classes. How do I perform encryption using my salt and secrete key ? The closest article I could find related to my issue was <a href=""https://stackoverflow.com/questions/53195595/swift-aes-encrypt-and-decrypt-gets-different-results"">this</a>, but I couldn't understand it.</p>
<pre><code>func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
    let documentDirectory = FileManager.default.urls(for: .documentDirectory,in: .userDomainMask)[0]
    let tempFileName = documentDirectory.appendingPathComponent(&quot;temp.enc&quot;)
    do{
        let iv: [UInt8] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        let fileToEncrypt = try Data(contentsOf: urls.first!)
        let operations = CCOperation(kCCEncrypt)
        let algorithm = CCAlgorithm(kCCAlgorithmAES)
        let options = CCOptions(kCCOptionPKCS7Padding)
        

    }catch{
        print(&quot;Error&quot;)
    }
}
</code></pre>
<p>The last option for me would be to convert my Java code into Objective-c using <a href=""https://developers.google.com/j2objc"" rel=""nofollow noreferrer"">j2objc</a>.</p>
"	NULL	NULL	NULL	21:37.7	NULL	NULL	NULL	NULL	NULL	10246652	0	1	1	<ios><swift><encryption><aes>	File Encryption in Swift with AES	260	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74161586	0	NULL	"<p>I am building and Instagram bot which needs to login to Instagram. Now I know that Instagram uses an encryption system for its password, and I am trying to follow it but keep running into the</p>
<blockquote>
<p>java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: IOException: null</p>
</blockquote>
<p>Basically Instagram needs a cipher text that follow the structure detailed in this <a href=""https://github.com/Datalux/instagram-weak-encryption#encryption-phases"" rel=""nofollow noreferrer"">github repo</a>. My code is as follows to replicate it.</p>
<pre><code> // Generate a random IV
 byte[] iv = new byte[12];
 new SecureRandom().nextBytes(iv);

 // Get the system current time in milliseconds
 long timestamp = System.currentTimeMillis();

 // Converting public key to byte array from hex string
 byte[] publicKeyBytes = hexStringToByteArray(publicKey);

 // Create a random key
 byte[] randomKey = new byte[32];
 new SecureRandom().nextBytes(randomKey);

 // rebuild key using SecretKeySpec
 SecretKey publicKeyClass = new SecretKeySpec(randomKey,0, randomKey.length, &quot;AES&quot;);

 //generate the cipher text
 Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
 cipher.init(Cipher.ENCRYPT_MODE, publicKeyClass, new GCMParameterSpec(128, iv));

 // Add the current time in milliseconds as additional authenticated data
 cipher.updateAAD(Long.toString(timestamp).getBytes(StandardCharsets.UTF_8));
 byte[] cipherText = cipher.doFinal(pwd.getBytes(StandardCharsets.UTF_8));

 // Get the tag from the end of the cipher text
 byte[] tag = Arrays.copyOfRange(cipherText, cipherText.length - 16, cipherText.length);

 // Now we encrypt a random key using the same public key
 // use RSA encryption to encrypt the random key
 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes, &quot;RSA&quot;);
 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
 PublicKey encryptedKeyClass = keyFactory.generatePublic(keySpec);
 Cipher cipher2 = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
 cipher2.init(Cipher.ENCRYPT_MODE, encryptedKeyClass);
 byte[] encryptedRandomKey = cipher2.doFinal(randomKey);

 // Generate the final encrypted text
 String encryptedText = publicKeyId+encryptedRandomKey.toString()+tag.toString()+cipherText.toString();

 //Base64 encode the encrypted text
 String encryptedTextBase64 = Base64.getEncoder().encodeToString(encryptedText.getBytes(StandardCharsets.UTF_8));
</code></pre>
<p>and the function hexStringtoByteArray</p>
<pre><code>public static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i &lt; len; i += 2) {
        data[i / 2] =(byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                             + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}
</code></pre>
<p>I realize that it is a lot of code so here is a basic gist of what is going on</p>
<ol>
<li>I pass a password and publickey(string) to the function.</li>
<li>We generate a random IV and a new random key.</li>
<li>I then use this random key to encrypt the password using AES_GCM_256 bit encryption.</li>
<li>Then the publickey(which was given by instagram) is 64 bytes long and appears to be hex encoded. So I decode it and use it as a key to encrypt the randomly generated key that I have created.</li>
<li>Finally I combine all of this in the format that insta wants and return the final cipher text.</li>
</ol>
<p>Now my problem lies in the 4th step.I keep getting the error that the key is of invalid spec. The line that throws the error is</p>
<pre><code>PublicKey encryptedKeyClass = keyFactory.generatePublic(keySpec);
</code></pre>
<p>Example Public Key that Instagram returns</p>
<pre><code>c81814218a8fe89a6a5794ff5f2a192bf5ab9d3f7115bc8fbceb7b701079777c
</code></pre>
<p>I checked multiple online sources and they all seem to follow the same method I am doing. Am I doing something wrong? Thanks !</p>
"	NULL	NULL	NULL	42:10.1	NULL	NULL	NULL	NULL	NULL	13612757	0	1	0	<java><cryptography><aes><rsa><instagram>	InvalidKeyException when attempting to encrypt password for Instagram login	85	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74222175	0	NULL	"<p>Implemeting decrypt all everything and output will same as payload.</p>
<p>But i only manage to get the path of <code>teacher</code> key. and also the teacher key is missing.
is there is also way to get the student and teacher at desame time?</p>
<pre><code>import javax.crypto.spec.SecretKeySpec;
import java.io.FileReader;
import java.util.Base64;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;

public class TestClass{
public static void main( String[] args ) throws Exception {

    String secret = &quot;secret&quot;;

    JSONParser parser = new JSONParser();
    Object object = parser.parse(new FileReader(&quot;src/main/resources/test.json&quot;));

    JSONObject jsonObject = (JSONObject) object;

    JSONObject teacher = (JSONObject)jsonObject.get(&quot;teacher&quot;);
    String encrypt= (String) teacher.get(&quot;profile&quot;);

    String iv = (String) teacher.get(&quot;iv&quot;);

    byte[] newKey = Base64.getDecoder().decode(secret);
    byte[] IVTest = Base64.getDecoder().decode(iv);

    String Decrypt = decryption(encrypt,newKey, IVTest);
    System.out.println(&quot;Decrypt output : &quot;+ Decrypt);
}

public static String decryption (String cipherText, byte[] myKey,byte[] IV) throws Exception {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKeySpec keySpec = new SecretKeySpec(myKey, &quot;AES&quot;);
    IvParameterSpec ivSpec = new IvParameterSpec(IV);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
    byte[] decryptedText = cipher.doFinal(Base64.getDecoder().decode(cipherText));
    return new String(decryptedText);
}
}
</code></pre>
<p>Json payload</p>
<pre><code>
{
  &quot;student&quot;: {
    &quot;firstname&quot;: &quot;Joan&quot;,
    &quot;lastname&quot;: &quot;lastname&quot;
  },
  &quot;teacher&quot;: {
    &quot;profile&quot;: {
      &quot;firstname&quot;: &quot;Mary&quot;,
      &quot;lastname&quot;: &quot;lastname&quot;
    },
    &quot;iv&quot;: &quot;ivvvv&quot;

  }
}

</code></pre>
<p>Output of decryption</p>
<pre><code>
 +\r+pvb);{
    &quot;profile&quot;: {
      &quot;firstname&quot;: &quot;Mary&quot;,
      &quot;lastname&quot;: &quot;lastname&quot;
    },
    &quot;iv&quot;: &quot;ivvvv&quot;

  }
}

</code></pre>
"	NULL	NULL	NULL	38:35.9	NULL	NULL	NULL	NULL	NULL	20319609	0	1	0	<java><json><spring><encryption>	Decryption not able to get all the value and key	42	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74253159	0	NULL	"<p>I am doing a project to learn about encryption and decryption. I encrypt a file (input file) and encrypt the symmetric key using RSA public. Then I decrypt the symmetric key using RSA private key and then decrypt the file(output file).</p>
<p>here below is the code:</p>
<pre><code>import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class Main {
    public static SecretKey generateKey(int n) throws NoSuchAlgorithmException {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(n);
        SecretKey key = keyGenerator.generateKey();
        return key;
    }
    public static IvParameterSpec generateIv() {
        byte[] iv = new byte[128/8];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }

    public static void encryptFile(String algorithm, SecretKey key, IvParameterSpec iv,
                                   File inputFile, File outputFile) throws IOException, NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {

        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        byte[] buffer = new byte[64];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] output = cipher.update(buffer, 0, bytesRead);
            if (output != null) {
                outputStream.write(output);
            }
        }
        byte[] outputBytes = cipher.doFinal();
        if (outputBytes != null) {
            outputStream.write(outputBytes);
        }
        inputStream.close();
        outputStream.close();
    }

    public static void decryptFile(String algorithm, SecretKey key, IvParameterSpec iv,
                                   File inputFile, File outputFile) throws IOException, NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {

        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        byte[] buffer = new byte[64];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] output = cipher.update(buffer, 0, bytesRead);
            if (output != null) {
                outputStream.write(output);
            }
        }
        byte[] outputBytes = cipher.doFinal();
        if (outputBytes != null) {
            outputStream.write(outputBytes);
        }
        inputStream.close();
        outputStream.close();
    }

    public static KeyPair generateKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(&quot;RSA&quot;);
        generator.initialize(2048);
        KeyPair pair = generator.generateKeyPair();
        return pair;
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, IOException, RuntimeException, InvalidKeySpecException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException, InvalidAlgorithmParameterException {

        //generating a symmetric key
        SecretKey secKey = generateKey(128);
        //generating an IV
        IvParameterSpec iv=generateIv();

        //encrypt the data with AES
        File inputFile = new File(&quot;C:/Users/nm-ca/IdeaProjects/RSA/src/inputFile.txt&quot;);
        File outputFile = new File(&quot;C:/Users/nm-ca/IdeaProjects/RSA/src/outputFile.txt&quot;);
        encryptFile(&quot;AES/CBC/PKCS5Padding&quot;,secKey,iv,inputFile,outputFile);

        //RSA pair of keys generation
        PrivateKey privateKey = generateKeyPair().getPrivate();
        PublicKey publicKey = generateKeyPair().getPublic();

        //encrypt the symmetric key with RSA public key
        Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
        cipher.init(Cipher.PUBLIC_KEY, publicKey);
        byte[] encryptedKey = cipher.doFinal(secKey.getEncoded());

        //decrypt the symmentric key with RSA private Key
        cipher.init(Cipher.PRIVATE_KEY, privateKey);
        byte[] decryptedKey = cipher.doFinal(encryptedKey);
        SecretKey originalKey = new SecretKeySpec(decryptedKey , 0, decryptedKey .length, &quot;AES&quot;);

        //Decrypt the cipher text using decrypted symmetric key
        decryptFile(&quot;AES/CBC/PKCS5Padding&quot;, originalKey,iv,outputFile,inputFile);
    }
}
</code></pre>
<p>When I execute this, I get an BadPaddingException: Decryption error.
<a href=""https://i.stack.imgur.com/pLQdb.png"" rel=""nofollow noreferrer"">error</a></p>
<p>What is the problem and how can I solve it?</p>
"	NULL	NULL	NULL	44:46.5	NULL	NULL	NULL	NULL	NULL	19749794	0	1	0	<java><security><encryption><aes><rsa>	BadPaddingException: Decryption error while encrypting and decrypting a file using RSA with symmetrics Key in Java	47	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74254222	0	NULL	"<p>I am doing a project to learn about encryption and decryption. I encrypt a file (input file) and encrypt the symmetric key using RSA public. Then I decrypt the symmetric key using RSA private key and then decrypt the file(output file).</p>
<p>here below is the code:</p>
<pre><code>import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

public class Main {
    public static SecretKey generateKey(int n) throws NoSuchAlgorithmException {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(n);
        SecretKey key = keyGenerator.generateKey();
        return key;
    }
    public static IvParameterSpec generateIv() {
        byte[] iv = new byte[128/8];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }

    public static void encryptFile(String algorithm, SecretKey key, IvParameterSpec iv,
                                   File inputFile, File outputFile) throws IOException, NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {

        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        byte[] buffer = new byte[64];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] output = cipher.update(buffer, 0, bytesRead);
            if (output != null) {
                outputStream.write(output);
            }
        }
        byte[] outputBytes = cipher.doFinal();
        if (outputBytes != null) {
            outputStream.write(outputBytes);
        }
        inputStream.close();
        outputStream.close();
    }

    public static void decryptFile(String algorithm, SecretKey key, IvParameterSpec iv,
                                   File inputFile, File outputFile) throws IOException, NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {

        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);
        byte[] buffer = new byte[64];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] output = cipher.update(buffer, 0, bytesRead);
            if (output != null) {
                outputStream.write(output);
            }
        }
        byte[] outputBytes = cipher.doFinal();
        if (outputBytes != null) {
            outputStream.write(outputBytes);
        }
        inputStream.close();
        outputStream.close();
    }


    public static byte[] encryptSymmetricKey(SecretKey secKey) throws NoSuchAlgorithmException, IOException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

        byte[] key = Files.readAllBytes(Paths.get(&quot;publicKey.key&quot;));
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);
        PublicKey publicKey = keyFactory.generatePublic(keySpec);
        Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
        cipher.init(Cipher.PUBLIC_KEY, publicKey);
        byte[] encryptedKey = cipher.doFinal(secKey.getEncoded());
        return encryptedKey;
    }

    public static SecretKey decryptSymmetricKey(SecretKey secKey) throws NoSuchAlgorithmException, IOException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        byte[] encryptedKey= encryptSymmetricKey(secKey);
        byte[] key = Files.readAllBytes(Paths.get(&quot;publicKey.key&quot;));
        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(key);
        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
        Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);
        cipher.init(Cipher.PRIVATE_KEY, privateKey);
        byte[] decryptedKey = cipher.doFinal(encryptedKey);
        SecretKey originalKey = new SecretKeySpec(decryptedKey , 0, decryptedKey .length, &quot;AES&quot;);
        return originalKey;
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, IOException, RuntimeException, InvalidKeySpecException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException, InvalidAlgorithmParameterException {

        SecretKey secKey=generateKey(128);
        IvParameterSpec iv=generateIv();

        File inputFile=new File(&quot;C:/Users/nm-ca/IdeaProjects/RSA/src/inputFile.txt&quot;);
        File outputFile=new File(&quot;C:/Users/nm-ca/IdeaProjects/RSA/src/outputFile.txt&quot;);
        encryptFile(&quot;AES/CBC/PKCS5Padding&quot;,secKey,iv,inputFile,outputFile);


        //Decrypt the cipher text using decrypted symmetric key
        decryptFile(&quot;AES/CBC/PKCS5Padding&quot;, decryptSymmetricKey(secKey),iv,outputFile,inputFile);
    }
}
</code></pre>
<p>The Error:
Exception in thread &quot;main&quot; java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: invalid key format</p>
<p>When I encrypt the symmetric key and then decrypt it, I produce an invalid key I guess. How can I solve this problem?</p>
"	NULL	NULL	NULL	13:17.7	NULL	NULL	NULL	NULL	NULL	19749794	0	1	0	<java><security><encryption><aes><rsa>	java.security.InvalidKeyException: invalid key format while encrypting and decrypting a file using RSA with symmetrics Key in Java	223	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74272875	74275811	NULL	"<p>I have to change java code for decrypt to flutter code. I use library &quot;encrypt&quot; for flutter. my flutter code show</p>
<blockquote>
<p>Key length not 128/192/256 bits.</p>
</blockquote>
<p>my java spring boot code.</p>
<pre><code>public static String decryptAES256(String str, String secretKey) throws java.io.UnsupportedEncodingException,
                NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
                InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
            String AES = &quot;AES&quot;;
            String AES_PADDING = &quot;AES/CBC/PKCS5Padding&quot;;
            byte[] keyData = java.util.Base64.getDecoder().decode(secretKey);
            String iv = secretKey.substring(0, 16);
            SecretKey secureKey = new SecretKeySpec(keyData, AES);
            Cipher c = Cipher.getInstance(AES_PADDING);
            c.init(Cipher.DECRYPT_MODE, secureKey, new IvParameterSpec(iv.getBytes(StandardCharsets.UTF_8)));
            byte[] byteStr = Base64.getDecoder().decode(str.getBytes());
            return new String(c.doFinal(byteStr), StandardCharsets.UTF_8);
        }
</code></pre>
<p>my flutter code.</p>
<pre><code>final encData = codefModel.data!.encData!;
    final key = en.Key.fromUtf8(decryptKey);
    final b64key = en.Key.fromUtf8(base64Url.encode(key.bytes));
    final iv = en.IV.fromLength(16);
    final encrypter = en.Encrypter(en.AES(b64key, mode: en.AESMode.cbc));
    logger.d(encrypter.decrypt64(encData, iv: iv));
</code></pre>
"	NULL	NULL	NULL	43:59.1	NULL	NULL	NULL	NULL	NULL	17030358	0	1	0	<java><flutter>	how to implement decrypt in flutter like java?	42	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74302125	74302287	NULL	"<p>newbie in Java AES! I am exploring and following the tutorial of <a href=""https://www.baeldung.com/java-aes-encryption-decryption"" rel=""nofollow noreferrer"">baeldung</a> and I got this error while seeing it for myself for 256 key length:
<strong>Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Message must be a multiple of the block size without padding</strong></p>
<p>I have the below:
<strong>main Method</strong>
`</p>
<pre><code>public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException, IllegalBlockSizeException, InvalidKeySpecException {
        System.out.println(&quot;Encrypt/Decrypt a string&quot;);
        //3 params for AES algo: (1) input data, (2) secret key, (3) and IV
        Scanner scanner = new Scanner(System.in);
        String inputKey;
        int inputSecretKey = 256;
        IvParameterSpec IV;
        
        
        //step 1: input
        System.out.print(&quot;Input: &quot;);
        inputKey = scanner.nextLine();
        
        //step 2: generate secret key

        System.out.println(&quot;Generating secret key with size &quot;+inputSecretKey);
        SecretKey secretKey1 = generateKey(inputSecretKey);
        
        //step 3: generate IV
        IV = generateIv();
        
        //step 4: print
        String cipherText = encrypt(&quot;AES/CBC/PKCS5Padding&quot;, inputKey, secretKey1, IV);
        String plainText = decrypt(&quot;AES/CBC/PKCS5Padding&quot;, inputKey, secretKey1, IV);
        Assertions.assertEquals(inputKey, plainText);
        System.out.println(&quot;Encrypted: &quot;+cipherText+&quot; [size : &quot;+cipherText.length()+&quot;]&quot;);
        System.out.println(&quot;Decrypted: &quot;+plainText+&quot; [size : &quot;+plainText.length()+&quot;]&quot;);
        
        
        scanner.close();
        
    }
</code></pre>
<p>`</p>
<p><strong>generateKey Method</strong>
`</p>
<pre><code>public static SecretKey generateKey(int n) throws NoSuchAlgorithmException {
        KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGen.init(n);
        SecretKey key = keyGen.generateKey();
        return key;
    }
</code></pre>
<p>`</p>
<p><strong>generateIv Method</strong>
`</p>
<pre><code>public static IvParameterSpec generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }
</code></pre>
<p>`</p>
<p><strong>encrypt Method</strong>
`</p>
<pre><code>public static String encrypt(String algorithm, String input, SecretKey key,
            IvParameterSpec iv) throws NoSuchPaddingException, NoSuchAlgorithmException,
            InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {
            
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);
            byte[] cipherText = cipher.doFinal(input.getBytes());
            return Base64.getEncoder()
                .encodeToString(cipherText);
    }
</code></pre>
<p>`</p>
<p><strong>decrypt Method</strong> (I included which specific line is eclipse pointing me at)
`</p>
<pre><code>public static String decrypt(String algorithm, String cipherText, SecretKey key,
            IvParameterSpec iv) throws NoSuchPaddingException, NoSuchAlgorithmException,
            InvalidAlgorithmParameterException, InvalidKeyException,
            BadPaddingException, IllegalBlockSizeException {
            
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, key, iv);
            byte[] plainText = cipher.doFinal(Base64.getDecoder()
                .decode(cipherText)); //&lt;-------- GETTING ERROR IN THIS LINE
            return new String(plainText);
        }
</code></pre>
<p>`</p>
<p>I tried searching but I think no one has encountered this yet. The only thing I understood is AES/CBC/PKCS5Padding stands for algorithm/mode/padding. I did find <a href=""https://stackoverflow.com/questions/10935068/what-are-the-cipher-padding-strings-in-java"">this</a> though I am not sure what to use. I am quite confused on what I should change in the code and the root cause of the error.</p>
<p>I am trying inputs like &quot;hello&quot; or &quot;dFet4Q2fi&quot; if that helps.</p>
"	NULL	NULL	NULL	08:36.5	NULL	NULL	NULL	NULL	NULL	4338139	0	1	0	<java><encryption><aes>	Java AES Encryption and Decryption: javax.crypto.IllegalBlockSizeException	123	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74320310	74320645	NULL	"<p>I was trying to class a code that would encrypt an entered text with JFRAME, which does it well for me. Once I'm done, it saves the encrypted text in a .txt and then has to decrypt it, but I don't understand why it doesn't decrypt it for me.
Thank you very much.</p>
<pre><code>public class NewJFrame extends javax.swing.JFrame {
   
    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Generated Code&quot;&gt;                          
    private void initComponents() {

        btn_Decript = new javax.swing.JButton();
        btn_Encript = new javax.swing.JButton();
        text_Encript = new javax.swing.JLabel();
        text_decript = new javax.swing.JLabel();
        Text = new javax.swing.JTextField();
        Text1 = new javax.swing.JTextField();
        Text2 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        btn_Decript.setText(&quot;Desencriptar&quot;);
        btn_Decript.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_DecriptActionPerformed(evt);
            }
        });

        btn_Encript.setText(&quot;Encirptar&quot;);
        btn_Encript.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_EncriptActionPerformed(evt);
            }
        });

        text_Encript.setText(&quot;Encriptat&quot;);

        text_decript.setText(&quot;Desencriptar&quot;);

        Text.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TextActionPerformed(evt);
            }
        });

        Text1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Text1ActionPerformed(evt);
            }
        });

        Text2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Text2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(56, 56, 56)
                .addComponent(btn_Encript)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 35, Short.MAX_VALUE)
                .addComponent(btn_Decript)
                .addGap(53, 53, 53))
            .addGroup(layout.createSequentialGroup()
                .addGap(88, 88, 88)
                .addComponent(Text, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(text_Encript, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Text1, javax.swing.GroupLayout.PREFERRED_SIZE, 137, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(text_decript, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Text2)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
            .addGroup(layout.createSequentialGroup()
                .addGap(38, 38, 38)
                .addComponent(Text, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(text_Encript)
                    .addComponent(text_decript, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Text1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Text2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(46, 127, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btn_Encript)
                    .addComponent(btn_Decript))
                .addGap(29, 29, 29))
        );

        pack();
    }// &lt;/editor-fold&gt;                        

    private void TextActionPerformed(java.awt.event.ActionEvent evt) {                                     

    }                                    

    private void btn_EncriptActionPerformed(java.awt.event.ActionEvent evt) {                                            
        Txt(encrypt(Text1.getText(), &quot;Marti&quot;));
        Text1.setText(llegir());
        
        Text1.setEditable(false);
    }                                           

    private void btn_DecriptActionPerformed(java.awt.event.ActionEvent evt) {                                            
        Text2.setText(decrypt(llegir(),&quot;Marti&quot;));
        Text2.setText(llegir());
        
         Text1.setEditable(false);
    }                                           

    private void Text1ActionPerformed(java.awt.event.ActionEvent evt) {                                      
        // TODO add your handling code here:
    }                                     

    private void Text2ActionPerformed(java.awt.event.ActionEvent evt) {                                      
     
    }                                     

    /**
     * @param args the command line arguments
     */
    
 
    // Variables declaration - do not modify                     
    private javax.swing.JTextField Text;
    private javax.swing.JTextField Text1;
    private javax.swing.JTextField Text2;
    private javax.swing.JButton btn_Decript;
    private javax.swing.JButton btn_Encript;
    private javax.swing.JLabel text_Encript;
    private javax.swing.JLabel text_decript;
    // End of variables declaration                   

    
public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot; Look and feel setting code (optional) &quot;&gt;
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if (&quot;Nimbus&quot;.equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //&lt;/editor-fold&gt;

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }
    
public static void Txt(String secret){
    Path path = Paths.get(&quot;./encriptar.txt&quot;);
    
    try{
        Files.writeString(path, secret, StandardCharsets.UTF_8);
    }
    catch (Exception e){
        System.out.println(&quot;Error while encrypting: &quot;);
    }
}

public static String llegir(){
    Path path = Paths.get(&quot;./encriptar.txt&quot;);
    String algo = null;
    try{
        algo = Files.readString(path);
    }catch(Exception e){
        System.out.println(&quot;Error&quot;);
    }
    return algo;
}
  
  private static SecretKeySpec secretKey;
  private static byte[] key;
 
  
  public static void setKey(final String myKey) {
    MessageDigest sha = null;
    try {
      key = myKey.getBytes(&quot;UTF-8&quot;);
      sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
      key = sha.digest(key);
      key = Arrays.copyOf(key, 16);
      secretKey = new SecretKeySpec(key, &quot;AES&quot;);
    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }

  public static String encrypt(final String strToEncrypt, final String secret) {
    try {
      setKey(secret);
      Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
      cipher.init(Cipher.ENCRYPT_MODE, secretKey);
      return Base64.getEncoder()
        .encodeToString(cipher.doFinal(strToEncrypt.getBytes(&quot;UTF-8&quot;)));
    } catch (Exception e) {
      System.out.println(&quot;Error while encrypting: &quot;);
    }
    return null;
  }

  public static String decrypt(final String strToDecrypt, final String secret) {
    try {
      setKey(secret);
      Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
      cipher.init(Cipher.DECRYPT_MODE, secretKey);
      return new String(cipher.doFinal(Base64.getDecoder()
        .decode(strToDecrypt)));
    } catch (Exception e) {
      System.out.println(&quot;Error while decrypting: &quot; + e.toString());
    }
    return null;
  } 
</code></pre>
<p>I try to see if someone can know how to solve the error that I write above, thanks.</p>
"	NULL	NULL	NULL	40:38.9	NULL	NULL	NULL	NULL	NULL	20238177	0	1	0	<java><encryption><netbeans><jframe><file-descriptor>	I am encrypting and decrypting but it does not show me the decryption	62	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74353333	0	NULL	"<p>Im using the Cipher class in the java.security library to encrypt and decrypt data. Im specifically using RSA encryption to encrypt AES parameters and message byte length, the AES cipher is what I'm using to encrypt the message itself. Currently I have a problem that I can't be sure if the provided encrypted AES parameters and message length were encrypted with my RSA key, or if they were encrypted at all and not just random jiberish.</p>
<pre><code>val rsaCipher = Cipher.getInstance(&quot;RSA&quot;)
rsaCipher.init(Cipher.DECRYPT_MODE, privateKey)
val rsaDecoded = rsaCipher.doFinal(encryptedAesParametersAndMessageLength)
val aesParameters = ByteArray(48)
val messageLength = ByteArray(4)
for (i in aesParameters.indices) {
    aesParameters[i] = rsaDecoded[i]
}
for (i in messageLength.indices) {
    messageLength[i] = rsaDecoded[i + aesParameters.size]
}

val length = ByteBuffer.wrap(messageLength).order(ByteOrder.LITTLE_ENDIAN).int
val aesEncryptor = AesEncryptor(aesParameters)
//bytes of the encryptedMessage
//TODO Make sure this doesn't result in an error
val encryptedMessage = ByteArray(length)
</code></pre>
<p>When trying to decrypt AES parameters and message length using the RSA key it doesn't throw any kind of exception if the data wasn't decrypted correctly. Eventually this leads to a memory overflow error because the message length is too large. Is it safe to maybe put a 4 bytes(holding some constant int value) after these parameters that i can check to make sure the data was decrypted correctly, or would that risk my apps safety?</p>
"	NULL	NULL	NULL	53:18.8	NULL	NULL	NULL	NULL	NULL	15937198	0	1	0	<kotlin><encryption><aes><rsa>	How do I know if my data was decrypted correctly?	66	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74373866	0	NULL	"<p>I have an API endpoint for encrypting with Spring Boot.</p>
<p>My PostMapping code is the following:
`</p>
<pre><code>@PostMapping(value = &quot;/aes/decrypt&quot;,produces = &quot;application/json&quot;)
public static DecryptionResponse aesDecrypt(@RequestBody final DecryptionRequest decryptionRequest) throws NoSuchPaddingException, NoSuchAlgorithmException, UnrecoverableEntryException, KeyStoreException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(KEY_ALIAS ,passwordProtection);
    final SecretKey secretKey = secretKeyEntry.getSecretKey();
    //final int myTLen = decryptionRequest.getGcmParameterSpec().getTLen();
    //byte[] iV = decryptionRequest.getGcmParameterSpec().getIV();
   // final GCMParameterSpec gcmP= new GCMParameterSpec(myTLen, iV);
    final AlgorithmParameters ap = decryptionRequest.getAp();
    Cipher decCipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    decCipher.init(Cipher.DECRYPT_MODE, secretKey, ap);
    byte[] dec = decCipher.doFinal(decryptionRequest.getCipherText());

    DecryptionResponse decryptionResponse = new DecryptionResponse();
    decryptionResponse.setMessage(new String(dec, StandardCharsets.UTF_8));
    return decryptionResponse;
}
</code></pre>
<p>`</p>
<p>The class DecryptionRequest looks like the following:
`</p>
<pre><code>package com.cryptoDemo.cryptoDemo;

import javax.crypto.spec.GCMParameterSpec;
import java.security.AlgorithmParameters;

public class DecryptionRequest {

    private String keyAlias;
    private byte[] cipherText;
    private GCMParameterSpec gcmParameterSpec;

    private AlgorithmParameters ap;

    public DecryptionRequest(String keyAlias, byte[] cipherText) {
        this.keyAlias = keyAlias;
        this.cipherText = cipherText;
    }

    public String getKeyAlias() {
        return keyAlias;
    }

    public void setKeyAlias(String keyAlias) {
        this.keyAlias = keyAlias;
    }

    public byte[] getCipherText() {
        return cipherText;
    }

    public void setCipherText(byte[] cipherText) {
        this.cipherText = cipherText;
    }
/*
    public GCMParameterSpec getGcmParameterSpec() {
        return gcmParameterSpec;
    }

    public void setGcmParameterSpec(GCMParameterSpec gcmParameterSpec) {
        this.gcmParameterSpec = gcmParameterSpec;
    }
*/
    public AlgorithmParameters getAp() {
        return ap;
    }

    public void setAp(AlgorithmParameters ap) {
        this.ap = ap;
    }
}

</code></pre>
<p>`</p>
<p>Encrypting works fine, but when i try to decrypt with the supplied JSON data, i get an 'unsupported media type' response from the browser.</p>
<p>I tried different things like returning the GCMParameterSpec, seperaterly retrieving my iV and the TLen, returning the whole AlgorithmParameters, but everytime i get the 'unsupported media type'.</p>
<p>Does anyone have an idea how to fix it?</p>
"	NULL	NULL	NULL	05:59.4	NULL	NULL	NULL	NULL	NULL	20329827	0	1	0	<java><encryption><aes-gcm>	Failed to evaluate Jackson deserialization when using API endpoint	36	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74386927	74388018	NULL	"<p>I am trying to generate a key using Java. To be honest I am not that experienced with keys, password, ciphers and encryption.</p>
<p>And from whatever I have searched from this site, I see it as a very common problem. I did some reading and came up with this code that I wrote:</p>
<pre><code>    Security.setProperty(&quot;crypto.policy&quot;, &quot;unlimited&quot;);

    String valueToEncode = &quot;some_random_text&quot;;

    SecureRandom secureRandom = new SecureRandom();
    byte[] salt = new byte[256];

    secureRandom.nextBytes(salt);

    KeySpec keySpec = new PBEKeySpec(&quot;some_random_password&quot;.toCharArray(), salt, 65536, 256); // AES-256
    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBEWITHHMACSHA512ANDAES_256&quot;);
    byte[] key = secretKeyFactory.generateSecret(keySpec).getEncoded();
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);

    byte[] ivBytes = new byte[16];

    secureRandom.nextBytes(ivBytes);

    IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);

    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);

    byte[] encValue = cipher.doFinal(valueToEncode.getBytes(StandardCharsets.UTF_8));
    byte[] finalCiphertext = new byte[encValue.length + 2 * 16];

    System.arraycopy(ivBytes, 0, finalCiphertext, 0, 16);
    System.arraycopy(salt, 0, finalCiphertext, 16, 16);
    System.arraycopy(encValue, 0, finalCiphertext, 32, encValue.length);

    System.out.println(finalCiphertext.toString());
</code></pre>
<p>This is modified from an answer that I saw on another post. But I still get the &quot;invalid length&quot; error.</p>
<p>The error that I get is:</p>
<pre><code>Exception in thread &quot;main&quot; java.security.InvalidKeyException: Invalid AES key length: 20 bytes
    at com.sun.crypto.provider.AESCrypt.init(AESCrypt.java:87)
    at com.sun.crypto.provider.CipherBlockChaining.init(CipherBlockChaining.java:93)
    at com.sun.crypto.provider.CipherCore.init(CipherCore.java:591)
    at com.sun.crypto.provider.AESCipher.engineInit(AESCipher.java:346)
    at javax.crypto.Cipher.implInit(Cipher.java:805)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:863)
    at javax.crypto.Cipher.init(Cipher.java:1395)
    at javax.crypto.Cipher.init(Cipher.java:1326)
    at com.att.logicalprovisioning.simulators.Trial.main(Trial.java:47)
</code></pre>
<p><code>Trial.java:47</code> being the line: <code>cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);</code></p>
<p>Is there a one-size fits all solution to this? Or is it just my lack of understanding?</p>
<p>Any help would be appreciated.</p>
"	NULL	NULL	NULL	39:33.0	NULL	NULL	NULL	NULL	NULL	1047226	0	1	1	<java><encryption><cryptography><aes>	Invalid AES key length: 20 bytes (Java 11)	60	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74418832	74421015	NULL	"<p>Implement UDP chat application using symmetric AES encryption. I start with the client side having a message and sending the message encrypted (ciphertext) to the server side. Then the server side will decrypt with the fixed key and the ciphertext to get the original message. Both the server-side and client-side will use this key for encrypting and decrypt</p>
<pre><code>client.sentThenReceive(&quot; P@ssword123@@24&quot;.getBytes(StandardCharsets.UTF_8));
</code></pre>
<pre><code>server.receiveThenSend(&quot; P@ssword123@@24&quot;.getBytes(StandardCharsets.UTF_8));
</code></pre>
<p>Everything worked properly until I try to decrypt method on the server side with the ciphertext and given the key  causing the error below in this line of code</p>
<pre><code>byte[] originalMessage = cipher.doFinal(message);
</code></pre>
<pre><code>Exception in thread &quot;main&quot; javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
    at java.base/com.sun.crypto.provider.CipherCore.unpad(CipherCore.java:858)
    at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:938)
    at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:734)
    at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:434)
    at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2206)
    at Server.Decryption(Server.java:45)
    at Server.receiveThenSend(Server.java:63)
    at Server.main(Server.java:81)
</code></pre>
<p>Here is the encryption method in the client side, after the client encrypte the message and send it to the client side</p>
<pre><code>public byte[] Encryption(byte[] message, byte[] keyBytes)throws InvalidKeyException, NoSuchPaddingException,
        NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException {
    // Step 5: Create a Cipher object
    Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
    SecretKey secrekey = new SecretKeySpec(keyBytes, &quot;AES&quot;);
    cipher.init(cipher.ENCRYPT_MODE, secrekey);
    byte[] Encryption = cipher.doFinal(message);
    return Encryption;
}
</code></pre>
<p>When the Server side receive the encrypted message from the client side, it will using decrypte method to decrypt. The error evoke by this line of code:  byte[] originalMessage = cipher.doFinal(message);</p>
<pre><code>public String Decryption(byte[] message, byte[] keyBytes)throws InvalidKeyException, NoSuchPaddingException,
        NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException {

        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        SecretKey secretKey = new SecretKeySpec(keyBytes, &quot;AES&quot;);
        cipher.init(cipher.DECRYPT_MODE, secretKey);
        byte[] originalMessage = cipher.doFinal(message);
        return new String(originalMessage);
}
</code></pre>
<p>This is the send method in client side use to send the ciphertext to server side</p>
<pre><code>
public void sentThenReceive(byte[] key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {

    Scanner scanner = new Scanner(System.in);
    while (true) {
        try {
            String messageToSend = scanner.nextLine();
            byte[] message = messageToSend.getBytes();
            DatagramPacket datagramPacket = new DatagramPacket (message, message.length, inetAddress, 2468);
            datagramSocket.send(datagramPacket);
</code></pre>
<p>This is the receive method in the server side use to receive the message from client side</p>
<pre><code>public void receiveThenSend(byte[] key) throws NoSuchPaddingException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException {
    while (true) {
        try {
            DatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length);
            datagramSocket.receive(datagramPacket);
            System.out.println(Decryption(datagramPacket.getData(),key));
            InetAddress inetAddress = datagramPacket.getAddress();
            int port = datagramPacket.getPort();
            datagramPacket = new DatagramPacket(buffer, buffer.length, inetAddress, port);
            datagramSocket.send(datagramPacket);
</code></pre>
<p>I'm a learner so anyone please feel free to teach me what wrong with my code and how I can fix it. I would very appreciate your input!</p>
"	NULL	NULL	NULL	02:10.7	NULL	NULL	NULL	NULL	NULL	20482882	0	1	-1	<java><exception><encryption><cryptography><udp>	javax.crypto.BadPaddingException: Given final block not properly padded. AES Decryption	731	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74457873	0	NULL	"<p>I am facing an error while decryption of 1 of the parameters named as CardHolderName().
Please find the error snippet below:</p>
<pre class=""lang-none prettyprint-override""><code>Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
    at com.sun.crypto.provider.CipherCore.unpad(CipherCore.java:975)
    at com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1056)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at javax.crypto.Cipher.doFinal(Cipher.java:2164)
    at com.example.encryptdecrypt.utils.AES.decrypt(AES.java:79)
    at com.example.encryptdecrypt.service.EncryptionServiceimpl.decrypt(EncryptionServiceimpl.java:36)
    at com.example.encryptdecrypt.EncryptionController.EncryptionController.userDecryptusingKey(EncryptionController.java:56)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
</code></pre>
<p>Please find my attached code snippet for the same.</p>
<pre class=""lang-java prettyprint-override""><code>@PostMapping(&quot;/userdecryptusingKey&quot;)
public User userDecryptusingKey(@RequestBody Map&lt;String,String&gt; secretKeybody) {
    String secretKey = secretKeybody.get(&quot;secretKey&quot;);
    User user1 = encryptionService.getUserByKey(secretKey);
    System.out.println(user1.getCardHolderName());
    user1.setCardHolderName(encryptionService.decrypt(user1.getCardHolderName(),secretKey));
    user1.setCvv(encryptionService.decrypt(user1.getCvv().toString(),secretKey));
    
    return user1;
}
</code></pre>
<p>This is the function for generating the Key</p>
<pre class=""lang-java prettyprint-override""><code>private void setKey() throws GeneralSecurityException {
    try {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(256);
        secretKey = keyGenerator.generateKey();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<pre class=""lang-java prettyprint-override""><code>public static SecretKey convertStringToSecretKey(String encodedKey) {
    //System.out.println(&quot;encoded key&quot;+ encodedKey);
    byte[] decodedKey = Base64.getDecoder().decode(encodedKey);
    SecretKey originalKey = new SecretKeySpec(decodedKey,&quot;AES&quot;);
    return originalKey;
}
</code></pre>
<pre class=""lang-java prettyprint-override""><code>public String decrypt(String strToDecrypt,String key){
    try {
        SecretKey secretKey1 = convertStringToSecretKey(key);
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
        byte[] iv = new byte[16];
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey1);
        return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
    } catch ( InvalidKeyException |IllegalBlockSizeException |NoSuchAlgorithmException| NoSuchPaddingException | BadPaddingException e) {
        System.out.println(&quot;error decr&quot; + e.getMessage());
        e.printStackTrace();
    }
    return null;
}
</code></pre>
<p>I am able to fetch the CVV value without any problem, but cardHolderName() is coming as null.</p>
<p>I have tried numerous changes for doFinal() and update() still not working.</p>
"	NULL	NULL	NULL	15:53.2	NULL	NULL	NULL	NULL	NULL	20518250	0	1	0	<java><spring-boot><aes>	Given final block not properly padded. Such issues can arise if a bad key is used during decryption. Problem in decryption	313	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74475421	0	NULL	"<p>I have an encryption and decryption method in Java. I want to create same decryption function in JavaScript. I am translating line by line, but have an issue in one line as I am not able to understand that. That line is:</p>
<pre class=""lang-java prettyprint-override""><code>byte[] dec = Base64Utils.decode(encryptedString.getBytes());
</code></pre>
<p>How can I do this in JavaScript. I know .getBytes can be replicated by using text encoder, but I'm not sure about base64 decoding it.</p>
<p>For reference, here is the Java method I am trying to replicate</p>
<pre class=""lang-java prettyprint-override""><code>public String decrypti(String encryptedString, String encodekey) {
    try {
        if (encryptedString != null) {
            encryptedString = encryptedString.replace(&quot;-&quot;, &quot;+&quot;).replace(&quot;_&quot;, &quot;/&quot;).concat(&quot;==&quot;);

            Cipher dcipher = Cipher.getInstance(&quot;AES&quot;);
            byte[] key = encodekey.getBytes(StandardCharsets.UTF_8);
            MessageDigest sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); // use only first 128 bit

            SecretKeySpec secretKeySpec = new SecretKeySpec(key, transformation);

            dcipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            // decode with base64 to get bytes
            byte[] dec = Base64Utils.decode(encryptedString.getBytes());
            byte[] utf8 = dcipher.doFinal(dec);

            // create new string based on the specified charset
            return new String(utf8, StandardCharsets.UTF_8);
        }

    } catch (Exception e) {
        log.error(&quot;Error during decrypting code - {}&quot;, e.getMessage());
    }
    return null;
}
</code></pre>
<p>And here is the JavaScript code that I have written till now:</p>
<pre class=""lang-js prettyprint-override""><code>const decrypt = (encodedString, encodeKey) =&gt; {
  let encrptedStr = encodedString.replace(/-/g, &quot;_&quot;).replace(/\+/g, &quot;/&quot;).concat(&quot;==&quot;);
  
  const encoder = new TextEncoder('UTF-8');
  const bytes = encoder.encode(encodeKey);  // reference to encodekey.getBytes(StandardCharsets.UTF_8);
  const sha1Hash = CryptoJS.SHA1(bytes);                        // Create SHA1 hash
  const secretAesKey = CryptoJS.lib.WordArray.create(sha1Hash.words.slice(0, 4)); 

  const decryptedBytes = CryptoJS.AES.decrypt(
    encrptedStr,
    secretAesKey,
  );
  const finalDecryptedValue = decryptedBytes.toString(CryptoJS.enc.Utf8);
  return finalDecryptedValue;
}
</code></pre>
"	NULL	NULL	NULL	23:41.1	NULL	NULL	NULL	NULL	NULL	20522388	0	1	0	<javascript><java><base64><decoding><cryptojs>	Javascript syntax for Base64Utils.decode() java code	56	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74542727	0	NULL	"<p>I have implemented AES Algorithm to encrypt and Decrypt the access token, below is my Code.</p>
<pre><code>    @RequiresApi(Build.VERSION_CODES.M)
    fun createKey(): SecretKey {
        try {
            var keyGenerator =
                KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, &quot;AndroidKeyStore&quot;)
            keyGenerator.init(
                KeyGenParameterSpec.Builder(
                    &quot;SCI&quot;,
                    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
                )
                    .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)
                    .build()
            )
            return keyGenerator.generateKey()
        } catch (e: NoSuchAlgorithmException) {
            throw RuntimeException(&quot;Failed to create a Symmetric Key&quot;, e)
        } catch (e: NoSuchProviderException) {
            throw RuntimeException(&quot;Failed to create a Symmetric Key&quot;, e)
        } catch (e: InvalidAlgorithmParameterException) {
            throw RuntimeException(&quot;Failed to create a Symmetric Key&quot;, e)
        }
    }



    fun storeData(data: String, key: String, context: Context) {
        val pref = PreferenceProvider(context)
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
            val secretKey = createKey()
            val chiper =
                Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + &quot;/&quot; + KeyProperties.BLOCK_MODE_CBC + &quot;/&quot; + KeyProperties.ENCRYPTION_PADDING_PKCS7)
            chiper.init(Cipher.ENCRYPT_MODE, secretKey)
            val encryptionIV = chiper.iv
            val passwordBytes = data.toByteArray()
            val encrptedPasswordBytes = chiper.doFinal(passwordBytes)
            val encrptedValue = android.util.Base64.encodeToString(
                encrptedPasswordBytes,
                android.util.Base64.DEFAULT
            )
            pref.saveString(key, encrptedValue)
            pref.saveString(
                &quot;encryptionIV&quot;, android.util.Base64.encodeToString(
                    encryptionIV,
                    android.util.Base64.DEFAULT
                )
            )
        } else {
            pref.saveString(key, data)
        }
    }



   
    fun retraiveData(key: String, context: Context): String {
        val pref = PreferenceProvider(context)
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
            val base64EncryptedPassword = pref.getString(key)
            val base64EncryptedIV = pref.getString(&quot;encryptionIV&quot;)
            val encryptedPassword = Base64.decode(base64EncryptedPassword, Base64.DEFAULT)
            val encryptedIV = Base64.decode(base64EncryptedIV, Base64.DEFAULT)
            var keyStore = KeyStore.getInstance(&quot;AndroidKeyStore&quot;)
            keyStore.load(null)
            val secretKey = keyStore?.getKey(&quot;SCI&quot;, null) as SecretKey
            val chiper =
                Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + &quot;/&quot; + KeyProperties.BLOCK_MODE_CBC + &quot;/&quot; + KeyProperties.ENCRYPTION_PADDING_PKCS7)
            chiper.init(Cipher.DECRYPT_MODE, secretKey, IvParameterSpec(encryptedIV))
            val passwordBytes = String(chiper.doFinal(encryptedPassword), charset(&quot;UTF-8&quot;))
            //  val passwordBytes = chiper.doFinal(encryptedPassword)
            val password = passwordBytes
            return password
        } else {
            return pref.getString(key)
        }
    }
</code></pre>
<p>getting below error</p>
<pre><code>java.lang.Error: javax.crypto.BadPaddingException
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1173)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
        at java.lang.Thread.run(Thread.java:923)
     Caused by: javax.crypto.BadPaddingException
        at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:515)
        at javax.crypto.Cipher.doFinal(Cipher.java:2055)
        at s4.c.a(Unknown Source:30)
        at e6.g.c(RealInterceptorChain.kt:14)
        at d6.e.g(RealCall.kt:23)
        at d6.e$a.run(RealCall.kt:12)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) 
        at java.lang.Thread.run(Thread.java:923) 
     Caused by: android.security.KeyStoreException: Invalid argument
        at android.security.KeyStore.getKeyStoreException(KeyStore.java:1461)
        at android.security.keystore.KeyStoreCryptoOperationChunkedStreamer.doFinal(KeyStoreCryptoOperationChunkedStreamer.java:186)
        at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:506)
        at javax.crypto.Cipher.doFinal(Cipher.java:2055) 
        at s4.c.a(Unknown Source:30) 
        at e6.g.c(RealInterceptorChain.kt:14) 
        at d6.e.g(RealCall.kt:23) 
        at d6.e$a.run(RealCall.kt:12) 
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) 
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) 
        at java.lang.Thread.run(Thread.java:923)
</code></pre>
"	NULL	NULL	NULL	45:18.9	NULL	NULL	NULL	NULL	NULL	6400572	0	1	0	<android><cryptography><aes>	java.lang.Error: javax.crypto.BadPaddingException	62	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74575538	0	NULL	"<p>The title pretty much sums up the question. The quadratic runtime of the cipher compared to the input, can be see using this sample code:</p>
<pre class=""lang-java prettyprint-override""><code>import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.function.BiFunction;
import java.util.function.Function;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class AES_Test {

  public static void main(String[] args) throws Exception {
    Random r = new Random();
    byte[] key = new byte[32];
    byte[] spec = new byte[12];
    byte[] iv = new byte[16];
    r.nextBytes(key);
    r.nextBytes(spec);
    r.nextBytes(iv);

    List&lt;BiFunction&lt;Integer, SecretKeySpec, Cipher&gt;&gt; cipherCreators = List.of(
      (mode, serverKey) -&gt; {
        GCMParameterSpec eGcmParameterSpec = new GCMParameterSpec(16 * 8, spec);
        try
        {
          Cipher eCipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
          eCipher.init(mode, serverKey, eGcmParameterSpec);
          return eCipher;
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      },
      (mode, serverKey) -&gt; {
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        Cipher eCipher;
        try {
          eCipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
          eCipher.init(mode, serverKey, ivSpec);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        return eCipher;
      },
      (mode, serverKey) -&gt; {
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        Cipher eCipher;
        try {
          eCipher = Cipher.getInstance(&quot;AES/CTR/NoPadding&quot;);
          eCipher.init(mode, serverKey, ivSpec);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        return eCipher;
      },
      (mode, serverKey) -&gt; {
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        Cipher eCipher;
        try {
          eCipher = Cipher.getInstance(&quot;AES/CTS/NoPadding&quot;);
          eCipher.init(mode, serverKey, ivSpec);
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
        return eCipher;
      }
    );

    SecretKeySpec serverKey = new SecretKeySpec(key, &quot;AES&quot;);
    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(16 * 8, spec);

    for (int j = 0; j &lt; 3; j++) {
      System.out.println(&quot;*** Run &quot; + (j + 1) + &quot; ***&quot;);
      for (BiFunction&lt;Integer, SecretKeySpec, Cipher&gt; cipherCreator : cipherCreators) {
        for (int i = 1; i &lt;= 32; i *= 2) {
          byte[] randomBytes = new byte[i * 1024 * 1024];
          r.nextBytes(randomBytes);
            long start = System.currentTimeMillis();
          // Encrypt
          ByteArrayOutputStream bout = new ByteArrayOutputStream(randomBytes.length);
          {
            Cipher encryptCipher = cipherCreator.apply(Cipher.ENCRYPT_MODE, serverKey);
            ByteArrayInputStream fin = new ByteArrayInputStream(randomBytes);
            OutputStream cout = new CipherOutputStream(bout, encryptCipher);

            fin.transferTo(cout);
            cout.close();
          }
          byte[] encBytes = bout.toByteArray();
          long encrypted = System.currentTimeMillis();
          // Decrypt
          {
            InputStream fin = new ByteArrayInputStream(encBytes);
            Cipher decryptCipher = cipherCreator.apply(Cipher.DECRYPT_MODE, serverKey);
            InputStream cin = new CipherInputStream(fin, decryptCipher);
            bout = new ByteArrayOutputStream(randomBytes.length);

            cin.transferTo(bout);
          }
          long decrypted = System.currentTimeMillis();

          System.out.println(cipherCreator.apply(Cipher.ENCRYPT_MODE, serverKey).toString() + &quot;  Size=&quot; + i + &quot;M  Encrypted=&quot; + (encrypted - start) + &quot;ms  Decrypted1=&quot; + (decrypted - encrypted) + &quot;ms result1=&quot; + Arrays.equals(randomBytes, bout.toByteArray()));
        }
      }
    }
  }
}
</code></pre>
<p>On my machine, this gives:</p>
<pre><code>*** Run 3 ***
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=1M  Encrypted=13ms  Decrypted1=91ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=2M  Encrypted=25ms  Decrypted1=236ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=4M  Encrypted=56ms  Decrypted1=854ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=8M  Encrypted=104ms  Decrypted1=3552ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=16M  Encrypted=202ms  Decrypted1=13896ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: SunJCE  Size=32M  Encrypted=394ms  Decrypted1=53576ms result1=true
</code></pre>
<p>The O(n²) runtime of the decrypt is quite clear to see!</p>
<p>Looking at the code, it <em>is</em> buffering all input before it would push it out, but that should be O(lg(n)) as the buffer doubles in size each time to copy the input bytes.</p>
<p>It is something specific to the JDK implementation, since Bouncycastle does not exhibit this behaviour:</p>
<pre><code>*** Run 3 ***
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=1M  Encrypted=15ms  Decrypted1=16ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=2M  Encrypted=28ms  Decrypted1=30ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=4M  Encrypted=51ms  Decrypted1=59ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=8M  Encrypted=111ms  Decrypted1=124ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=16M  Encrypted=196ms  Decrypted1=222ms result1=true
Cipher.AES/GCM/NoPadding, mode: encryption, algorithm from: BC  Size=32M  Encrypted=362ms  Decrypted1=443ms result1=true
</code></pre>
"	NULL	NULL	NULL	23:51.8	NULL	NULL	NULL	NULL	NULL	97627	0	1	2	<java><encryption><cryptography><aes-gcm>	Why is the runtime complexity of GCM mode encryption O(n²) in Java?	72	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74598447	0	NULL	"<p>I'm working on a secure Preferences DataStore mechanism in my app in order to save encrypted data.
Using the class described below I am able to encrypt the data, but when I try to decrypt it, I'm getting BadPaddingException.
Do you have any ideea what could cause this? I read a bit about it on the internet, and it is said to be caused by using a different key for decryption from what it was used when the data was encrypted, but I am generating a key only when it doesn't exist in the KeyStore, so I don't think that is the problem.</p>
<pre><code>class CryptoUtils @Inject constructor() {

    private val keyStore = KeyStore.getInstance(KEY_STORE_KEY).apply { load(null) }

    private val encryptCypher
        get() = Cipher.getInstance(TRANSFORMATION).apply {
            init(Cipher.ENCRYPT_MODE, getKey())
        }


    private fun getDecryptCipherForInitVector(iv: ByteArray): Cipher {
        return Cipher.getInstance(TRANSFORMATION).apply {
            init(Cipher.DECRYPT_MODE, getKey(), IvParameterSpec(iv))
        }
    }

    private val keyGenerator =
        KeyGenerator.getInstance(ALGORITHM).apply {
            init(
                KeyGenParameterSpec.Builder(
                    ALIAS,
                    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
                ).setBlockModes(BLOCK_MODE)
                    .setEncryptionPaddings(PADDING)
                    .setUserAuthenticationRequired(false).setRandomizedEncryptionRequired(true)
                    .build()
            )
        }
    

    private fun getKey(): SecretKey {
        val existingKey = keyStore.getEntry(ALIAS, null) as? KeyStore.SecretKeyEntry
        Log.d(&quot;TAG&quot;,&quot;getKEY currentkey = $existingKey&quot;)
        return existingKey?.secretKey ?: keyGenerator.generateKey()
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun encrypt(value: String): String {
        val encryptedBytes = encryptCypher.doFinal(value.toByteArray())

        val iv = encryptCypher.iv
        val ivSize = iv.size
        val ivString = Base64.getEncoder().encodeToString(iv)
        val encResultSize = encryptedBytes.size
        val encodedResult = Base64.getEncoder().encodeToString(encryptedBytes)

        Log.d(
            &quot;TAG&quot;,
            &quot;encrypt value $value iv = $ivString, ivSize = $ivSize, encBytes = $encodedResult, encResultSize = $encResultSize&quot;
        )
        return &quot;$ivString|$ivSize|$encodedResult|$encResultSize&quot;
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun decrypt(encryptedString: String): String {
        val stringList = encryptedString.split(&quot;|&quot;)
        Log.d(&quot;TAG&quot;, &quot;decrypt value $encryptedString&quot;)


        val ivBytes = ByteArray(stringList[1].toInt())
        Base64.getDecoder().decode(stringList[0]).copyInto(ivBytes)
        val encryptedBytes = ByteArray(stringList[3].toInt())
        Base64.getDecoder().decode(stringList[2]).copyInto(encryptedBytes)
        val cipher = getDecryptCipherForInitVector(ivBytes)
        val decryptedData = cipher.doFinal(encryptedBytes)
        Log.d(&quot;TAG&quot;, &quot;decrypted data $decryptedData&quot;)

        return String(decryptedData)
    }

    companion object {
        private const val KEY_STORE_KEY = &quot;AndroidKeyStore&quot;
        private const val ALIAS = &quot;SUEPR&quot;
        private const val ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
        private const val BLOCK_MODE = KeyProperties.BLOCK_MODE_CBC
        private const val PADDING = KeyProperties.ENCRYPTION_PADDING_PKCS7
        private const val TRANSFORMATION = &quot;$ALGORITHM/$BLOCK_MODE/$PADDING&quot;
    }

}
</code></pre>
"	NULL	NULL	NULL	24:39.3	NULL	NULL	NULL	NULL	NULL	4514247	0	1	0	<android><encryption><android-jetpack-datastore>	BadPaddingException when decrypting Android	43	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74601513	74602441	NULL	"<p>I'm trying to decrypt a token that the server I'm using brings in order to load correctly users access to the page.</p>
<p>I already achieved the goal using CryptoJs using JavaScript. However now I need to transfer that function to my java backend.</p>
<p>Look my code using CryptoJs which works correctly</p>
<pre class=""lang-js prettyprint-override""><code>const token = &quot;U2FsdGVkX1+6YueVRKp6h0dZfk/a8AC9vyFfAjxD4nb7mXsKrM7rI7xZ0OgrF1sShHYNLMJglz4+67n/I7P+fg==&quot;
const key = &quot;p80a0811-47db-2c39-bcdd-4t3g5h2d5d1a&quot;

// Decrypt
const iv = CryptoJS.enc.Utf8.parse(key);
const decryptedToken = CryptoJS.AES.decrypt(token, key, {
  keySize: 16,
  iv,
  mode: CryptoJS.mode.CBC,
  padding: CryptoJS.pad.Pkcs7,
});

const stringToken = decryptedToken.toString(CryptoJS.enc.Utf8);
const dataToUse = JSON.parse(stringToken)

console.log(&quot;decryptedToken =&gt; &quot;, stringToken);
console.log(&quot;data =&gt; &quot;,dataToUse);
</code></pre>
<p>And this is my code in Java using javax.crypto</p>
<pre class=""lang-java prettyprint-override""><code>public String decrypt() {
  String finalToken = null;
  Cipher cipher;
  try {
    String token = &quot;U2FsdGVkX1+6YueVRKp6h0dZfk/a8AC9vyFfAjxD4nb7mXsKrM7rI7xZ0OgrF1sShHYNLMJglz4+67n/I7P+fg==&quot;;
    String key = &quot;p80a0811-47db-2c39-bcdd-4t3g5h2d5d1a&quot;;
    Key skeySpec = new SecretKeySpec(Arrays.copyOf(key.getBytes(), 16), &quot;AES&quot;);
    byte[] iv = Arrays.copyOf(key.getBytes(StandardCharsets.UTF_8), 16);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
    byte[] bytesToDecrypt = Base64.decodeBase64(token.getBytes());
    cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;);
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec);
    byte[] decrypted = cipher.doFinal(bytesToDecrypt);
    finalToken = new String(decrypted);
    log.info(&quot;Decrypt token succesfully {}&quot;, finalToken);
  } catch (NoSuchAlgorithmException
      | InvalidAlgorithmParameterException
      | IllegalBlockSizeException
      | NoSuchPaddingException
      | BadPaddingException
      | InvalidKeyException e) {
    e.printStackTrace();
    log.error(&quot;Error decrypting&quot;);
  }

  return finalToken;
}
</code></pre>
<p>I'm not sure I'm setting correctly the key and the iv. With the piece of code above I get this error:</p>
<blockquote>
<p>javax.crypto.BadPaddingException: pad block corrupted</p>
</blockquote>
<p>If I don't &quot;cut&quot; the key and the iv in order to have 16 bytes I get wrong length error.</p>
<p>Can someone help me to figure out what's wrong please!</p>
<p>The expected result is to get this info in java so then I can manipulate the object:</p>
<pre class=""lang-json prettyprint-override""><code>{name: &quot;Burak&quot;, surName: &quot;Bayraktaroglu&quot;}
</code></pre>
"	NULL	NULL	NULL	44:32.3	NULL	NULL	NULL	NULL	NULL	18131215	0	1	1	<javascript><java><spring-boot><encryption><cryptojs>	CryptoJs decrypt function equivalent in Java	121	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74602286	0	NULL	"<p><strong>Context:</strong>
I'm running into an issue of decrypting a value in Java that was encrypted in javascript with crypto-js.
I have two applications on a server talking to each other and some of the requests are secured by sending some encrypted values and decrypting them on the receiving end, to make sure that the requests are not accepted when they are coming from the client, but only from the other server.</p>
<p><strong>Code:</strong>
In javascript I have the following code to encrypt it:</p>
<pre><code>export const encryptString = (stringToEncrypt: string, saltKey: string) =&gt; {
    const key = enc.Utf8.parse(saltKey);
    const ciphertext = AES.encrypt(stringToEncrypt, saltKey, { iv: key }).toString();
    return ciphertext;
};
</code></pre>
<p>In Java I have the following code to decrypt it:</p>
<pre><code>private String decryptString(String stringToDecrypt, String saltKey)
{
    IvParameterSpec iv = new IvParameterSpec(saltKey.getBytes(&quot;UTF-8&quot;));
    SecretKeySpec skeySpec = new SecretKeySpec(saltKey.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;);
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
    byte[] cipherText = cipher.doFinal(Base64.getDecoder().decode(stringToDecrypt));
    return new String(cipherText);
}

</code></pre>
<p><strong>The problem:</strong> The problem seems to be caused by the fact that I am using the 'saltKey' as passphrase in javascript, because if I use the value 'key' it works. Unfortunately it is undesirable to change the encryption because of existing logic.</p>
<p><strong>Question:</strong> Is it possible to modify the java code in a way that it can decrypt the encrypted value? And if so, how?</p>
"	NULL	NULL	NULL	43:50.7	NULL	NULL	NULL	NULL	NULL	20624371	0	1	0	<java><encryption><cryptojs>	How to decrypt in Java after after encrypting with crypto-js and phrasekey?	42	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74637124	0	NULL	"<p>I'm trying to convert a java script to php, but i'm having a hard time, can someone help me</p>
<pre><code>String key = &quot;mykey123823196ext470329981320tst&quot;;
String str = &quot;Emma&quot;;
Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
byte[] IV = new byte[16];
    
SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(&quot;UTF-8&quot;), &quot;AES&quot;);
IvParameterSpec ivParameterSpec = new IvParameterSpec(IV);
        
cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        
String result = Base64.getEncoder().encodeToString(cipher.doFinal(str.getBytes(&quot;UTF-8&quot;)));
        
System.out.println(result); // OUTPUT: wuN9UzYYdmevVxgTxcYIbw==
</code></pre>
<p>This is what i tried but the result is not the same as the output of java code</p>
<pre><code>$str = 'Emma';
$key = 'mykey123823196ext470329981320tst';
$iv  = '0000000000000000';
$encodedEncryptedData = base64_encode(openssl_encrypt($str, &quot;AES-128-CBC&quot;, $key, OPENSSL_RAW_DATA, $iv));
echo $encodedEncryptedData; // OUTPUT: Vn5U9IbbxtQWxyeiLKBu9A==
</code></pre>
"	NULL	NULL	NULL	04:13.8	NULL	NULL	NULL	NULL	NULL	8420124	0	1	1	<java><php><encryption><aes>	How to convert java AES/CBC/PKCS5Padding to php	64	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74644466	0	NULL	"<p>I have been trying to figure this out for 2 days now. Encryption method works fine, but during the decryption tests I am getting the exception below. Especially I am using: AES/GCM/NoPadding.</p>
<p>Error :</p>
<p>Exception in thread &quot;main&quot; javax.crypto.AEADBadTagException: Tag mismatch!</p>
<p>at java.base/com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:623)
at java.base/com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1116)
at java.base/com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1053)
at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2202)
at com.solarwinds.whd.symmetric.GSMTest.decrypt(GSMTest.java:72)
at com.solarwinds.whd.symmetric.GSMTest.main(GSMTest.java:38)</p>
<p>Code:</p>
<pre><code>import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

import static java.nio.charset.StandardCharsets.UTF_8;

public class GSMTest {

private static final String ALGORITHM = &quot;AES&quot;;
private static final int T_LEN = 128;
private static final int IV_LENGTH = 12;

public static void main(String[] args) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException, NoSuchPaddingException, BadPaddingException {
    String s = &quot;xaT2UtvzIt2rO8OMxaT2UtvzIt2rO8OM&quot;;

    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
    keyGenerator.init(256);
    SecretKey key = keyGenerator.generateKey();

    GSMTest ob = new GSMTest();
    System.out.println(&quot;Before encrypt: &quot;+s);
    String se = ob.encrypt(s, key);
    System.out.println(&quot;After encrypt: &quot;+se);
    String sd = ob.decrypt(se, key);
    System.out.println(&quot;After decrypt: &quot;+sd);
}

public String encrypt(String text, SecretKey key) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException {
    byte[] iv = new byte[IV_LENGTH];
    (new SecureRandom()).nextBytes(iv);

    SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), ALGORITHM);
    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    GCMParameterSpec ivSpec = new GCMParameterSpec(T_LEN, iv);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] ciphertext = cipher.doFinal(text.getBytes(UTF_8));
    byte[] encrypted = new byte[iv.length + ciphertext.length];
    System.arraycopy(iv, 0, encrypted, 0, iv.length);
    System.arraycopy(ciphertext, 0, encrypted, iv.length, ciphertext.length);

    Base64.Encoder en = Base64.getEncoder();
    return en.encodeToString(encrypted);

}

public String decrypt(String encryptedText, SecretKey key) throws IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException {
    Base64.Decoder de = Base64.getDecoder();

    byte[] decoded = de.decode(encryptedText);
    byte[] iv = Arrays.copyOfRange(decoded, IV_LENGTH, decoded.length);

    SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), ALGORITHM);
    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    GCMParameterSpec ivSpec = new GCMParameterSpec(T_LEN, iv);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decryptedText = cipher.doFinal(decoded);

    return new String(decryptedText);
}

}
</code></pre>
<p>Can anyone help? I have been reading many about, and still cannot find anything wrong.</p>
"	NULL	NULL	NULL	38:23.2	NULL	NULL	NULL	NULL	NULL	5236334	0	1	0	<java><encryption><aes-gcm>	problem while decrypting private key getting javax.crypto.AEADBadTagException: Tag mismatch! Error	244	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74645257	74646310	NULL	"<p>I'm struggling with openssl and aes encryption. I need to encrypt a file in java while forcing the key and IV values instead of using a password. It must be decipher with the following command:</p>
<pre class=""lang-bash prettyprint-override""><code>openssl aes-256-cbc -d -K $KEY_VALUE -iv $IV -in hello.txt.ssl -out hello-clear.txt
</code></pre>
<p>Sadly, I can not change this command, it's the requirement of the client.</p>
<p>I managed to encrypt the file in java (see following code) but I get this error when decrypting it with openssl</p>
<pre><code>hex string is too short, padding with zero bytes to length
hex string is too short, padding with zero bytes to length
bad decrypt
40874B28DD7F0000:error:1C800064:Provider routines:ossl_cipher_unpadblock:bad decrypt:providers/implementations/ciphers/ciphercommon_block.c:124:
</code></pre>
<p>Any idea of what I missed in the encryption process ? Or any other way to do it ?</p>
<p><em>Here is the full java sample that encrypt and generate the decryption command:</em></p>
<pre class=""lang-java prettyprint-override""><code>import org.apache.commons.io.IOUtils;

import javax.crypto.Cipher;
import javax.crypto.spec.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;

public class OpenSslEncryptor {

    public static void main(String... args) throws Exception {

        int keyLength = 256;
        int keyLengthInBit = keyLength / 8;

        File baseFile = new File(&quot;hello.txt&quot;);
        IOUtils.write(&quot;hello openssl !&quot;, new FileOutputStream(baseFile), StandardCharsets.UTF_8);
        byte[] inBytes = new FileInputStream(baseFile).readAllBytes();

        String keyValue = generateRandom(40);
        String iv = generateRandom(16);
        byte[] keyValueB = Arrays.copyOfRange(keyValue.getBytes(), 0, keyLengthInBit);
        byte[] ivB = Arrays.copyOfRange(iv.getBytes(), 0, 16);

        final SecretKeySpec key = new SecretKeySpec(keyValueB, &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivB));

        byte[] data = cipher.doFinal(inBytes);

        File outputFile = new File(baseFile.getAbsolutePath() + &quot;.ssl&quot;);
        IOUtils.write(data, new FileOutputStream(outputFile));

        String decryptCommand = &quot;openssl aes-256-cbc -d -K &quot; + keyValue
                + &quot; -iv &quot; + iv
                + &quot; -in &quot; + outputFile.getName()
                + &quot; -out hello-clear.txt&quot;;

        System.out.println(decryptCommand);
    }

    private static String generateRandom(int length) {
        SecureRandom secureRandom = new SecureRandom();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            builder.append(Integer.toHexString(secureRandom.nextInt(16)));
        }
        return builder.toString();
    }
}
</code></pre>
<p>Here is the command line encrypt with openssl if anyone want it</p>
<pre class=""lang-bash prettyprint-override""><code>openssl aes-256-cbc -e -K $KEY_VALUE -iv $IV -in hello.txt -out hello.txt.ssl
</code></pre>
"	NULL	NULL	NULL	36:50.5	NULL	NULL	NULL	NULL	NULL	954248	0	1	0	<java><encryption><openssl>	AES-256-CBC encrypt with key / IV in java and decrypt in OpenSSL	249	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74655202	0	NULL	"<p>I want to implement AES GCM encryption/decryption using shared secret.</p>
<p>But Backend server is throwing error with my keys. This is working fine in Android app with Java. Although size of encrypted text is same in both iOS and Android.
My iOS code.</p>
<pre><code>private func getCryptoPublicKey() -&gt; (privateKey: Curve25519.KeyAgreement.PrivateKey,publicKey :Curve25519.KeyAgreement.PublicKey){
        
        let ephemeralKey = Curve25519.KeyAgreement.PrivateKey()
        
        
        //AES.KeyWrap.wrap(SymmetricKey(size: .bits256), using: &lt;#T##SymmetricKey#&gt;)
        
        let ephemeralPublicKey = ephemeralKey.publicKey
        
        let privateKey = ephemeralKey.rawRepresentation.base64EncodedString()
        
        let publicKey = ephemeralPublicKey.rawRepresentation.base64EncodedString()
        
        Singleton.shared.clientPrivateKey = privateKey
        
        Singleton.shared.clientPublicKey = publicKey
        
        return (ephemeralKey,ephemeralPublicKey)
    }





let cryptoData = self.getCryptoPublicKey()
let publicKeyData = Data.init(base64Encoded: ServerPublicKey)!  //ServerPublicKey is shared by server 
        
        let serverPublicKey = try! Curve25519.KeyAgreement.PublicKey(rawRepresentation: publicKeyData)
      
        let clientSharedSecret = try! cryptoData.privateKey.sharedSecretFromKeyAgreement(with: serverPublicKey)
        
        let clientSharedSecretSymmetricKey = clientSharedSecret.x963DerivedSymmetricKey(using: SHA256.self, sharedInfo: Data(), outputByteCount: 32)


let clientSealedBoxDatakClientId = try! AES.GCM.seal(kClientId.data(using: .utf8)!, using: clientSharedSecretSymmetricKey).combined!

        let clientSealedBoxDatakClientSecret = try! AES.GCM.seal(kClientSecret.data(using: .utf8)!, using: clientSharedSecretSymmetricKey).combined!

        let clientSealedBoxDataCredent = try! AES.GCM.seal(&quot;client_credentials&quot;.data(using: .utf8)!, using: clientSharedSecretSymmetricKey).combined!



let clientIDEncryptedBase64Str = clientSealedBoxDatakClientId.base64EncodedString()

        let clientSecretEncryptedBase64Str = clientSealedBoxDatakClientSecret.base64EncodedString()

        let clientCredentialsEncryptedBase64Str = clientSealedBoxDataCredent.base64EncodedString()


</code></pre>
<p>JAVA CODE:</p>
<p>`</p>
<pre><code>private void makeKeyExchangeParams() {
    KeyPairGenerator kpg;
    try {
        kpg = KeyPairGenerator.getInstance(&quot;X25519&quot;, new org.bouncycastle.jce.provider.BouncyCastleProvider());
        kpg.initialize(AES_KEY_SIZE);
        KeyPair kp = kpg.generateKeyPair();
        publickey = kp.getPublic();
        keyAgreement = KeyAgreement.getInstance(&quot;XDH&quot;, new org.bouncycastle.jce.provider.BouncyCastleProvider());
        keyAgreement.init(kp.getPrivate());

    } catch (NoSuchAlgorithmException | InvalidKeyException  e) {
        e.printStackTrace();
    }
}
</code></pre>
<pre><code>package com.bankofbaroda.bobabhivyakti.Utilities.Encryption;

import android.os.Build;

import androidx.annotation.RequiresApi;

import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.nio.charset.StandardCharsets;
import java.security.*;
import java.util.Base64;


public class CryptoService {
    public static final int GCM_IV_LENGTH = 12;
    public static final int GCM_TAG_LENGTH = 16;

    @RequiresApi(api = Build.VERSION_CODES.O)
    public static String getEncryptedText(String plainText, SecretKey secretKey) {
        if(plainText == null) {
            plainText = &quot;&quot;;
        }
        try {
            byte[] ivBytes = new byte[GCM_IV_LENGTH];
            SecureRandom random = new SecureRandom();
            random.nextBytes(ivBytes);
            String iv = Base64.getEncoder().encodeToString(ivBytes);

            byte[] cipherText = encrypt(plainText.getBytes(), secretKey, ivBytes);
            String text = Base64.getEncoder().encodeToString(cipherText);
            text = iv+text;
            return text;
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;&quot;;
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    public static String getDecryptedText(String cipherText, SecretKey secretKey) {
        try {
            String iv = cipherText.substring(0,16);
            byte[] ivBytes = Base64.getDecoder().decode(iv);
            cipherText = cipherText.substring(16);


            byte[] data = Base64.getDecoder().decode(cipherText);
            return decrypt(data, secretKey, ivBytes);
        } catch (Exception e) {
            e.printStackTrace();
            return &quot;&quot;;
        }
    }

    private static byte[] encrypt(byte[] plaintext, SecretKey key, byte[] nonce) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), &quot;AES&quot;);
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmParameterSpec);
        return cipher.doFinal(plaintext);
    }

    private static String decrypt(byte[] cipherText, SecretKey key, byte[] nonce) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        SecretKeySpec keySpec = new SecretKeySpec(key.getEncoded(), &quot;AES&quot;);
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmParameterSpec);
        byte[] decryptedText = cipher.doFinal(cipherText);
        return new String(decryptedText);
    }
}

</code></pre>
<p>`</p>
<p>I am not able to get what is exact issue here. Do I have to change something on Java side?</p>
"	NULL	NULL	NULL	38:04.0	NULL	NULL	NULL	NULL	NULL	20665756	0	1	0	<bouncycastle><aes-gcm><apple-cryptokit>	AES/GCM/NoPadding in swift iOS	157	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74706293	0	NULL	"<p>While I was going through a piece of code in JAVA for encryption there is padding mechanism we can provide while creating cipher instance.</p>
<blockquote>
<pre><code>        final Cipher cipher = Cipher.getInstance(&quot;AES/CBC/ISO10126Padding&quot;);
</code></pre>
</blockquote>
<p>Here we can specify the padding to be used.</p>
<p>How can i achieve the same in Node.js?</p>
<p>Use Case: I am decrypting the data which i have encrypted via JAVA using this method.</p>
<p>Note: In Java i can encrypt &amp; decrypt by creating the cipher instance the above provided way and getting success response.
Let me know if any other info required.</p>
"	NULL	NULL	NULL	53:26.4	NULL	NULL	NULL	NULL	NULL	9639645	0	1	1	<java><node.js><encryption><node-crypto>	How can I use custom padding in Node js encryption and decryption?	62	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74714504	0	NULL	"<p>I have this project wherein I have to convert nodeJs into Kotlin. The nodeJs project uses CryptoJS.AES.encrypt(text, password) which produces a encrypted value with 256 bytes. I. have been doing this in kotlin but the encrypted value returned is not the same from the nodeJs version and it only has 236 bytes. Can someone help me why it is not producing the same result? and how can i do it? Below is my sample code in kotlin</p>
<pre><code>fun encryptAesTry(text: String, password: String): String {

    val md = MessageDigest.getInstance(&quot;SHA-256&quot;)
    val bytes = password.toByteArray(StandardCharsets.UTF_8)
    md.update(bytes, 0, bytes.size)
    val key = md.digest()
    val secretKeySpec = SecretKeySpec(key, &quot;AES&quot;)
    val c = Cipher.getInstance(&quot;AES&quot;)
    c.init(Cipher.ENCRYPT_MODE, secretKeySpec)
    val encVal = c.doFinal(text.toByteArray())
            
    return Base64.getEncoder().encodeToString(encVal)

}
</code></pre>
"	NULL	NULL	NULL	39:33.9	NULL	NULL	NULL	NULL	NULL	17842135	0	1	0	<java><kotlin><encryption><aes><cryptojs>	"Applying CryptoJS.AES.encrypt(inputText, password) in kotlin"	148	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74721065	74737175	NULL	"<p>I am trying to use below decrypt method(found it over internet) in my GO application. The cipherKey that I have is not a straightforward 32 bit one, but it looks to be base64 encoded. Hence, I decoded that first and then applied. I don't get any error in this whole decryption process, however the output of this decrypt method looks to be another ciphertext.</p>
<p>Not sure if I am missing something as far as the cipherKey is concerned.</p>
<pre><code>func decrypt(key []byte, secure string) (decoded string, err error) {
    //Remove base64 encoding:
    cipherText, err := base64.StdEncoding.DecodeString(secure)

    //IF DecodeString failed, exit:
    if err != nil {
        return
    }

    //Create a new AES cipher with the key and encrypted message
    block, err := aes.NewCipher(key)

    //IF NewCipher failed, exit:
    if err != nil {
        return
    }

    //IF the length of the cipherText is less than 16 Bytes:
    if len(cipherText) &lt; aes.BlockSize {
        err = errors.New(&quot;ciphertext block size is too short&quot;)
        return
    }

    iv := cipherText[:aes.BlockSize]
    cipherText = cipherText[aes.BlockSize:]
    fmt.Println(&quot;before deciphering: &quot;, string(cipherText))

    //Decrypt the message
    stream := cipher.NewCFBDecrypter(block, iv)
    stream.XORKeyStream(cipherText, cipherText)

    return string(cipherText), err
}
</code></pre>
<p>Updating the original question...</p>
<p>I have got to decrypt a data in my GO application. The data, in turn, is coming from a Java application. Here are the snippets from the same,</p>
<pre><code>public static final String KEY_ALGORITHM = &quot;AES&quot;;
public static final String AES_ALGORITHM = &quot;AES/CFB8/NoPadding&quot;;
public static final String DIGEST_ALGORITHM = &quot;MD5&quot;;
public static final byte[] INITIAL_VECTOR = { -25, 9, -119, 91, -90, 112, 98, -40, 65, -106, -1, 96, 118, -13, 88,
                85 }; 
</code></pre>
<pre><code>package com.crypto;

import static com.CryptoConstant.AES_ALGORITHM;
import static com.CryptoConstant.DIGEST_ALGORITHM;
import static com.CryptoConstant.INITIAL_VECTOR;
import static com.CryptoConstant.KEY_ALGORITHM;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;


@Slf4j
@Component
public class MessageCrypto {

    /**
     * 
     */
    @Value(&quot;${design.secret.key}&quot;)
    private String designSecretKey;

    /**
     * Md 5
     *
     * @param input the input
     * @return the string
     * @throws NoSuchAlgorithmException the no such algorithm exception
     */
    private static String md5(final String input) throws NoSuchAlgorithmException {
        final MessageDigest md = MessageDigest.getInstance(DIGEST_ALGORITHM);
        final byte[] messageDigest = md.digest(input.getBytes());
        // Convert byte array to a string of hex digits
        final BigInteger number = new BigInteger(1, messageDigest);
        // The 0 in the mask does the padding, 32 chars and x indicates lower hex
        // digits.
        return String.format(&quot;%032x&quot;, number);
    }

    /**
     * Inits the cipher
     *
     * @param mode the mode
     * @return the cipher
     * @throws NoSuchAlgorithmException           the no such algorithm exception
     * @throws NoSuchPaddingException             the no such padding exception
     * @throws InvalidKeyException                the invalid key exception
     * @throws InvalidAlgorithmParameterException the invalid algorithm parameter
     *                                            exception
     */
    private Cipher initCipher(final int mode) throws NoSuchAlgorithmException, NoSuchPaddingException,
            InvalidKeyException, InvalidAlgorithmParameterException {

        final SecretKeySpec skeySpec = new SecretKeySpec(md5(designSecretKey).getBytes(), KEY_ALGORITHM);
        final IvParameterSpec initialVector = new IvParameterSpec(INITIAL_VECTOR);
        final Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(mode, skeySpec, initialVector);
        return cipher;
    }

    /**
     * Encrypt
     * 
     * @param dataToEncrypt the data to encrypt
     * @return the string
     */
    public String encrypt(final String dataToEncrypt) {
        log.info(&quot;Processing encrypt...&quot;);
        byte[] encryptedData = {};

        try {

            // Initialize the cipher
            final Cipher cipher = initCipher(Cipher.ENCRYPT_MODE);
            // Encrypt the data
            final byte[] encryptedByteArray = cipher.doFinal(dataToEncrypt.getBytes());
            // Encode using Base64
            encryptedData = Base64.getEncoder().encode(encryptedByteArray);

        } catch (IllegalBlockSizeException | BadPaddingException | NoSuchAlgorithmException | NoSuchPaddingException
                | InvalidAlgorithmParameterException | InvalidKeyException e) {
            log.error(&quot;Encryption error: {} &quot;, e);
        }
        log.info(&quot;Processed encrypt...&quot;);
        return new String(encryptedData);
    }

    /**
     * Decrypt
     *
     * @param encryptedData the encrypted data
     * @return the string
     */
    public String decrypt(final String encryptedData) {
        log.info(&quot;Processing decrypt...&quot;);
        String decryptedData = &quot;&quot;;

        try {

            // Initialize the cipher
            final Cipher cipher = initCipher(Cipher.DECRYPT_MODE);
            // Decode using Base64
            final byte[] encryptedByteArray = Base64.getDecoder().decode(encryptedData.getBytes());
            // Decrypt the data
            final byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);

            decryptedData = new String(decryptedByteArray, StandardCharsets.UTF_8);

        } catch (IllegalBlockSizeException | BadPaddingException | NoSuchAlgorithmException | NoSuchPaddingException
                | InvalidAlgorithmParameterException | InvalidKeyException e) {
            log.error(&quot;Decryption error: {} &quot;, e);
        }
        log.info(&quot;Processed decrypt...&quot;);
        return decryptedData;
    }

}
</code></pre>
<p>I have received the cipherkey as well as a ciphertext from their side. Now I need to implement something equivalent to this Java in GO. I am trying to use CFB encrypt/decrypt mechanism which appears to be straightforward to implement. However, I am trying to figure out how to retrieve the actual cipherkey from provided one. From the Java code it looks like, I need to have something equivalent to what md5() method is doing here in Java.</p>
<p>Here is something that I tried,</p>
<pre><code>key := &quot;94k/IwqJQ5wf4Yt5JZmbW85r2x246rI3g3LZbTI80Vo=&quot;
key_decr := md5.Sum([]byte(key))
key = hex.EncodeToString(key_decr[:])
log.Println(&quot;key:&quot;, key)
decrypt(key, secureText)
</code></pre>
<p>However, that does not work.</p>
"	NULL	NULL	NULL	59:10.6	NULL	NULL	NULL	NULL	NULL	18164170	0	1	1	<go><aes>	Golang AES decryption mechanism outputs another ciphertext only	214	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74722438	0	NULL	"<p>I'm on iOS and trying to match the Android AES-CTR decryption.
The code on Android:</p>
<pre><code>Cipher cipher = Cipher.getInstance(&quot;AES/CTR/NoPadding&quot;);
cipher.init(
      Cipher.DECRYPT_MODE,
      key,
      new IvParameterSpec(ivStr));
  result =
      cipher.doFinal(dataToDecrypt);
</code></pre>
<p>I'm trying to use CommonCrypto in swift to implement the same logic above, there is what I have for now:</p>
<pre><code>    func AESCRTDecrypt(with key: [UInt8], encryptedData: [UInt8], iv: [UInt8]) -&gt; [UInt8]? {
    var resultBytes = [UInt8](repeating: 0, count: encryptedData.count)
    var resultLength = 0
    let status = CCCrypt(CCOperation(kCCDecrypt),
                         CCAlgorithm(kCCAlgorithmAES),
                         CCOptions(????), // THIS IS MY Question: how to set AES-CTR-DECRYPT option so it can be the same as Android above as &quot;AES/CTR/NoPadding&quot;? 
                         key,
                         kCCKeySizeAES256,
                         iv,
                         encryptedData,
                         encryptedData.count,
                         &amp;resultBytes,
                         resultBytes.count,
                         &amp;resultLength)
    guard status == kCCSuccess else {
        Log.e(&quot;Failed in AES-CRT-DECRYPTION. Status: \(status)&quot;)
        return nil
    }
    return resultBytes
}
</code></pre>
<p>My question was commented above:  how to set the option so it can be same as Android above as &quot;AES/CTR/NoPadding&quot;?
I checked the options and some example code for this function, there are only 2 options in the enum for options:</p>
<pre><code>public var kCCOptionPKCS7Padding: Int { get }
public var kCCOptionECBMode: Int { get }
</code></pre>
<p>Neither of them is what I want..</p>
<p>Could any help here?
Thanks!!</p>
"	NULL	NULL	NULL	16:53.9	NULL	NULL	NULL	NULL	NULL	4830531	0	1	0	<swift><commoncrypto>	How to use swift CommonCrypto to implement AES-CTR decryption in swift	16	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74736093	0	NULL	"<p>If I needed to reference an encoding, like UTF-8, I'd typically reference the <code>StandardCharset.UTF-8</code> static, not use a String literal <code>&quot;UTF-8&quot;</code>.</p>
<p>When working with cipher transformations, I see everywhere that transformations are given as String literals, like <code>Cipher.getInstance(&quot;AES&quot;)</code> or <code>Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;)</code>, and occasionally, there's a typo.</p>
<p>Which class can I use for statics of cipher algorithm names, modes and paddings? Does one exist?</p>
<p>For reference, <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher"" rel=""nofollow noreferrer"">list of permitted names/modes/paddings</a> in the docs.</p>
"	NULL	NULL	NULL	40:56.9	NULL	NULL	NULL	NULL	NULL	19972353	0	1	1	<java><encryption><javax.crypto>	Is there a class containing statics for algorithm names/modes/paddings?	38	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74798951	0	NULL	"<p>I am trying to write and encrypt/decrypt program that. I am able to encrypt the String just fine, but while decrypting, I am getting the above error.</p>
<p>My code currently looks like this:</p>
<pre><code>import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

public class Trial {

    static String key = &quot;USSWIF3925NJ50R&quot;;
    static String userName = &quot;sam1234t&quot;;

    public static void main(String[] arg) throws IllegalBlockSizeException, BadPaddingException {

        Trial trial = new Trial();

        Cipher cipher = trial.initialiseCipher(&quot;encrypt&quot;);

        // Finally generate the transient key in bytes.
        byte[] transientKey = cipher.doFinal(userName.getBytes(StandardCharsets.UTF_8));

        String encryptedPassword = Base64.getEncoder().encodeToString(transientKey);

        System.out.println(&quot;Encrypted Key: &quot; + encryptedPassword);

        cipher = trial.initialiseCipher(&quot;decrypt&quot;);

        // Finally decrypt the transient key in bytes.
        byte[] temp = cipher.doFinal(encryptedPassword.getBytes(StandardCharsets.UTF_8));
        String decryptedKey = new String(Base64.getDecoder().decode(temp));

        System.out.println(&quot;Decrypted Key: &quot; + decryptedKey);
    }


    private Cipher initialiseCipher(String mode) {

        Cipher cipher = null;

        try {

            Security.setProperty(&quot;crypto.policy&quot;, &quot;unlimited&quot;);

            SecureRandom secureRandom = new SecureRandom();
            byte[] salt = new byte[256];
            byte[] ivBytes = new byte[16];

            secureRandom.nextBytes(salt);
            secureRandom.nextBytes(ivBytes);

            // Generate the Key Specs.
            IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);
            PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, 65536, ivParameterSpec);
            PBEKeySpec pbeKeySpec = new PBEKeySpec((key + userName).toCharArray());

            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBEWITHHMACSHA512ANDAES_256&quot;);
            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);

            cipher = Cipher.getInstance(&quot;PBEWITHHMACSHA512ANDAES_256&quot;);

            if (mode.equals(&quot;encrypt&quot;)) {
                cipher.init(Cipher.ENCRYPT_MODE, secretKey, pbeParameterSpec);
            } else if (mode.equals(&quot;decrypt&quot;)) {
                cipher.init(Cipher.DECRYPT_MODE, secretKey, pbeParameterSpec);
            }

        } catch (NoSuchAlgorithmException e) {

            e.printStackTrace();

        } catch (InvalidKeySpecException e) {

            e.printStackTrace();

        } catch (NoSuchPaddingException e) {

            e.printStackTrace();

        } catch (InvalidKeyException e) {

            e.printStackTrace();

        } catch (InvalidAlgorithmParameterException e) {

            e.printStackTrace();
        }

        return cipher;
    }
}
</code></pre>
<p>When I run the piece of code I get the output:</p>
<pre><code>Encrypted Key: 9DfMJ/yuEFobrdGVsVkhpQ==
Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
    at com.sun.crypto.provider.CipherCore.prepareInputBuffer(CipherCore.java:1005)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:848)
    at com.sun.crypto.provider.PBES2Core.engineDoFinal(PBES2Core.java:323)
    at javax.crypto.Cipher.doFinal(Cipher.java:2164)
    at com.att.logicalprovisioning.simulators.Trial.main(Trial.java:43)
</code></pre>
<p>All the solutions I Googled for use the Cipher algorithm as <code>AES</code>. So I am not sure it replicates like for like, I have tried a few of them, without any luck.</p>
<p>Any help would be helpful. Thanks.</p>
"	NULL	NULL	NULL	22:28.3	NULL	NULL	NULL	NULL	NULL	1047226	0	1	0	<java><encryption><cryptography><aes><hmacsha256>	Input length must be multiple of 16 when decrypting with padded cipher (PBEWITHHMACSHA512ANDAES_256)	127	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74839342	0	NULL	"<p>Here is my AES Library in Java:</p>
<pre><code>public class AESUtil {

  private SecretKeySpec secretKey;

  public static void main(String[] args) {
    String str = args[1];
    String salt = args[2];

    AESUtil aesUtil = new AESUtil();

    if (args[0].equals(&quot;D&quot;)) {
      //Going to Decrypt
      System.out.println(aesUtil.decrypt(str, salt));
    } else {
      //Going to Encrypt
      System.out.println(aesUtil.encrypt(str, salt));
    }
  }

  public String encrypt(final String strToEncrypt, final String secret) {
    try {
      setKey(secret);
      Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
      cipher.init(Cipher.ENCRYPT_MODE, secretKey);
      return Base64.getEncoder()
          .encodeToString(cipher.doFinal(strToEncrypt.getBytes(StandardCharsets.UTF_8)));
    } catch (Exception e) {
      System.out.println(&quot;Error while encrypting: &quot; + e.toString());
    }
    return null;
  }

  public String decrypt(final String strToDecrypt, final String secret) {
    try {
      setKey(secret);
      Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;);
      cipher.init(Cipher.DECRYPT_MODE, secretKey);
      return new String(cipher.doFinal(Base64.getDecoder()
          .decode(strToDecrypt)));
    } catch (Exception e) {
      System.out.println(&quot;Error while decrypting: &quot; + e.toString());
    }
    return null;
  }

  private void setKey(final String myKey) {
    MessageDigest sha = null;
    try {
      byte[] key = myKey.getBytes(StandardCharsets.UTF_8);
      sha = MessageDigest.getInstance(&quot;SHA-1&quot;);
      key = sha.digest(key);

      key = Arrays.copyOf(key, 16);

      secretKey = new SecretKeySpec(key, &quot;AES&quot;);
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
    }
  }
}
</code></pre>
<p>Here is my Decryption Logic in Javascript using CryptoJS lib:</p>
<pre><code>function decrypt() {
    var hashedKey = CryptoJS.SHA1(CryptoJS.enc.Utf8.parse(document.getElementById(&quot;pass&quot;).value));
    console.log(hashedKey)
    
    var encryptedCipherText = document.getElementById(&quot;text&quot;).value;
    console.log(encryptedCipherText)

    var decryptedData = CryptoJS.AES.decrypt(encryptedCipherText, hashedKey,
      {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
      })
    console.log(decryptedData)

    var decryptedText = decryptedData.toString(CryptoJS.enc.Utf8);
    console.log(decryptedText)

    document.getElementById(&quot;decrypted&quot;).innerHTML = decryptedText;
    document.getElementById(&quot;result&quot;).innerHTML = '';
  }
</code></pre>
<p>In Java:</p>
<p>For:</p>
<p>Plain Text: <code>This Value is to Encrypt</code></p>
<p>Secret: <code>shh!</code></p>
<p>Encrypted Value: <code>i8DHmeHuoQWv3rwZ+cybgSdSkyUX7MAcU54NUf2iyxU=</code></p>
<p>However when putting the same value in Javascript:</p>
<p><a href=""https://i.stack.imgur.com/RGkF9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RGkF9.png"" alt=""HTML View"" /></a></p>
<p>I have a high suspect on SHA1 logic i have in Java, that might be causing the issue. But not sure on how to validate that.</p>
"	NULL	NULL	NULL	44:42.7	NULL	NULL	NULL	NULL	NULL	5809504	0	1	0	<javascript><java><encryption><cryptojs>	Crypto JS and Java Security Library for replicate both Encryption and Decryption	191	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74901735	0	NULL	"<p>I'm looking for someone who could help me to integrate the Login Part (with Encryption) with the last Instagram API version for Useragent.</p>
<p>Actually I have an Android app which runs with the old version of Instagram API (8.2.0) which runs with just Username and Password but I have to update it and it seems I have to encrypt the password...</p>
<p>The github I'm looking is in JAVA (<a href=""https://github.com/instagram4j/instagram4j"" rel=""nofollow noreferrer"">https://github.com/instagram4j/instagram4j</a>), and
I think the missing thing is the ecryption ( public static String encryptPassword(String password, String enc_id, String enc_pub_key) ), but I was not able to integrate it to my project...</p>
<p>Did someone manage to do the login with recent Instagram API version with Android?</p>
<p>Please send me a pm with the budget to Telegram: @autostagram</p>
<pre><code> @SneakyThrows
public static String encryptPassword(String password, String enc_id, String enc_pub_key) {
    byte[] rand_key = new byte[32], iv = new byte[12];
    SecureRandom sran = new SecureRandom();
    sran.nextBytes(rand_key);
    sran.nextBytes(iv);
    String time = String.valueOf(System.currentTimeMillis() / 1000);

    // Encrypt random key
    String decoded_pub_key =
            new String(Base64.getDecoder().decode(enc_pub_key), StandardCharsets.UTF_8)
                    .replaceAll(&quot;-(.*)-|\n&quot;, &quot;&quot;);
    Cipher rsa_cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1PADDING&quot;);
    rsa_cipher.init(Cipher.ENCRYPT_MODE, KeyFactory.getInstance(&quot;RSA&quot;)
            .generatePublic(
                    new X509EncodedKeySpec(Base64.getDecoder().decode(decoded_pub_key))));
    byte[] rand_key_encrypted = rsa_cipher.doFinal(rand_key);

    // Encrypt password
    Cipher aes_gcm_cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    aes_gcm_cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(rand_key, &quot;AES&quot;),
            new GCMParameterSpec(128, iv));
    aes_gcm_cipher.updateAAD(time.getBytes());
    byte[] password_encrypted = aes_gcm_cipher.doFinal(password.getBytes());

    // Write to final byte array
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    out.write(Integer.valueOf(1).byteValue());
    out.write(Integer.valueOf(enc_id).byteValue());
    out.write(iv);
    out.write(ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN)
            .putChar((char) rand_key_encrypted.length).array());
    out.write(rand_key_encrypted);
    out.write(Arrays.copyOfRange(password_encrypted, password_encrypted.length - 16,
            password_encrypted.length));
    out.write(Arrays.copyOfRange(password_encrypted, 0, password_encrypted.length - 16));

    return String.format(&quot;#PWD_INSTAGRAM:%s:%s:%s&quot;, &quot;4&quot;, time,
            Base64.getEncoder().encodeToString(out.toByteArray()));
}
</code></pre>
"	NULL	NULL	NULL	13:14.6	NULL	NULL	NULL	NULL	NULL	2158354	0	1	0	<android><api><instagram>	Instagram Private API Login for Android (Paid Service)	57	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74917947	74918428	NULL	"<p>I am using AES/GCM/NoPadding 128 bit. I want to encrypt in Java &amp; decrypt it in Javascript.</p>
<p>When I encrypt in JS &amp; try to decrypt in Java I get the error as <em>Tag mismatch!null</em></p>
<p>When I encrypt in Java &amp; try to decrypt in JS I get the error as</p>
<pre><code>internal/crypto/cipher.js:164
  const ret = this._handle.final();
                           ^

Error: Unsupported state or unable to authenticate data
    at Decipheriv.final (internal/crypto/cipher.js:164:28)
    at decrypt (/tmp/HoErdq6TQ2.js:51:58)
</code></pre>
<p>What am I missing in my JS
Please suggest fixes in JS code, Java code can't be changed as it is in use on production</p>
<p>Java code:</p>
<pre><code>
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import java.util.logging.Logger;
import java.util.Base64;

public class HelloWorld {

    private final static Logger LOGGER =  Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);

    public static void main(String []args) {
        String masterKey = &quot;2f12cb0f1d2e3d12345f1af2b123dce4&quot;;
        String encrypted = aesEncryptStringV2(&quot;Hello, World!&quot;, masterKey);
        System.out.println(encrypted);
        

        String decrypted = aesDecryptStringV2(encrypted, masterKey);
        System.out.println(decrypted);
    }


    private static final String ALGORITHM = &quot;AES/GCM/NoPadding&quot;;
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;

    private static SecretKeySpec setKeyV2(final String myKey) {
        try {
            byte[] newKey = myKey.getBytes(StandardCharsets.UTF_8);
            MessageDigest sha = MessageDigest.getInstance(&quot;SHA-512&quot;);

            newKey = sha.digest(newKey);
            newKey = Arrays.copyOf(newKey, 16);

            return new SecretKeySpec(newKey, &quot;AES&quot;);
        } catch (Exception e) {
            System.out.println(&quot;Error in setKeyV2: &quot;);
            System.out.println(e.getMessage());
        }
        return null;
    }

    public static synchronized String aesEncryptStringV2(
        final String strToEncrypt, final String secret) {
        try {
            SecretKeySpec newSecretKey = setKeyV2(secret);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec gcmParameterSpec = new
            GCMParameterSpec(GCM_TAG_LENGTH * 8,
                             new byte[GCM_IV_LENGTH]);
            cipher.init(Cipher.ENCRYPT_MODE, newSecretKey, gcmParameterSpec);
            return Base64.getEncoder()
                   .encodeToString(cipher.doFinal(strToEncrypt.getBytes(StandardCharsets.UTF_8
                                                                       )));
        } catch (Exception e) {
            System.out.println(&quot;Error in aesEncryptStringV2: &quot;);
            System.out.println(e.getMessage());
        }
        return null;
    }

    public static synchronized String aesDecryptStringV2(
        final String strToDecrypt, final String secret) {
        try {
            SecretKeySpec newSecretKey = setKeyV2(secret);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            GCMParameterSpec gcmParameterSpec = new
            GCMParameterSpec(GCM_TAG_LENGTH * 8,
                             new byte[GCM_IV_LENGTH]);
            cipher.init(Cipher.DECRYPT_MODE, newSecretKey, gcmParameterSpec);

            return new
                   String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
        } catch (Exception e) {
            System.out.println(&quot;Error in aesDecryptStringV2: &quot;);
            System.out.println(e.getMessage());
        }
        return null;
    }
}

</code></pre>
<p>Javascript Code:</p>
<pre><code>
const crypto = require('crypto');


const cryptoConfig = {
    cipherAlgorithm: 'aes-128-gcm',
    masterKey: '2f12cb0f1d2e3d12345f1af2b123dce4',
    ivLength: 12,
    tagLength: 16,
    digest: 'sha512'
}

const generateKey = () =&gt; {
    var h = crypto.createHash(cryptoConfig.digest);
    h.update(cryptoConfig.masterKey, 'utf8');
    
    var k = h.digest().slice(0, 16);
    return k;
  };

function encrypt(content) {
    const iv = crypto.randomBytes(cryptoConfig.ivLength);
    const key = generateKey();

    const cipher = crypto.createCipheriv(cryptoConfig.cipherAlgorithm, key, iv, {authTagLength: cryptoConfig.tagLength});

    const encrypted = Buffer.concat([cipher.update(content, 'utf8'), cipher.final()]);

    const tag = cipher.getAuthTag();

    return Buffer.concat([iv, encrypted, tag]).toString('base64');
}


const decrypt = (encdata, masterkey) =&gt; {
    const bData = Buffer.from(encdata, 'base64');

    const iv = bData.slice(0, 12);
    const tag = bData.slice(bData.length - 16, bData.length);
    const text = bData.slice(12, bData.length - 16);

    const key = generateKey(masterkey);

    const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv);
    decipher.setAuthTag(tag);


    const decrypted =
      decipher.update(text, 'binary', 'utf8') + decipher.final('utf8');


    return decrypted;
  };

const encryptedData = encrypt('hello world'); 
console.log('encrypt data -&gt; ', encryptedData);

const decryptedData = decrypt(encryptedData); 
console.log('decryptedData -&gt; ', decryptedData);

</code></pre>
"	NULL	NULL	NULL	02:11.6	NULL	NULL	NULL	NULL	NULL	17166044	0	1	0	<javascript><java><encryption><cryptography><aes-gcm>	AES/GCM/NoPadding encryption in JAVA & decryption in JavaScript	587	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74921221	0	NULL	"<p>I have been trying to send data effectively between two applications. One is implemented in C# (Sender) the other in Java (Receiver). The sender has to encrypt data using the transformation &quot;AES/GCM/NOPadding&quot; with a 32-byte key while the receiver has to decrypt using the same parameters. Here is the sender encryption function in C# (using bouncy castle)</p>
<pre><code>public static string Encrypt(string plainText, string msgId)
        {
            const byte GcmTagSize = 16;

            byte[] hashKey;
            byte[] secretKey = Encoding.UTF8.GetBytes(msgId);

            Console.WriteLine(secretKey.Length);

            using (var hasher = SHA512.Create())
            {
                byte[] digestSeed = hasher.ComputeHash(secretKey);
                hashKey = new byte[16];
                Array.Copy(digestSeed, hashKey, hashKey.Length);
            }

            var keyParameter = new KeyParameter(hashKey);
            var keyParameters = new AeadParameters(keyParameter, GcmTagSize * 8, secretKey);

            var cipher = CipherUtilities.GetCipher(&quot;AES/GCM/NoPadding&quot;);
            cipher.Init(true, keyParameters);

            var plainTextData = Encoding.ASCII.GetBytes(plainText);
            var cipherText = cipher.DoFinal(plainTextData); //bouncy castle 

            return Convert.ToBase64String(cipherText);
        }
</code></pre>
<p>Here is the receiver decryption function in java</p>
<pre><code>private static byte[] decrypt(byte[] message, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException,
            IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, InvalidKeyException {

        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NOPadding&quot;); //NoPadding


        byte[] nonce = Arrays.copyOfRange(message, message.length - cipher.getBlockSize(), message.length);
        byte[] encryptedKycData = Arrays.copyOf(message, message.length - cipher.getBlockSize());


        System.out.println(doEncode(nonce));


        System.out.println(doEncode(nonce));
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, nonce);
        cipher.init(Cipher.DECRYPT_MODE, key, gcmParameterSpec);

        byte[] decryptedValue=cipher.doFinal(encryptedKycData);

        return decryptedValue;

    }
</code></pre>
<p>When I try to decrypt with the java decryption function I get the error</p>
<pre><code>javax.crypto.AEADBadTagException: Tag mismatch
</code></pre>
<p>Struggling with this issue and any help would be appreciated.</p>
"	NULL	NULL	NULL	24:02.5	NULL	NULL	NULL	NULL	NULL	6518059	0	1	0	<java><c#><cryptography><bouncycastle><aes-gcm>	"AES/GCM Encryption on C# and decryption on Java fails with error ""Tag Mismatch"""	130	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
74960474	0	NULL	"<p>Below Code used for encryption in java side and encrypted data is shared to ui where we need to decrypt. Front end and backend using same key and iv .</p>
<pre><code>    public static Optional&lt;String&gt; encrypt(String strToEncrypt) {
            try {
                Field field = Class.forName(&quot;javax.crypto.JceSecurity&quot;).getDeclaredField(&quot;isRestricted&quot;);
                field.setAccessible(true);
                Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);
                modifiersField.setAccessible(true);
                modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);
                field.set(null, false);
    
                byte[] keyHex = Hex.decodeHex(secretKey.toCharArray());
                byte[] decodeHex = Hex.decodeHex(ivKey.toCharArray());
                IvParameterSpec ivspec = new IvParameterSpec(decodeHex);
    
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyHex, AES_ENC);
    
                Cipher cipher = Cipher.getInstance(ALGORITHM);
                cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivspec);
                String encodedToString = Base64.getEncoder()
                        .encodeToString(cipher.doFinal(strToEncrypt.getBytes(StandardCharsets.UTF_8)));
                System.out.println(&quot;ENC:&gt;&quot;+Base64.getDecoder().decode(encodedToString));
                return Optional.ofNullable(encodedToString);
            } catch (Exception e) {
                //log.error(&quot;AesUtil : Error occurred while encrypting the data : &quot; + e);
            }
            return Optional.empty();
        }
    
        public static Optional&lt;String&gt; decrypt(String strToDecrypt) {
    
            try {
                Field field = Class.forName(&quot;javax.crypto.JceSecurity&quot;).getDeclaredField(&quot;isRestricted&quot;);
                field.setAccessible(true);
                Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);
                modifiersField.setAccessible(true);
                modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);
                field.set(null, false);
    
                byte[] keyHex = Hex.decodeHex(secretKey.toCharArray());
                byte[] decodeHex = Hex.decodeHex(ivKey.toCharArray());
                IvParameterSpec ivspec = new IvParameterSpec(decodeHex);
    
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyHex, AES_ENC);
    
                Cipher cipher = Cipher.getInstance(ALGORITHM);
                cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivspec);
                byte[] decode = Base64.getDecoder().decode(strToDecrypt);
                String finalRes = new String(cipher.doFinal(decode));
                System.out.println(finalRes);
                return Optional.ofNullable(finalRes);
            } catch (Exception e) {
                //log.error(&quot;AesUtil : Error occurred while decrypting the data : &quot; + e);
            }
            return Optional.empty();
        }
</code></pre>
<p>`Below code i tried to decrypt but its printing empty in console log also tried to decode the data  in js and tried to decrypt, but still getting same empty output.</p>
<pre><code>const decrypt = ()=&gt;{

    var decode  = atob(encrypted);
var decrypted = CryptoJS.AES.decrypt({
    ciphertext: encrypted //decode
 },key, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
    console.log(decrypted.toString()); 
    console.log(decrypted.toString(CryptoJS.enc.Utf8));
    
}
</code></pre>
"	NULL	NULL	NULL	26:30.3	NULL	NULL	NULL	NULL	NULL	4994052	0	1	0	<javascript><java><encryption><aes><cryptojs>	"I encrypted the data in java using AES and trying the same to decrypt form javascript, but i am getting empty string as output in . Any suggestions"	50	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75095685	0	NULL	"<p>In my code I am using hardcoded arrays(given below) for IV and key</p>
<pre><code>**private static byte[] IVAes = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };

private static byte[] keyAes = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };

public static String encryptAes(String strPlain) {
        byte[] encrypted = null;
        if (StringUtils.isBlank(strPlain)) {
            return strPlain;
        }
        byte[] toEncrypt = strPlain.getBytes();
        try {
            AlgorithmParameterSpec paramSpec = new IvParameterSpec(IVAes);
            // Generate the key specs.
            SecretKeySpec skeySpec = new SecretKeySpec(keyAes, AES_ALGORITHM);
            // Instantiate the cipher
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, paramSpec);
            encrypted = cipher.doFinal(toEncrypt);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
                | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {
            LOGGER.error(e.getMessage(), e);
        }
        return new String(Base64.encodeBase64(encrypted));
    }**
</code></pre>
<p>but using hardcoded array as IV and Key is not prefered due to security perspective. Instead of this type of Hardcoded array can I use SecureRandom() as given below-</p>
<pre><code>**public static String encryptAes(String strPlain) {
        byte[] encrypted = null;
        if (StringUtils.isBlank(strPlain)) {
            return strPlain;
        }
        byte[] toEncrypt = strPlain.getBytes();
        try {
//---------calling generateIV method

            AlgorithmParameterSpec paramSpec = generateIv();
                // Instantiate the cipher
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, paramSpec);
            encrypted = cipher.doFinal(toEncrypt);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
                | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException e) {
            LOGGER.error(e.getMessage(), e);
        }
        return new String(Base64.encodeBase64(encrypted));
    }

public static IvParameterSpec generateIv() {
    byte[] IVAes = new byte[16];
    new SecureRandom().nextBytes(IVAes);
    return new IvParameterSpec(IVAes);
}

int n = 128;
public static SecretKey generateKey(int n) throws NoSuchAlgorithmException {
    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
    keyGenerator.init(n);
    SecretKey key = keyGenerator.generateKey();
    return key;
}**
</code></pre>
<p>I just wanted to know that creating array of 16 bytes for IV and key by using SecureRandom and also key generator will give same result as it was giving when I use hardcoded array as shown above??</p>
"	NULL	NULL	NULL	30:29.2	NULL	NULL	NULL	NULL	NULL	15212005	0	1	0	<java><encryption><aes><rc4-cipher><secure-random>	How to use SecureRandom instead of using hardcoded bytes array for Java AES Encrytion and Decryption?	38	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75176542	0	NULL	"<p>I have this code in java</p>
<pre><code>String data = &quot;private-key&quot;;
System.out.println(&quot;data: &quot; + data);

//create Cipher
Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);

//generate key
KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
keyGenerator.init(256);
SecretKey skey = keyGenerator.generateKey();
System.out.println(&quot;skey: &quot; + new String(Base64.getEncoder().encode(skey.getEncoded())));

//generate iv
byte[] biv = new byte[12];
SecureRandom random = new SecureRandom();
random.nextBytes(biv);
System.out.println(&quot;biv: &quot; + new String(Base64.getEncoder().encode(biv)));

//init
GCMParameterSpec spec = new GCMParameterSpec(128, biv);
cipher.init(Cipher.ENCRYPT_MODE, skey, spec);

//encrypt
byte[] encryption = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
byte[] be = Base64.getEncoder().encode(encryption);
System.out.println(&quot;encryption: &quot; + new String(be, StandardCharsets.UTF_8));

//decrypt
cipher.init(Cipher.DECRYPT_MODE, skey, spec);
byte[] decryption = cipher.doFinal(encryption);
System.out.println(&quot;origin: &quot; + new String(decryption, StandardCharsets.UTF_8));
</code></pre>
<p>And I want to translate this code in PHP(I want to share infos between java app and php app).</p>
<p>In PHP I managed this:</p>
<pre><code>$data = &quot;private-key&quot;;

$skey = random_bytes(32);
$biv = random_bytes(12);

//encrypt
$encryption = openssl_encrypt($data, 'aes-128-gcm', $skey, OPENSSL_NO_PADDING, $biv);
echo &quot;encryption: &quot; . base64_encode($encryption) . &quot;&lt;br&gt;&quot;;

//decrypt
$origin = openssl_decrypt($encryption, &quot;aes-128-gcm&quot;, $skey, OPENSSL_NO_PADDING, $biv);
echo &quot;origin: &quot; . $origin;
</code></pre>
<p>But I get error in PHP at <code>openssl_encrypt</code>:
<code>Warning: openssl_encrypt(): A tag should be provided when using AEAD mode</code> and I have no idea how to fix it.</p>
"	NULL	NULL	NULL	07:30.3	NULL	NULL	NULL	NULL	NULL	9011164	0	1	0	<java><php><aes>	Encrypt/Decrypt AES/GCM/NoPadding from JAVA to PHP(A tag should be provided)	56	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75180048	0	NULL	"<p>I got an warning from google to Change encryption mode from &quot;AES/ECB/PKCS5Padding&quot; to &quot;AES/GCM/NoPadding&quot;.
After changing I need to be compatible with the old data which is encrypted with &quot;AES/ECB/PKCS5Padding&quot;.
Can you please help with a goof solution to do this.
Right now I am using simple try catch.</p>
<pre><code>    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
     cipher.init(Cipher.DECRYPT_MODE, secretKey);
    byte[] decrypted = cipher.doFinal(encryptedString);
</code></pre>
"	NULL	NULL	NULL	20:45.2	NULL	NULL	NULL	NULL	NULL	5005553	0	1	0	<android><encryption><google-play-console><caesar-cipher><android-security>	AES/ECB/PKCS5Padding Unsafe Encryption Mode error	84	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75266913	0	NULL	"<p>i used the aes library in android studio to encrypt a string of data to send to an esp8266 in AP mode. i am able to get the encrypted value but not the correct decrypted value. i am still particularly new to this and the decryption code was obtained through chatgpt.</p>
<p>this is the code i used to send an encrypted 16 byte value</p>
<pre><code>new Thread(new Runnable() {
                        @Override
                        public void run() {
                            byte[] key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
                            String data = &quot;thats my kung fu&quot;;
                            try {
                                SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);
                                Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
                                cipher.init(Cipher.ENCRYPT_MODE, secretKey);
                                byte[] encryptedData = cipher.doFinal(data.getBytes());

                                Log.d(&quot;EncryptedData&quot;, Base64.encodeToString(encryptedData, Base64.DEFAULT));

                                OkHttpClient client = new OkHttpClient.Builder()
                                        .callTimeout(40, TimeUnit.SECONDS)
                                        .build();
                                RequestBody formBody = new FormBody.Builder()
                                        .add(&quot;data&quot;, Base64.encodeToString(encryptedData, Base64.DEFAULT))
                                        .build();
                                Request request = new Request.Builder()
                                    .url(&quot;http://192.168.4.1/post&quot;)
                                    .post(formBody)
                                    .build();
                            client.newCall(request).enqueue(new Callback() {
                                @Override
                                public void onResponse(okhttp3.Call call, Response response) throws IOException {
                                    if (response.isSuccessful()) {
                                        String myResponse = response.body().string();
                                        Log.i(&quot;POST&quot;, myResponse);
                                        Log.d(&quot;TAG&quot;, &quot;data: &quot; + data);
                                    } else {
                                        Log.d(&quot;POST&quot;, &quot;response code: &quot; + response.code() + &quot; response message: &quot; + response.message());
                                    }
                                }

                                @Override
                                public void onFailure(okhttp3.Call call, IOException e) {
                                    e.printStackTrace();
                                    Log.e(&quot;TAG&quot;, &quot;Post request failed&quot;);
                                }
                            });
                            } catch (NoSuchAlgorithmException | NoSuchPaddingException |
                                     InvalidKeyException |
                                     IllegalBlockSizeException |
                                     BadPaddingException e) {
                                e.printStackTrace();
                            }
                        }
                    }).start();
</code></pre>
<p>i am able to receive the encrypted value on the esp, which is hYRPznVRiPVGVV0NkOy4XpVPZPLk6G6e7oLSAhZoSJk=</p>
<p>this is the arduino code to decrypt the value:</p>
<pre><code>#include &lt;AES.h&gt;
#include &lt;AESLib.h&gt;
#include &lt;AES_config.h&gt;
#include &lt;xbase64.h&gt;

#include &lt;ESP8266WebServer.h&gt;

ESP8266WebServer server(80);
AES aes;

const char* ssid = &quot;ESP8266-AP&quot;;
const char* password = &quot;password&quot;;

const byte key[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };

void handlePost() {
  String val = server.arg(&quot;data&quot;);
  byte decrypted[val.length()];
  aes.set_key(key, sizeof(key));
  aes.decrypt((byte*)val.c_str(), decrypted); 
  String decryptedVal = String((char*)decrypted);
  Serial.println(&quot;Received value: &quot; + decryptedVal);
  Serial.println(&quot;Encrypted value: &quot; + val);
  server.send(200, &quot;text/plain&quot;, &quot;Value Received&quot;);
}


void setup() {
  //Set ESP as AP
  Serial.begin(9600);
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, password);

  //Initialize server
  server.begin();
  server.on(&quot;/post&quot;, HTTP_POST, handlePost);
  Serial.println(&quot;Server started&quot;);
}

void loop() {
  server.handleClient();
}

</code></pre>
<p>this is my output:</p>
<p>Server started
Received value: *qz????5??2?k?D{<code>????3???????j @</code>???
Encrypted value: hYRPznVRiPVGVV0NkOy4XpVPZPLk6G6e7oLSAhZoSJk=</p>
<p>*received value is the supposedly decrypted value.</p>
"	NULL	NULL	NULL	22:50.3	NULL	NULL	NULL	NULL	NULL	21054032	0	1	0	<android><aes><arduino-esp8266>	Android to esp8266 decryption	38	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75292189	0	NULL	"<p>Because of cipher CBC is vulnerability, the solution is to change using cipher GCM, but the problem there is old result of cipher CBC encryption exist. So the question is how to decrypt the result of cipher CBC encryption using cipher GCM?</p>
<p>Cipher CBC encryption:</p>
<pre><code>private static final String AES_ALGORITHM = &quot;AES&quot;;
private static final Integer BLOCK_SIZE = 16;
private static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;

public String generateMerchantToken(String internalToken, String merchantSecretKey) throws Exception{
    SecretKeySpec secretKeySpec = new SecretKeySpec(merchantSecretKey.getBytes(), AES_ALGORITHM);
    byte[] iv = new byte[BLOCK_SIZE];
    secureRandom.nextBytes(iv);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);

    byte[] cipherEncodedBytes = cipher.doFinal(internalToken.getBytes());
    byte[] combinedBytes = ArrayUtils.addAll(iv, cipherEncodedBytes);
    byte[] encodedBytes = Base64.encodeBase64(combinedBytes);

    return new String(encodedBytes);
}
</code></pre>
<p>Here is GCM decrypt but found error &quot;javax.crypto.AEADBadTagException: Tag mismatch!&quot;</p>
<pre><code>private static final String AES_ALGORITHM = &quot;AES&quot;;
private static final Integer BLOCK_SIZE = 16;
private static final Integer GCM_TAG_SIZE = 16 * Byte.SIZE;
private static final String CIPHER_ALGORITHM = &quot;AES/GCM/NoPadding&quot;;

public String decryptMerchantToken(String token, String merchantSecretKey) throws Exception {
    byte[] decodeBase64 = Base64.decodeBase64(token);
    byte[] ivString = Arrays.copyOfRange(decodeBase64,0, BLOCK_SIZE);
    SecretKeySpec secretKeySpec = new SecretKeySpec(merchantSecretKey.getBytes(), AES_ALGORITHM);
    GCMParameterSpec iv = new GCMParameterSpec(GCM_TAG_SIZE ,ivString);

    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv);
    byte[] original = cipher.doFinal(Arrays.copyOfRange(decodeBase64, BLOCK_SIZE, decodeBase64.length));
    String decryptedString = new String(original);

    return decryptedString;
}
</code></pre>
<p>The expectation is success to decrypt cipher CBC encryption result using cipher GCM</p>
"	NULL	NULL	NULL	36:52.6	NULL	NULL	NULL	NULL	NULL	19637759	0	1	0	<encryption>	How to decrypt result of cipher CBC encryption using cipher GCM?	47	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75304371	0	NULL	"<p>I am experiencing an issue when decrypting a string using sunjce :</p>
<pre><code>javax.crypto.Cipher cipher =
      javax.crypto.Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;, new BouncyCastleProvider());
  GCMParameterSpec spec = new GCMParameterSpec(Constants.GCM_TAG_BYTES * 8, nonce);
  cipher.init(javax.crypto.Cipher.DECRYPT_MODE, dataKey, spec);

  cipher.update(ciphertext);
  
  return cipher.doFinal();
</code></pre>
<p>if I pass the whole ciphertext to doFinal it works correctly but if I call it correctly it only returns partial string. FOr instance for the input</p>
<pre><code>String jsonExample = &quot;{\&quot;dataType\&quot;:\&quot;STRING\&quot;,\&quot;strValue\&quot;:\&quot;000000\&quot;}&quot;;
</code></pre>
<p>The decrypted bytes only contain &quot;000000&quot; but if I use</p>
<pre><code>return cipher.doFinal(ciphertext); 
</code></pre>
<p>and remove the update so it correctly prints the original string. What might be the reason? if I pass an empty byte array to doFinal after the update it also results in the same data loss. I want to know the logic behind it, it passes for small texts but for texts of this size it simply does not work.</p>
<p>this is my input</p>
<pre><code>String jsonExample = &quot;{\&quot;dataType\&quot;:\&quot;STRING\&quot;,\&quot;strValue\&quot;:\&quot;000000\&quot;}&quot;;
</code></pre>
<p>This is how I am printing the decrypted string</p>
<pre><code>String decryptedString = new String(decrypted, StandardCharsets.UTF_8);
</code></pre>
<p>This is how I am passing the input string as bytes to the encrypt function</p>
<pre><code>text = jsonExample.getBytes(StandardCharsets.UTF_8)
</code></pre>
<p>this is how I am calling encrypt</p>
<pre><code>GCMParameterSpec spec = new GCMParameterSpec(Constants.GCM_TAG_BYTES * 8, nonce);
try {
  cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, dek, spec);
  byte[] ciphertext = cipher.doFinal(text);
</code></pre>
<p>When I use <code>cipher.update(ciphertext)</code> during decryption followed by <code>cipher.doFinal()</code> or <code>cipher.doFInal(new byte[0])</code> it only returns</p>
<p><code>&quot;000000&quot;</code> after  I use the returned <code>byte[]</code> to <code>String decryptedString = new String(decrypted, StandardCharsets.UTF_8);</code></p>
<p>But if I directly call <code>cipher.doFInal(cipherText)</code> during decryption the result string I get is the original string.</p>
"	NULL	NULL	NULL	02:44.6	NULL	NULL	NULL	NULL	NULL	1164435	0	1	0	<java><encryption><aes><aes-gcm><block-cipher>	Cipher.doFinal() returning part of decrypted string for a long string	78	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75337378	75337694	NULL	"<p>I don't understand how to do this in Java:</p>
<pre><code>$text = &quot;YOU IN&quot;;
// get the password key via: `base64_encode(openssl_random_pseudo_bytes(32)) = gGwdF6FDd68C/ANEqlqgOrsLqqC11u2JYn7NEJP10DA` = and further:
$keyPass = base64_decode(&quot;gGwdF6FDd68C/ANEqlqgOrsLqqC11u2JYn7NEJP10DA=&quot;);
$rndBytes = openssl_random_pseudo_bytes(openssl_cipher_iv_length('aes-256-cbc')); // 0PLpHMRYGwDBgcBsbeI3Qw==
$encText = openssl_encrypt($text, 'aes-256-cbc', $keyPass, 0, $rndBytes); // n+hHeLU4eI9r23ckxOwBOA==
</code></pre>
<p>So that you can also return this text without any problems:</p>
<pre><code>echo openssl_decrypt(
    base64_decode(&quot;n+hHeLU4eI9r23ckxOwBOA==&quot;),
    'aes-256-cbc',
    base64_decode(&quot;gGwdF6FDd68C/ANEqlqgOrsLqqC11u2JYn7NEJP10DA=&quot;),
    OPENSSL_RAW_DATA,
    base64_decode(&quot;0PLpHMRYGwDBgcBsbeI3Qw==&quot;)
); // YOU IN
</code></pre>
<p>How can I do this in Java?</p>
<p>The task in Java is to return, not to encrypt.<br />
That is, the resulting <code>$encText</code> will always be different, while any one will fit <code>openssl_decrypt</code>.</p>
<p>Tried to do like this:</p>
<pre><code>final Decoder decoder = Base64.getDecoder();
final byte[] encBytes = decoder.decode(&quot;n+hHeLU4eI9r23ckxOwBOA==&quot;),
             keyPass = decoder.decode(&quot;gGwdF6FDd68C/ANEqlqgOrsLqqC11u2JYn7NEJP10DA=&quot;),
             rndBytes = decoder.decode(&quot;0PLpHMRYGwDBgcBsbeI3Qw==&quot;);
final String algo = &quot;AES&quot;;
final SecretKeySpec secretKey = new SecretKeySpec(keyPass, algo);
final Cipher cipher = Cipher.getInstance(algo);
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
final byte[] decBytes = cipher.doFinal(encBytes);
System.out.println(new String(decBytes));
//
// Return hieroglyphs:
//
// ??*?#???\??i?9???:?_?`?-U??
</code></pre>
<p>I don't know how to find this <code>aes-256-cbc</code>...
If you try to change the line:</p>
<pre><code>cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(rndBytes));
</code></pre>
<p>Crashes with an error:<br />
<code>InvalidAlgorithmParameterException: ECB mode cannot use IV</code></p>
"	NULL	NULL	NULL	51:29.4	NULL	NULL	NULL	NULL	NULL	20025013	0	1	-1	<java><php><aes>	How to write an analogue of returning text	54	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75347305	0	NULL	"<p>As part of a project, I am supposed to demonstrate 128-bit AES encryption in Arduino. Unfortunately, there is not much information on how to implement this in Arduino compared to for example, Android, which gives me my desired encrypted output.</p>
<p>Here is the sample code (<a href=""https://gist.github.com/EC12-Code/73b19a98c759c777e303a75e94d6ed21"" rel=""nofollow noreferrer"">https://gist.github.com/EC12-Code/73b19a98c759c777e303a75e94d6ed21</a>) which I have referred to to implement AES, unfortunately when I compare the encrypted output to online tools, the encrypted output for Arduino is different but for Android it is the same. Somehow, the Arduino code still manages to give the desired decrypted output however, which confuses me. Is it a format issue? I am a newbie at this and I have no idea what is causing this difference, shouldn't the same key and IV used give the same encrypted output anyways?</p>
<p>Code on Arduino's side (with ref to the link above):</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;hwcrypto/aes.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;base64.h&gt;

static inline int32_t _getCycleCount(void) {
  int32_t ccount;
  __asm__ __volatile__(&quot;rsr %0,ccount&quot;:&quot;=a&quot; (ccount));
  return ccount;
}

char plaintext[16384];
char encrypted[16384];

int encodetest()
{
//uint8_t key[32];
//uint8_t iv[16];
unsigned char iv[16] = {0x57, 0x6E, 0x5A, 0x72, 0x34, 0x75, 0x37, 0x78, 0x21, 0x7A, 0x25, 0x43, 0x2A, 0x46, 0x2D, 0x4A};
unsigned char key[32] ={0x66 ,0x54 ,0x6A ,0x57 ,0x6E ,0x5A ,0x72 ,0x34 ,0x75 ,0x37 ,0x78 ,0x21 ,0x41 ,0x25 ,0x44 ,0x2A ,0x47 ,0x2D ,0x4A ,0x61 ,0x4E ,0x64 ,0x52 ,0x67 ,0x55 ,0x6B ,0x58 ,0x70 ,0x32 ,0x73 ,0x35 ,0x76};

  strcpy( plaintext, &quot;Hello&quot; );
  Serial.printf( &quot;\n================================Encode================================\nIV HEX:&quot; );

  for(int d = 0; d &lt; sizeof(iv); d++) {
  Serial.printf( &quot;%02x&quot;, iv[d] );
  }
  Serial.printf( &quot;\nKey HEX:&quot; );
  for(int f = 0; f &lt; sizeof(key); f++) {
  Serial.printf( &quot;%02x&quot;, key[f] );
  }
  
  Serial.printf(&quot;\nWill Encode \n%s&quot;,plaintext);
  //Just FYI - you must be encrypting/decrypting data that is in BLOCKSIZE chunks!!!

  esp_aes_context ctx;
  esp_aes_init( &amp;ctx );
  esp_aes_setkey( &amp;ctx, key, 256 );
  int32_t start = _getCycleCount();
  esp_aes_crypt_cbc( &amp;ctx, ESP_AES_ENCRYPT, sizeof(plaintext), iv, (uint8_t*)plaintext, (uint8_t*)encrypted );
  int32_t end = _getCycleCount();
  float enctime = (end-start)/240.0;
  Serial.printf( &quot;Encryption time: %.2fus  (%f MB/s)\n&quot;, enctime, (sizeof(plaintext)*1.0)/enctime );

  //See encrypted payload, and wipe out plaintext.
  memset( plaintext, 0, sizeof( plaintext ) );
  int i;
   Serial.printf( &quot;Hex&quot; );
  for( i = 0; i &lt; 128; i++ )
  {    
  if  (i % 8 == 0) {Serial.printf( &quot; &quot; );};
    Serial.printf( &quot;%02x&quot;, encrypted[i] );
  }
  Serial.printf( &quot;\n================================Decode================================ \n&quot; );
  //Must reset IV. Otherwise first block will fail
unsigned char iva[16] = {0x57, 0x6E, 0x5A, 0x72, 0x34, 0x75, 0x37, 0x78, 0x21, 0x7A, 0x25, 0x43, 0x2A, 0x46, 0x2D, 0x4A};

for(int c = 0; c &lt; sizeof(iva); c++) {
 Serial.printf( &quot;%02x &quot;, iva[c] );
}

memset( iv, 0, sizeof( iv ) );  

  //Use the ESP32 to decrypt the CBC block.
  esp_aes_crypt_cbc( &amp;ctx, ESP_AES_DECRYPT, sizeof(encrypted), iva, (uint8_t*)encrypted, (uint8_t*)plaintext );

 Serial.printf( &quot;\nHuman Readable\n&quot; );
 
  //Verify output
  for( i = 0; i &lt; sizeof( plaintext ); i++ )
  {
   // printf( &quot;%c&quot;,  (plaintext[i]&gt;31)?plaintext[i]:' ' );  
   Serial.printf( &quot;%c&quot;, plaintext[i]);
  }
  Serial.printf( &quot;\n&quot; );

  esp_aes_free( &amp;ctx );
}

void setup() {
  // put your setup code here, to run once:
   Serial.begin(115200);
   Serial.println(&quot;Execute Begin&quot;);

int a = encodetest();
}
</code></pre>
<p>Code on Android's side:</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    EditText inputText, inputPassword;
    TextView outputText;
    Button encBtn, decBtn;
    String outputString;
    String AES = &quot;AES&quot;;
    private static final String SECRET_KEY = &quot;fTjWnZr4u7x!A%D*G-JaNdRgUkXp2s5v&quot;;
    private static final String SALT = &quot;ssshhhhhhhhhhh!!!!&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        inputText = findViewById(R.id.inputText);
        inputPassword = findViewById(R.id.password);

        outputText =findViewById(R.id.outputText);
        encBtn = findViewById(R.id.encBtn);
        decBtn = findViewById(R.id.decBtn);

        encBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    outputString = encrypt(inputText.getText().toString());
                    outputText.setText(outputString);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public static String encrypt(String strToEncrypt) {
        try {
            byte[] iv = {0x57, 0x6E, 0x5A, 0x72, 0x34, 0x75, 0x37, 0x78, 0x21, 0x7A, 0x25, 0x43, 0x2A, 0x46, 0x2D, 0x4A};
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            //KeySpec spec = new PBEKeySpec(SECRET_KEY.toCharArray(), SALT.getBytes(), 65536, 256);
            //SecretKey tmp = factory.generateSecret(spec);
            //SecretKeySpec secretKey = new SecretKeySpec(tmp.getEncoded(), &quot;AES&quot;);
            byte[] key = SECRET_KEY.getBytes(&quot;UTF-8&quot;);
            SecretKeySpec secretKey = new SecretKeySpec(key, &quot;AES&quot;);

            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivspec);
            byte[] encVal = cipher.doFinal(strToEncrypt.getBytes());
            String encryptedValue = Base64.encodeToString(encVal, Base64.DEFAULT);
            return encryptedValue;
        } catch (Exception e) {
            System.out.println(&quot;Error while encrypting: &quot; + e.toString());
        }
        return null;
    }

}
</code></pre>
<p>Plaintext: Hello</p>
<p>Encrypted output from Arduino:</p>
<p>7c6e13cc7e943313 ee111a1c90387c04 ac1fa7a7c491d53e be6eea1feaf01815 d7733389f23dd8f4 ed6dae3e78f5388e 1eda7bbbaf3bad5f 1b5b0d01281805d4 2c38139fcda0a05b 7eded259247e105b 16b228aacefc89ee 9dd2db2392537168 63adf145feb2b33a 287c5a5623212a0d c8760ed78ffc6508 a1e95d6235895ef5</p>
<p>Encrypted output from Android, which is the same as the one generated from online tools:</p>
<p><a href=""https://i.stack.imgur.com/btoGb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/btoGb.png"" alt=""Android encrypted output"" /></a></p>
<p><a href=""https://i.stack.imgur.com/yAnnL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yAnnL.png"" alt=""enter image description here"" /></a></p>
<p>Any help would be much appreciated in helping me understanding why the Arduino output is different, thanks!</p>
"	NULL	NULL	NULL	17:03.0	NULL	NULL	NULL	NULL	NULL	18576251	0	1	0	<android><encryption><arduino><aes>	Why is my AES encryption (CBC) giving me the wrong encrypted output in Arduino?	51	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75363459	0	NULL	"<p>I am creating a program that encrypts data. De and encryption works perfectly fine. But when decrypting an image I get an error. I am very greatful for any help!</p>
<p>When trying to decrypt my image using the cat_encrypt method like this:</p>
<pre class=""lang-java prettyprint-override""><code> String encrypted = encrypt.cat_encrypt(getFileContent(jf.getSelectedFile()), pass);
 Files.writeString(Path.of(jf.getSelectedFile().getPath()), encrypted);
</code></pre>
<p>I get the following error:</p>
<pre class=""lang-java prettyprint-override""><code>java.lang.IllegalArgumentException: Input byte array has incorrect ending byte at 54808
</code></pre>
<p>Here is my encryption method:</p>
<pre class=""lang-java prettyprint-override""><code>public static String cat_encrypt(String text, String pass) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);
            Key key = new SecretKeySpec(messageDigest.digest(pass.getBytes(UTF_8)), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
            cipher.init(ENCRYPT_MODE, key);

            byte[] encrypted = cipher.doFinal(text.getBytes(UTF_8));
            byte[] encoded = Base64.getEncoder().encode(encrypted);
            return new String(encoded, UTF_8);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |
                 BadPaddingException e) {
            throw new RuntimeException(&quot;Cannot encrypt&quot;, e);
        }
    }
</code></pre>
<p>And this is my decryption method:</p>
<pre class=""lang-java prettyprint-override""><code>public static String cat_decrypt(String text, String pass)  {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);
            Key key = new SecretKeySpec(messageDigest.digest(pass.getBytes(UTF_8)), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
            cipher.init(DECRYPT_MODE, key);

            byte[] decoded = Base64.getDecoder().decode(text.getBytes(UTF_8));
            byte[] decrypted = cipher.doFinal(decoded);
            return new String(decrypted, UTF_8);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException |
                 BadPaddingException e) {

            try {
                sendError((e.getClass().getSimpleName()));
            }catch (Exception sE){e.printStackTrace();}

            throw new RuntimeException(&quot;Cannot decrypt&quot;, e);
        }
    }
</code></pre>
<p>I call the decrypt method like this:</p>
<pre><code>String decrypted = encrypt.cat_decrypt(getFileContent(jf.getSelectedFile()), pass);
</code></pre>
<p>The full error code:</p>
<pre><code>Exception in thread &quot;AWT-EventQueue-0&quot; java.lang.IllegalArgumentException: Input byte array has incorrect ending byte at 54808
    at java.base/java.util.Base64$Decoder.decode0(Base64.java:876)
    at java.base/java.util.Base64$Decoder.decode(Base64.java:566)
</code></pre>
"	NULL	NULL	NULL	39:58.6	NULL	NULL	NULL	NULL	NULL	18476481	0	1	0	<java><image><encryption><base64><aes>	Image encryption throws IllegalArgumentException	35	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75369912	0	NULL	"<p>I need to convert java code for encryption and decryption using AES/CBC/PKCS5Padding algorithm to dart code.</p>
<p>The java code of AES/CBC/PKCS5Padding encryption and decryption:</p>
<pre><code>package test_Terminal.classes;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 *
 * @author jeena
 */
public class IOTEncodingDecoding {

    SecretKeySpec secretKeySpec;
    IvParameterSpec ivSpec;
    String EncryptionKey = &quot;733D3A17-D8A0-454B-AD22-88608FD0C46A&quot;;
    String saltString = &quot;FA9A4D0F-5523-4EEF-B226-9A3E8F14FEF8&quot;;
    String algorithm = &quot;AES/CBC/PKCS5Padding&quot;;
    int encoding_mode;

    test_Terminal.classes.general General = new test_Terminal.classes.general();

    void setSecretKey() {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
            PBEKeySpec pbeKeySpec = new PBEKeySpec(EncryptionKey.toCharArray(), saltString.getBytes(StandardCharsets.UTF_16LE), 1000, 384);
            byte[] derivedData = factory.generateSecret(pbeKeySpec).getEncoded();

            byte[] key = new byte[32];
            byte[] iv = new byte[16];

            System.arraycopy(derivedData, 0, key, 0, key.length);
            System.arraycopy(derivedData, key.length, iv, 0, iv.length);

            secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);
            ivSpec = new IvParameterSpec(iv);
        } catch (Exception e) {
            General.LogException(&quot;setSecretKey&quot;, e);
        }
    }

    public String encrypt(String input) {
        try {
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] cipherText ;
            if(encoding_mode==1)            
                cipherText = cipher.doFinal(input.getBytes(StandardCharsets.UTF_16LE));
            else
                cipherText = cipher.doFinal(input.getBytes());                            
            return Base64.getEncoder().encodeToString(cipherText);
        } catch (Exception e) {
            General.LogException(&quot;encrypt&quot;, e);
        }
        return &quot;&quot;;
    }

    public String decrypt(String cipherText) {
        try {
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] plainText = cipher.doFinal(Base64.getDecoder().decode(cipherText));
            if(encoding_mode==1)
                return new String(plainText, StandardCharsets.UTF_16LE);
            else
                return new String(plainText);
            
                
        } catch (Exception e) {
            General.LogException(&quot;decrypt&quot;, e);
            General.LogActivity(&quot;decrypt&quot;, e.getMessage());
        }
        return &quot;Ticket format error&quot;;
    }

    public void setMode() {              
        setSecretKey();                         
    }

}

</code></pre>
<p>I need to get the following result:</p>
<p>Input(PlainText):C123492349C1CT20230206130645.
Output(Encrypted string):8tyHRaQCsxmmGW2xPBFYx/PALmvHkmjx/TzaXC2rIv0=</p>
<p>This is the dart code that I've got so far for decryption, but I'm getting error.</p>
<pre><code> Uint8List? decrypt(String ciphertext, String password) {
    Uint8List rawCipher = base64.decode(ciphertext);
    var salt = rawCipher.sublist(0, 0 + 8);
    var iv = rawCipher.sublist(8, 8 + 16);
    var encrypted = rawCipher.sublist(8 + 16);

    Uint8List key = generateKey(password, salt);
    print('key =&gt; $key');
    CBCBlockCipher cipher = CBCBlockCipher(AESEngine());

    ParametersWithIV&lt;KeyParameter&gt; params =
        ParametersWithIV&lt;KeyParameter&gt;(KeyParameter(key), iv);
    PaddedBlockCipherParameters&lt;ParametersWithIV&lt;KeyParameter&gt;, Null&gt;
        paddingParams =
        PaddedBlockCipherParameters&lt;ParametersWithIV&lt;KeyParameter&gt;, Null&gt;(
            params, null);
    PaddedBlockCipherImpl paddingCipher =
        PaddedBlockCipherImpl(PKCS7Padding(), cipher);
    paddingCipher.init(false, paddingParams);

    var val = paddingCipher.process(encrypted);

    String res = String.fromCharCodes(val);

    debugPrint('res =&gt; $res');

    return val;
  }

 Uint8List generateKey(String passphrase, Uint8List salt) {
    final derivator = PBKDF2KeyDerivator(HMac(SHA1Digest(), 64))
      ..init(Pbkdf2Parameters(salt, 1024, 16));
    return derivator.process(utf8.encode(passphrase) as Uint8List);
  }

</code></pre>
<p><a href=""https://stackoverflow.com/questions/72945189/converting-aes-decryption-function-from-java-to-flutter"">I got this code from </a></p>
<p>The Exception that I'm getting is:</p>
<pre><code>Exception has occurred.
ArgumentError (Invalid argument(s): Input data length must be a multiple of cipher's block size)
</code></pre>
<p>I think the values inside rawCipher.sublist() function is wrong. I'm stuck on this problem for few days, please help.</p>
"	NULL	NULL	NULL	08:19.0	NULL	NULL	NULL	NULL	NULL	17228176	0	1	0	<java><flutter><aes>	Need to convert Java AES/CBC/PKCS5 Padding Encryption and decryption to dart code-Flutter	108	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75385441	0	NULL	"<p>I am trying to encrypt a string with a user defined password and then decode it with the string again.</p>
<p>My code:</p>
<p>SecurityManager.java</p>
<pre><code>package de.example.org;


import javax.crypto.*;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

public class SecurityManager {
    private static final String ALGORITHM = &quot;AES&quot;;
    private static final String TRANSFORMATION = &quot;AES/ECB/PKCS5Padding&quot;;

    private static final SecureRandom secureRandom = new SecureRandom();
    private static final Base64.Encoder base64Encoder = Base64.getUrlEncoder();
    private static final SecretKeyFactory factory;

    static {
        try {
            factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    private static PBEKeySpec generatePBEKeySpec(String password) {
        return new PBEKeySpec(password.toCharArray(), generateRandomString(16).getBytes(), 65536, 128);
    }


    public static String generateRandomString(int length) {
        byte[] randomBytes = new byte[length];
        secureRandom.nextBytes(randomBytes);
        return base64Encoder.encodeToString(randomBytes);
    }

    public static String generateEncryptedKey(String password) throws InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        SecretKey secretKey = factory.generateSecret(generatePBEKeySpec(password));
        byte[] encodedKey = secretKey.getEncoded();

        // Convert the secretKey to a SecretKeySpec
        Key secretKeySpec = new SecretKeySpec(encodedKey, ALGORITHM);

        // Encrypt the original string
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        String random = generateRandomString(128);
        System.out.println(random);
        byte[] encryptedBytes = cipher.doFinal(random.getBytes());

        return new String(encryptedBytes);
    }

    public static String decryptKey(String encryptedKey, String password) throws InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        SecretKey secretKey = factory.generateSecret(generatePBEKeySpec(password));
        byte[] encodedKey = secretKey.getEncoded();

        // Convert the secretKey to a SecretKeySpec
        Key secretKeySpec = new SecretKeySpec(encodedKey, ALGORITHM);

        // Decrypt the encrypted string
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        byte[] decryptedBytes = cipher.doFinal(encryptedKey.getBytes());

        return new String(decryptedBytes);
    }


}
</code></pre>
<p>Executing the function in main:</p>
<pre><code>String encrypted = SecurityManager.generateEncryptedKey(&quot;123&quot;);
String decrypted = SecurityManager.decryptKey(encrypted, &quot;123&quot;);
System.out.println(decrypted);
</code></pre>
<p>Error:</p>
<pre><code>Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
    at java.base/com.sun.crypto.provider.CipherCore.prepareInputBuffer(CipherCore.java:887)
    at java.base/com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:729)
    at java.base/com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:434)
    at java.base/javax.crypto.Cipher.doFinal(Cipher.java:2206)
    at de.example.org.SecurityManager.decryptKey(SecurityManager.java:66)
    at de.example.org.main.Main.main(Main.java:11)
</code></pre>
<p>I have been sitting on this for hours now, and with bytes I can encrypt it. But since I want to store the encrypted string, so it's still available after a restart, storing the bytes in a file would be less secure AFAIK.</p>
"	NULL	NULL	NULL	54:19.7	NULL	NULL	NULL	NULL	NULL	20377250	0	1	0	<java><security><encryption><cryptography>	Java read a encrypted string and decode it	64	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75386394	0	NULL	"<p>I am trying to decrypt encoded string in javascript using cryto.subtle. I have encoded this string in java using aes gcm. Please let me know the javascript code(using cryto.subtle) equivalent to below java code. Decryption works in java and just for learning I am using same string as key and initialization vector. Javascript code in giving error while decrypting. I am not using nodejs.</p>
<p><strong>JAVA code</strong></p>
<pre><code>package com.hm.fcs.controller;

import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class AesGcmExample
{
    static String plainText = &quot;pathname=editOffer&amp;offerId=8ab076727fdbba68017ff98c196b0000&amp;mode=sea&quot;;
    public static final int GCM_TAG_LENGTH = 16;

    // Password derived AES 256 bits secret key
    public static SecretKey getAESKeyFromPassword(char[] password, byte[] salt)
            throws NoSuchAlgorithmException, InvalidKeySpecException {

        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
        // iterationCount = 65536
        // keyLength = 256
        KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
        SecretKey secret = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
        return secret;

    }

    public static void main(String[] args) throws Exception
    {
        char[] secretKey = &quot;ZXE-ERW-QDD-EGXL&quot;.toCharArray();
        byte[] IV = &quot;ZXE-ERW-QDD-EGXL&quot;.getBytes();

//        SecureRandom random = new SecureRandom();
//        random.nextBytes(IV);
        System.out.println(&quot;original text : &quot;+plainText);
        SecretKey key = getAESKeyFromPassword(secretKey,IV);
        byte[] cipherText = encrypt(plainText.getBytes(), key, IV);
        System.out.println(&quot;Encrypted Text : &quot; + Base64.getEncoder().encodeToString(cipherText));

        String decryptedText = decrypt(cipherText, key, IV);
        System.out.println(&quot;DeCrypted Text : &quot; + decryptedText);
    }

    public static byte[] encrypt(byte[] plaintext, SecretKey key, byte[] IV) throws Exception
    {
        // Get Cipher Instance
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);

        // Create GCMParameterSpec
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, IV);

        // Initialize Cipher for ENCRYPT_MODE

        cipher.init(Cipher.ENCRYPT_MODE, key, gcmParameterSpec);

        // Perform Encryption
        byte[] cipherText = cipher.doFinal(plaintext);

        return cipherText;
    }

    public static String decrypt(byte[] cipherText, SecretKey key, byte[] IV) throws Exception
    {
        // Get Cipher Instance
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);

        // Create GCMParameterSpec
        GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, IV);

        // Initialize Cipher for DECRYPT_MODE
        cipher.init(Cipher.DECRYPT_MODE, key, gcmParameterSpec);

        // Perform Decryption
        byte[] decryptedText = cipher.doFinal(cipherText);

        return new String(decryptedText);
    }
}

</code></pre>
<p><strong>Java script code that I am trying</strong></p>
<pre><code>const pwUtf8 = new TextEncoder().encode(&quot;ZXE-ERW-QDD-EGXL&quot;);
        console.log(&quot;before pwHash&quot;);
        const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);
        console.log(&quot;after pwHash&quot;);
        const ivStr = &quot;ZXE-ERW-QDD-EGXL&quot;;
        // iv as Uint8Array
        const iv = new Uint8Array(Array.from(ivStr).map(ch =&gt; ch.charCodeAt(0)));

        const alg = { name: 'AES-GCM',
            iv: iv };
        // generate key from pw
        console.log(&quot;before key&quot;);
        const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']);
        console.log(&quot;after key&quot;);
        const ctStr = &quot;lZSyv0+aBh6x2rSdNwo683Oz0TtJDDzSjsIe7muCm3jHgUoSOacsYP3Qiaocr2oms1uIAA7jOHKFhG1ntcuyqnEe/0Z/6xNj5lyDSvcDpYPNAEeD&quot;;
        // ciphertext as Uint8Array


        const ctUint8 = new Uint8Array(Array.from(ctStr).map(ch =&gt; ch.charCodeAt(0)));


        try {
            // decrypt ciphertext using key
            console.log(&quot;before decrypt&quot;);
            const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);
            console.log(&quot;after decrypt&quot;);
            // return plaintext from ArrayBuffer
            return new TextDecoder().decode(plainBuffer);
        } catch (e) {

            console.log(&quot;in catch&quot;,e);
        }
</code></pre>
<p>Please help me in resolving this issue.</p>
<p>Trying the above javascript code to decrypt but not working. Need equivalent code to java in javascript using crypto.subtle. I am not using nodejs.
Getting this in console
Uncaught (in promise) Error: OperationError</p>
"	NULL	NULL	NULL	18:56.5	NULL	NULL	NULL	NULL	NULL	21172805	0	1	0	<javascript><java><aes-gcm>	How to decrypt encoded string created via java code(AES GCM) using javascript crypto.subtle?	56	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75408841	75410149	NULL	"<p>I have written this code in Angular to encrypt a string:</p>
<pre><code>import { Injectable } from '@angular/core';
import * as CryptoJS from 'crypto-js';

@Injectable({
    providedIn: 'root',
  })
export class CryptoService {
  
  encrypt(message: string, clef: string): string {

    const salt = CryptoJS.SHA256(&quot;123456789123&quot;);

    const key = CryptoJS.PBKDF2(clef, salt, {
      keySize: 128 / 32,
      iterations: 1000
  });

    // var key = CryptoJS.enc.Utf8.parse(clef);
    let iv = CryptoJS.enc.Utf8.parse(clef);
    let encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(message.toString()), key,
    {
        keySize: 128 / 8,
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });


    // var encryptedMessage = CryptoJS.AES.encrypt(message.trim(), key).toString();

    return encrypted.toString();
  }

  generateKey(): string {
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const charactersLength = characters.length;
      let counter = 0;
      while (counter &lt; 16) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
      counter += 1;
      }
      return result;
  }
}
</code></pre>
<p>I transfer my key and encriptedMessage to the back for the decryption.</p>
<p>I code dat on java:</p>
<pre><code>import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;

public class AESUtilService {
    
    protected static final String salt = &quot;123456789123&quot;;
    
    public SecretKey getKeyFromPassword(String password)
        throws NoSuchAlgorithmException, InvalidKeySpecException {
        
        SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(), 1000, 128/32);
        SecretKey secret = factory.generateSecret(spec);
        return secret;
    }
    public String decrypt(String cipherText, SecretKey key)
        throws NoSuchPaddingException, NoSuchAlgorithmException,
        InvalidAlgorithmParameterException, InvalidKeyException,
        BadPaddingException, IllegalBlockSizeException {
            
        String algorithm = &quot;AES/CBC/PKCS7Padding&quot;;
        IvParameterSpec iv = new IvParameterSpec(&quot;MnTQLHcWumIKTXpQ&quot;.getBytes());
        
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, key, iv);
        byte[] plainText = cipher.doFinal(Base64.getDecoder().decode(cipherText));
        return new String(plainText);
    }
    
}
</code></pre>
<p>My issue is the following.
The part of the code <code>Cipher cipher = Cipher.getInstance(algorithm);</code> crashes in java, if I use <code>String algorithm = &quot;AES/CBC/PKCS7Padding&quot;;</code>
However it would pass with <code>String algorithm = &quot;AES/CBC/PKCS5Padding&quot;;</code>, but this time it's angular that would crash. <strong>padding: CryptoJS.pad.Pkcs5</strong></p>
<p>I can't find a solution for this problem, and that's why I ask for your help.</p>
"	NULL	NULL	NULL	56:28.5	NULL	NULL	NULL	NULL	NULL	14016187	0	1	2	<java><angular><algorithm><aes><cbc-mode>	AES CBC algorithm/padding in java/angular	53	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75426317	75428137	NULL	"<p>I am getting javax.crypto.AEADBadTagException: Tag mismatch!
There is surely some small detail I am missing out. Thank you in advance!!
Full stack trace:
Exception in thread &quot;main&quot; javax.crypto.AEADBadTagException: Tag mismatch!
at com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:620)
at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1116)
at com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:1053)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:853)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
at javax.crypto.Cipher.doFinal(Cipher.java:2168)
at crypto.CryptoCore.c3andC4(CryptoCore.java:61)
at PokusMain.main(PokusMain.java:197)</p>
<p>I am sending ciphertext from Kotlin app to Java app. When I try to decrypt the exception occurs.</p>
<p>ciphertext from Kotlin app:</p>
<pre><code>fun getFinalCipher(): String {
        //generating key from some parameters
        var ukeyString = hash(appParameters.userKey + &quot;user&quot; + userCryptogram.nonce.toString() +
                receiverCryptogram.nonce.toString(), &quot;SHA-1&quot;)
        if (ukeyString != null) {
            ukeyString = ukeyString!!.substring(0,16)
        }
        val command = &quot;unlock&quot;
        val ukey: SecretKey = SecretKeySpec(ukeyString!!.toByteArray(), &quot;AES&quot;)
        val parameterSpec = GCMParameterSpec(128, getUserIv()) //IV has the length of 12
        val cipherC3 = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;)
        cipherC3.init(Cipher.ENCRYPT_MODE, ukey, parameterSpec)
        val plaintext = appParameters.atu + command.toByteArray()
        var ciphertext = cipherC3.doFinal(plaintext)
        val ciphertextHex = ciphertext.toHex()
        return ciphertextHex
    }
</code></pre>
<p>and when I try to decrypt it in Java app:</p>
<pre><code>public void c3andC4(String ciphertextHex) throws NoSuchPaddingException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, InvalidKeyException {
        byte[] ciphertext = decodeHexString(ciphertextHex);
        String userKey = hash(obuParameters.getDriverKey() + userCryptogram.getHatu(), &quot;SHA-1&quot;);
        String ukeyString = hash(userKey + &quot;user&quot; + userCryptogram.getNonce() + receiverCryptogram.getNonce(),&quot;SHA-1&quot;);
        userKey= userKey.substring(0, 16);
        ukeyString = ukeyString.substring(0,16);
        Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
        SecretKey ukey = new SecretKeySpec(ukeyString.getBytes(),&quot;AES&quot;);
        GCMParameterSpec parameterSpec = new GCMParameterSpec(128, userCryptogram.getIv()); //IV has the length of 12
        cipher.init(Cipher.DECRYPT_MODE,ukey, parameterSpec);
        byte[] decryptedMessage = cipher.doFinal(ciphertext); //this line throws exception
    }
</code></pre>
"	NULL	NULL	NULL	28:23.0	NULL	NULL	NULL	NULL	NULL	10408707	0	1	0	<java><kotlin><exception><cryptography><aes-gcm>	Java exception javax.crypto.AEADBadTagException: Tag mismatch when decrypting	53	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75427643	0	NULL	"<p>I have been trying this for weeks now. I want to use the Android Key Store to securely store my password/passphrase using Shared Preferences. I am able to store the encrypted data, the Initialization Vector (IV), and the authentication tag. However, during the decryption process, I am encountering an error: <strong>'android.security.KeyStoreException: Signature/MAC verification failed when trying to decrypt'</strong>.</p>
<p><strong>Error Logs:</strong></p>
<p>W/System.err:     at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:517)</p>
<p>W/System.err:     at javax.crypto.Cipher.doFinal(Cipher.java:2055)</p>
<p>W/System.err:     at com.example.secure_notes_app.KeyStoreHelper.retrievePassphrase(KeyStoreHelper.java:134)</p>
<p>W/System.err:     at com.example.secure_notes_app.LoginActivity.validatePassphrase(LoginActivity.java:53)</p>
<p>W/System.err:     at com.example.secure_notes_app.LoginActivity.access$200(LoginActivity.java:16)</p>
<p>W/System.err:     at com.example.secure_notes_app.LoginActivity$1.onClick(LoginActivity.java:35)</p>
<p>W/System.err:     at android.view.View.performClick(View.java:7448)</p>
<p>W/System.err:     at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1219)</p>
<p>W/System.err:     at android.view.View.performClickInternal(View.java:7425)</p>
<p>W/System.err:     at android.view.View.access$3600(View.java:810)</p>
<p>W/System.err:     at android.view.View$PerformClick.run(View.java:28305)</p>
<p>W/System.err:     at android.os.Handler.handleCallback(Handler.java:938)</p>
<p>W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:99)</p>
<p>W/System.err:     at android.os.Looper.loop(Looper.java:223)</p>
<p>W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7656)</p>
<p>W/System.err:     at java.lang.reflect.Method.invoke(Native Method)</p>
<p>W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)</p>
<p>W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)</p>
<p>W/System.err: Caused by: android.security.KeyStoreException: Signature/MAC verification failed</p>
<p>W/System.err:     at android.security.KeyStore.getKeyStoreException(KeyStore.java:1301)</p>
<p>W/System.err:     at android.security.keystore.KeyStoreCryptoOperationChunkedStreamer.doFinal(KeyStoreCryptoOperationChunkedStreamer.java:176)</p>
<p>W/System.err:     at android.security.keystore.AndroidKeyStoreAuthenticatedAESCipherSpi$BufferAllOutputUntilDoFinalStreamer.doFinal(AndroidKeyStoreAuthenticatedAESCipherSpi.java:373)</p>
<p>W/System.err:     at android.security.keystore.AndroidKeyStoreCipherSpiBase.engineDoFinal(AndroidKeyStoreCipherSpiBase.java:506)</p>
<p>W/System.err:   ... 17 more</p>
<p>E/validatePassphrase: android.security.KeyStoreException: Signature/MAC verification failed</p>
<p><strong>KeyStoreHelper Class</strong></p>
<pre><code>public class KeyStoreHelper {
    private static final String ANDROID_KEY_STORE = &quot;KeyStore&quot;;
    private static final String ALIAS = &quot;AppPassphrase&quot;;
    private static final String TRANSFORMATION = &quot;AES/GCM/NoPadding&quot;;
    private static final int IV_LENGTH = 12;
    private KeyStore keyStore;
    private final Context context;

    public KeyStoreHelper(Context context) {
        this.context = context;
        try {
            keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
            keyStore.load(null);
        } catch (Exception e) {
            // Handle the exception
            e.printStackTrace();
        }
    }

    public void generateKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE);
            keyGenerator.init(new KeyGenParameterSpec.Builder(ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                    .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                    .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                    .build());
            keyGenerator.generateKey();
        } catch (Exception e) {
            // Handle the exception
            e.printStackTrace();
        }
    }

    public void storePassphrase(String passphrase) {
        try {
            KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
            keyStore.load(null);

            if (!keyStore.containsAlias(ALIAS)) {
                generateKey();
            }

            KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(ALIAS, null);
            SecretKey secretKey = secretKeyEntry.getSecretKey();

            // Initialize the cipher in encryption mode with the secret key
            Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
            SecureRandom secureRandom = SecureRandom.getInstanceStrong();
            byte[] iv = new byte[IV_LENGTH];
            secureRandom.nextBytes(iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            // Update the cipher with the additional authenticated data (AAD)
            cipher.updateAAD(&quot;AAD&quot;.getBytes(StandardCharsets.UTF_8));
            byte[] encrypted = cipher.doFinal(passphrase.getBytes());
            // Store the authentication tag with the encrypted data
            int tagLength = 128 / 8;  // assuming a tag length of 128 bits (16 bytes)
            byte[] authTag = new byte[tagLength];

            SharedPreferenceHelper sharedPreferenceHelper = new SharedPreferenceHelper(context);
            sharedPreferenceHelper.storePassphrase(Base64.encodeToString(encrypted, Base64.DEFAULT));
            sharedPreferenceHelper.storeIV(iv);
            sharedPreferenceHelper.storeAuthTag(authTag);

        } catch (Exception e) {
            Log.e(&quot;KeyStoreHelper&quot;, &quot;Error while storing passphrase: &quot; + e.getCause());
            e.printStackTrace();
        }
    }



    public char[] retrievePassphrase() throws Exception {
        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
        keyStore.load(null);

        if (keyStore.containsAlias(ALIAS)) {
            KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(ALIAS, null);
            SecretKey secretKey = secretKeyEntry.getSecretKey();

            SharedPreferenceHelper sharedPreferenceHelper = new SharedPreferenceHelper(context);

            byte[] iv = sharedPreferenceHelper.getIV();

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec);

            // Get authentication tag from SharedPreferences
            byte[] authTag = sharedPreferenceHelper.getAuthTag();
            cipher.updateAAD(authTag);

            byte[] encryptedPassphraseBytes = Base64.decode(getEncryptedPassphrase(), Base64.DEFAULT);
            byte[] decryptedPassphraseBytes = cipher.doFinal(encryptedPassphraseBytes);

            // zero out the memory used to store the decrypted password
            char[] decryptedPassphrase = new String(decryptedPassphraseBytes, StandardCharsets.UTF_8).toCharArray();
            Arrays.fill(decryptedPassphraseBytes, (byte) 0);
            return decryptedPassphrase;
        } else {
            Log.d(&quot;KeyStoreHelper&quot;, &quot;Alias not found in KeyStore: &quot; + ALIAS);
            return null;
        }
    }

    private String getEncryptedPassphrase() {
        SharedPreferenceHelper sharedPreferenceHelper = new SharedPreferenceHelper(context);
        return sharedPreferenceHelper.getPassphrase();
    }

}
</code></pre>
<p><strong>SharedPreferenceHelper Class</strong></p>
<pre><code>public class SharedPreferenceHelper {

    private final SharedPreferences sharedPreferences;
    private static final String KEY_PASSPHRASE = &quot;passphrase&quot;;
    private static final String KEY_IV = &quot;iv&quot;;
    private static final String KEY_AUTH_TAG = &quot;auth_tag&quot;;


    public SharedPreferenceHelper(Context context) {
        sharedPreferences = context.getSharedPreferences(&quot;SecureNotesApp&quot;, Context.MODE_PRIVATE);
    }

    public void storePassphrase(String passphrase) {
        sharedPreferences.edit().putString(KEY_PASSPHRASE, passphrase).apply();
    }

    public String getPassphrase() {
        String passphrase = sharedPreferences.getString(KEY_PASSPHRASE, null);
        return passphrase;
    }


    public void storeIV(byte[] iv) {
        String encodedIV = Base64.encodeToString(iv, Base64.DEFAULT);
        sharedPreferences.edit().putString(KEY_IV, encodedIV).apply();
    }

    public byte[] getIV() {
        String encodedIV = sharedPreferences.getString(KEY_IV, null);
        if (encodedIV == null) {
            return null;
        }
        return Base64.decode(encodedIV, Base64.DEFAULT);
    }

    public byte[] getAuthTag() {
        String authTagString = sharedPreferences.getString(KEY_AUTH_TAG, null);
        if (authTagString == null) {
            return null;
        }
        byte[] authTag = Base64.decode(authTagString, Base64.DEFAULT);
        return authTag;
    }

    public void storeAuthTag(byte[] authTag) {
        try {
            String authTagValue = Base64.encodeToString(authTag, Base64.DEFAULT);
            sharedPreferences.edit().putString(KEY_AUTH_TAG, authTagValue).apply();
        } catch (Exception e) {
            Log.e(&quot;KeyStoreHelper&quot;, &quot;Error while storing auth tag: &quot; + e.getCause());
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>Can anyone please help me find all the possible issues in my code?</p>
"	NULL	NULL	NULL	19:47.5	NULL	NULL	NULL	NULL	NULL	11962996	0	1	1	<android><encryption><sharedpreferences><keystore><aes-gcm>	Android KeyStore: Error: android.security.KeyStoreException: Signature/MAC verification failed when trying to decrypt	58	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75531462	0	NULL	"<p>I have a encryption/decryption functionality in java code and wanted to write the same logic using the <strong>crypto</strong> node-js library.
What's the equivalent of these Java codes ?
<br><br>
Java code :</p>
<pre><code>
 String iv = &quot;Some random string&quot;;
 AlgorithmParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());
</code></pre>
<p>What I tried :</p>
<pre><code>const iv = &quot;Some random string&quot;
var ivSpec = new Buffer.from(iv);
</code></pre>
<br>
Java code : 
<pre><code>String key = &quot;Some random key&quot;;
SecretKeySpec newKey = new SecretKeySpec(key.getBytes(), &quot;AES&quot;);

</code></pre>
<p>What I tried :</p>
<pre><code>const key = &quot;Some random key&quot;
var newKey = new Buffer.from(key);

</code></pre>
<p>Java code :</p>
<pre><code>String message = &quot;Some message&quot;
Cipher cipher = Cipher.getInstance(&quot;AES/CFB/NoPadding&quot;);
cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
byte[] bytes = cipher.doFinal(textBytes.getBytes());
</code></pre>
<p>In java code it is using <strong>&quot;AES/CFB/NoPadding&quot;</strong> and I found equivalent in node js crypto i.e <strong>&quot;aes-256-cfb&quot;</strong> so I used it.</p>
<pre><code>var crypto = require('crypto');

var cipher = crypto.createCipheriv('aes-256-cfb', newKey, ivSpec);
cipher.update(message, 'utf8');
cipher.final();
</code></pre>
<p>Is that correct ? Where I am doin it wrong cause there is no output of cipher.final().
Thanks in advance.</p>
"	NULL	NULL	NULL	35:31.2	NULL	NULL	NULL	NULL	NULL	12567231	0	1	0	<java><node.js><encryption><node-crypto>	Converting java cipher crypto code to node js crypto	65	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75541010	0	NULL	"<p>I am trying to implement cipher text decryption on cipher generated using key derivation on X25519 algorithm. While I am able to decrypt using private key generated in my system on Java, it fails on python. Java code is using generate secret with tlspremaster, something I am unable to find on python. Can someone suggest how to resolve it? I will be posting my code in a while here.</p>
<p>I am fairly new to cryptography and still learning.</p>
<p>Below is my code. pkey is my Private key generated locally on my Mac Host. After key exchange, I am deriving a symmetric key to decrypt an encrypted string received from Java. The keys are X25519 keys generated on my Mac host and Public key from other system is returned in DER encoded format. Decrypting the same payload using my Public key and remote private key in Java works well. However, same in reverse is not working. What am I doing wrong below?</p>
<pre><code>    from cryptography.hazmat.primitives import serialization
    import base64
    from cryptography.hazmat.primitives.ciphers import         Cipher,algorithms,modes
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.hkdf import HKDF

    pkey = serialization.load_der_private_key(
    base64.b64decode(&quot;MC4CAQAwBQYDK2VuBCIEIKh1Dq7Fu82lqQdBQJTHTvBTxtD6hLconopqvVLVy81s&quot;),
password=None
</code></pre>
<p>)</p>
<pre><code>    ukey=pkey.public_key()
    encstr = base64.b64decode(&quot;tAIfdjkAClrwWFcKVYMiCYVhm7NFAotPyBgF2YJkM2ETWPEYcGG6g37MivEhS8b5&quot;.encode('utf-8'))


    uenkey = ukey.public_bytes(
    encoding=serialization.Encoding.DER,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
     )

    penkey = pkey.private_bytes(
      encoding=serialization.Encoding.DER,
    format=serialization.PrivateFormat.PKCS8,
      encryption_algorithm=serialization.NoEncryption()
    )
    ondcpub = (base64.b64decode(&quot;MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=&quot;))
    oenkey = serialization.load_der_public_key(ondcpub)
    shared_key = pkey.exchange(oenkey)
    shkey = base64.urlsafe_b64encode(shared_key).decode('utf-8')
    print(&quot;Shared Secret: &quot;,      base64.b64encode(shared_key).decode('utf-8'))

     hkdf = HKDF(
     algorithm=hashes.BLAKE2b(64),
     length=32,
     salt=None,
     info=None
     )

     key = hkdf.derive(shared_key)

     print(&quot;Derived Secret: &quot;, base64.b64encode(key).decode('utf-8'))

     iv = encstr[0:16]
     cipher = Cipher(algorithms.AES(key), modes.CBC(iv))

     dec = cipher.decryptor()

     text = dec.update(encstr) + dec.finalize()
</code></pre>
<p>However, while printing text, I am getting junk bytes returned and not what I encrypted.</p>
<p>Below is the Java code that is able to decrypt the string correctly with out problem:</p>
<pre><code>import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
//
import org.springframework.stereotype.Component;

import lombok.Data;

@Component
@Data
public class SubscribeEncryptDecrypt {

String clientPrivateKey = &quot;MFECAQEwBQYDK2VuBCIEIChY69PwPeovw1zAh7TRU+E40LIEykBsbIBp3CanVvRegSEASfWOME2kQQ75i5iMHx0ZodBn0P9UTHcOkeczDmeOVkU=&quot;;
String clientPublicKey = &quot;MCowBQYDK2VuAyEASfWOME2kQQ75i5iMHx0ZodBn0P9UTHcOkeczDmeOVkU=&quot;;

String proteanPublicKey = &quot;MCowBQYDK2VuAyEALtPj74XkIrkyxTqyssjtYJ3KRND5FnzK5MDrwlK3kC8=&quot;;
String proteanPrivateKey = &quot;MFECAQEwBQYDK2VuBCIEIAj5U1DVAX5eGI1jIIcjmzWgPQlIg/T1Q6A3pZ0AIWp6gSEAJGnKRTAEcSvpgD0mw9gBHv94E3w8sTtmPlszuXIEAF0=&quot;;

public static String secretKey = &quot;TlsPremasterSecret&quot;;

public static void setup() {
if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
Security.addProvider(new BouncyCastleProvider());
}
}

public String decrypt(String clientPrivateKey, String proteanPublicKey, String value) {

try {
byte[] dataBytes = Base64.getDecoder().decode(proteanPublicKey);
PublicKey publicKey = getPublicKey(&quot;X25519&quot;, dataBytes);

dataBytes = Base64.getDecoder().decode(clientPrivateKey);
PrivateKey privateKey = getPrivateKey(&quot;X25519&quot;, dataBytes);

KeyAgreement atServer1 = KeyAgreement.getInstance(&quot;X25519&quot;, BouncyCastleProvider.PROVIDER_NAME);
atServer1.init(privateKey); // Server1 uses its private key to initialize the aggreement object
atServer1.doPhase(publicKey, true); // Uses Server2's ppublic Key
SecretKey key1 = atServer1.generateSecret(secretKey); // derive secret at server 1.
// &quot;TlsPremasterSecret&quot; is the algorithm for

Cipher cipher2 = Cipher.getInstance(&quot;AES&quot;, BouncyCastleProvider.PROVIDER_NAME);
cipher2.init(Cipher.DECRYPT_MODE, key1); // Same derived key in server 2same as key1
byte[] decrypted2 = cipher2.doFinal(Base64.getDecoder().decode(value)); // b64 decode the
// message before

return new String(decrypted2);
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return &quot;&quot;;
}

public PublicKey getPublicKey(String algo, byte[] jceBytes) throws Exception {
X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(jceBytes);
PublicKey key = KeyFactory.getInstance(algo, BouncyCastleProvider.PROVIDER_NAME)
.generatePublic(x509EncodedKeySpec);
return key;
}

public PrivateKey getPrivateKey(String algo, byte[] jceBytes) throws Exception {
PrivateKey key = KeyFactory.getInstance(algo, BouncyCastleProvider.PROVIDER_NAME)
.generatePrivate(new PKCS8EncodedKeySpec(jceBytes));
return key;
}

public String encrypt(String clientPublicKey, String proteanPrivateKey, String value) {

try {
byte[] dataBytes = Base64.getDecoder().decode(clientPublicKey);
PublicKey publicKey = getPublicKey(&quot;X25519&quot;, dataBytes);

dataBytes = Base64.getDecoder().decode(proteanPrivateKey);
PrivateKey privateKey = getPrivateKey(&quot;X25519&quot;, dataBytes);

KeyAgreement atServer1 = KeyAgreement.getInstance(&quot;X25519&quot;, BouncyCastleProvider.PROVIDER_NAME);
atServer1.init(privateKey); // Server1 uses its private key to initialize the aggreement object
atServer1.doPhase(publicKey, true); // Uses Server2's ppublic Key
SecretKey key1 = atServer1.generateSecret(secretKey); // //derive secret at server 1.
// &quot;TlsPremasterSecret&quot; is the algorithm for

// *Server1
Cipher cipher1 = Cipher.getInstance(&quot;AES&quot;, BouncyCastleProvider.PROVIDER_NAME);
cipher1.init(Cipher.ENCRYPT_MODE, key1);
byte[] encrypted1 = cipher1.doFinal(value.getBytes(StandardCharsets.UTF_8));
String b64Encryped1 = Base64.getEncoder().encodeToString(encrypted1);

return b64Encryped1;
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return &quot;&quot;;
}


public static void main(String[] args) {
SubscribeEncryptDecrypt decr = new SubscribeEncryptDecrypt();

decr.setup();
 
String enc = decr.encrypt(&quot;MCowBQYDK2VuAyEAr+B5vDW7a3QFkCcYqf3RMMi5BxsnwU3fy63pxpCDnQM=&quot;,
&quot;MFECAQEwBQYDK2VuBCIEIJDIsJi4nLGZ7BKaJkkIzJxubIndEOvT5hx0MKgoGYFvgSEA13ZQjiRLAA5YG6prELnmQwboQlpj0MzI94XF/kG4UmY=&quot;,
&quot;Fossgen is awesome!&quot;);
System.out.println(&quot;ENC:&quot;);
System.out.println(enc);
System.out.println(&quot;DECR3:&quot;);
System.out.println(decr.decrypt(&quot;MFECAQEwBQYDK2VuBCIEIEhk0BhCxAEIHg8HehKzo9IHmCFRpcp9IlBGYsWTPdVzgSEAMmKN2FKRf+ojfYYQ80ZcgyJQvQlbxDA8BAsxNG4vuGI=&quot;, 
&quot;MCowBQYDK2VuAyEA13ZQjiRLAA5YG6prELnmQwboQlpj0MzI94XF/kG4UmY=&quot;,
enc));

}

}
</code></pre>
<p>Keys mentioned in the code are real.</p>
"	NULL	NULL	NULL	47:08.5	NULL	NULL	NULL	NULL	NULL	21270188	0	1	-2	<python><cryptography><diffie-hellman>	TLS Master Secret for generate Secret on X25519	39	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75579851	0	NULL	"<p>I am trying to implement cipher text decryption on cipher generated using key derivation on X25519 algorithm. While I am able to decrypt using private key generated in my system on Java, it fails on python. Java code is using generate secret with tlspremaster, something I am unable to find on python. Can someone suggest how to resolve it? I will be posting my code in a while here.</p>
<p>I am fairly new to cryptography and still learning.</p>
<p>Below is my code. pkey is my Private key generated locally on my Mac Host. After key exchange, I am deriving a symmetric key to decrypt an encrypted string received from Java. The keys are X25519 keys generated on my Mac host and Public key from other system is returned in DER encoded format. Decrypting the same payload using my Public key and remote private key in Java works well. However, same in reverse is not working. What am I doing wrong below?</p>
<pre><code>    from cryptography.hazmat.primitives import serialization
    import base64
    from cryptography.hazmat.primitives.ciphers import         Cipher,algorithms,modes
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.hkdf import HKDF

    pkey = serialization.load_der_private_key(
    base64.b64decode(&quot;MC4CAQAwBQYDK2VuBCIEIKh1Dq7Fu82lqQdBQJTHTvBTxtD6hLconopqvVLVy81s&quot;),
password=None
</code></pre>
<p>)</p>
<pre><code>    ukey=pkey.public_key()
    encstr = base64.b64decode(&quot;tAIfdjkAClrwWFcKVYMiCYVhm7NFAotPyBgF2YJkM2ETWPEYcGG6g37MivEhS8b5&quot;.encode('utf-8'))


    uenkey = ukey.public_bytes(
    encoding=serialization.Encoding.DER,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
     )

    penkey = pkey.private_bytes(
      encoding=serialization.Encoding.DER,
    format=serialization.PrivateFormat.PKCS8,
      encryption_algorithm=serialization.NoEncryption()
    )
    ondcpub = (base64.b64decode(&quot;MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=&quot;))
    oenkey = serialization.load_der_public_key(ondcpub)
    shared_key = pkey.exchange(oenkey)
    shkey = base64.urlsafe_b64encode(shared_key).decode('utf-8')
    print(&quot;Shared Secret: &quot;,      base64.b64encode(shared_key).decode('utf-8'))

     hkdf = HKDF(
     algorithm=hashes.BLAKE2b(64),
     length=32,
     salt=None,
     info=None
     )

     key = hkdf.derive(shared_key)

     print(&quot;Derived Secret: &quot;, base64.b64encode(key).decode('utf-8'))

     iv = encstr[0:16]
     cipher = Cipher(algorithms.AES(key), modes.CBC(iv))

     dec = cipher.decryptor()

     text = dec.update(encstr) + dec.finalize()
</code></pre>
<p>However, while printing text, I am getting junk bytes returned and not what I encrypted.</p>
<p>Below is the Java code that is able to decrypt the string correctly with out problem:</p>
<pre><code>import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.SecretKey;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
//
import org.springframework.stereotype.Component;

import lombok.Data;

@Component
@Data
public class SubscribeEncryptDecrypt {

String clientPrivateKey = &quot;MFECAQEwBQYDK2VuBCIEIChY69PwPeovw1zAh7TRU+E40LIEykBsbIBp3CanVvRegSEASfWOME2kQQ75i5iMHx0ZodBn0P9UTHcOkeczDmeOVkU=&quot;;
String clientPublicKey = &quot;MCowBQYDK2VuAyEASfWOME2kQQ75i5iMHx0ZodBn0P9UTHcOkeczDmeOVkU=&quot;;

String proteanPublicKey = &quot;MCowBQYDK2VuAyEALtPj74XkIrkyxTqyssjtYJ3KRND5FnzK5MDrwlK3kC8=&quot;;
String proteanPrivateKey = &quot;MFECAQEwBQYDK2VuBCIEIAj5U1DVAX5eGI1jIIcjmzWgPQlIg/T1Q6A3pZ0AIWp6gSEAJGnKRTAEcSvpgD0mw9gBHv94E3w8sTtmPlszuXIEAF0=&quot;;

public static String secretKey = &quot;TlsPremasterSecret&quot;;

public static void setup() {
if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
Security.addProvider(new BouncyCastleProvider());
}
}

public String decrypt(String clientPrivateKey, String proteanPublicKey, String value) {

try {
byte[] dataBytes = Base64.getDecoder().decode(proteanPublicKey);
PublicKey publicKey = getPublicKey(&quot;X25519&quot;, dataBytes);

dataBytes = Base64.getDecoder().decode(clientPrivateKey);
PrivateKey privateKey = getPrivateKey(&quot;X25519&quot;, dataBytes);

KeyAgreement atServer1 = KeyAgreement.getInstance(&quot;X25519&quot;, BouncyCastleProvider.PROVIDER_NAME);
atServer1.init(privateKey); // Server1 uses its private key to initialize the aggreement object
atServer1.doPhase(publicKey, true); // Uses Server2's ppublic Key
SecretKey key1 = atServer1.generateSecret(secretKey); // derive secret at server 1.
// &quot;TlsPremasterSecret&quot; is the algorithm for

Cipher cipher2 = Cipher.getInstance(&quot;AES&quot;, BouncyCastleProvider.PROVIDER_NAME);
cipher2.init(Cipher.DECRYPT_MODE, key1); // Same derived key in server 2same as key1
byte[] decrypted2 = cipher2.doFinal(Base64.getDecoder().decode(value)); // b64 decode the
// message before

return new String(decrypted2);
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return &quot;&quot;;
}

public PublicKey getPublicKey(String algo, byte[] jceBytes) throws Exception {
X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(jceBytes);
PublicKey key = KeyFactory.getInstance(algo, BouncyCastleProvider.PROVIDER_NAME)
.generatePublic(x509EncodedKeySpec);
return key;
}

public PrivateKey getPrivateKey(String algo, byte[] jceBytes) throws Exception {
PrivateKey key = KeyFactory.getInstance(algo, BouncyCastleProvider.PROVIDER_NAME)
.generatePrivate(new PKCS8EncodedKeySpec(jceBytes));
return key;
}

public String encrypt(String clientPublicKey, String proteanPrivateKey, String value) {

try {
byte[] dataBytes = Base64.getDecoder().decode(clientPublicKey);
PublicKey publicKey = getPublicKey(&quot;X25519&quot;, dataBytes);

dataBytes = Base64.getDecoder().decode(proteanPrivateKey);
PrivateKey privateKey = getPrivateKey(&quot;X25519&quot;, dataBytes);

KeyAgreement atServer1 = KeyAgreement.getInstance(&quot;X25519&quot;, BouncyCastleProvider.PROVIDER_NAME);
atServer1.init(privateKey); // Server1 uses its private key to initialize the aggreement object
atServer1.doPhase(publicKey, true); // Uses Server2's ppublic Key
SecretKey key1 = atServer1.generateSecret(secretKey); // //derive secret at server 1.
// &quot;TlsPremasterSecret&quot; is the algorithm for

// *Server1
Cipher cipher1 = Cipher.getInstance(&quot;AES&quot;, BouncyCastleProvider.PROVIDER_NAME);
cipher1.init(Cipher.ENCRYPT_MODE, key1);
byte[] encrypted1 = cipher1.doFinal(value.getBytes(StandardCharsets.UTF_8));
String b64Encryped1 = Base64.getEncoder().encodeToString(encrypted1);

return b64Encryped1;
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return &quot;&quot;;
}


public static void main(String[] args) {
SubscribeEncryptDecrypt decr = new SubscribeEncryptDecrypt();

decr.setup();
 
String enc = decr.encrypt(&quot;MCowBQYDK2VuAyEAr+B5vDW7a3QFkCcYqf3RMMi5BxsnwU3fy63pxpCDnQM=&quot;,
&quot;MFECAQEwBQYDK2VuBCIEIJDIsJi4nLGZ7BKaJkkIzJxubIndEOvT5hx0MKgoGYFvgSEA13ZQjiRLAA5YG6prELnmQwboQlpj0MzI94XF/kG4UmY=&quot;,
&quot;Fossgen is awesome!&quot;);
System.out.println(&quot;ENC:&quot;);
System.out.println(enc);
System.out.println(&quot;DECR3:&quot;);
System.out.println(decr.decrypt(&quot;MFECAQEwBQYDK2VuBCIEIEhk0BhCxAEIHg8HehKzo9IHmCFRpcp9IlBGYsWTPdVzgSEAMmKN2FKRf+ojfYYQ80ZcgyJQvQlbxDA8BAsxNG4vuGI=&quot;, 
&quot;MCowBQYDK2VuAyEA13ZQjiRLAA5YG6prELnmQwboQlpj0MzI94XF/kG4UmY=&quot;,
enc));

}

}
</code></pre>
<p>Keys mentioned in the code are real.</p>
<p>I am fairly naive with Cryptography, so apologies in advance for some stupid questions I may be raising here.
I create a Key pair with X25519 algorithm locally on my Mac Box. I am getting an encrypted string from a Java service using same algorithm. Code for both Java and Python are mentioned above. The private key of server and local public key in Java code is being used to generate key agreement and shared key. Post derivation of Key, decryption of key returns junk characters.</p>
<p>Below is output of python program:</p>
<pre><code>Local Private Key:  MC4CAQAwBQYDK2VuBCIEIKh1Dq7Fu82lqQdBQJTHTvBTxtD6hLconopqvVLVy81s
Local Public Key:  MCowBQYDK2VuAyEAX81uAZNOjPutK/Mz4tq/j27+dyjh7zdjwBGR4/+ye2U=
ONDC Public Key:  MCowBQYDK2VuAyEAa9Wbpvd9SsrpOZFcynyt/TO3x0Yrqyys4NUGIvyxX2Q=
Shared Secret:  n9GvHoVbxb3huDjRGp9h7UUEwmEtBFf5SYjHJPmAfX4=
Derived Secret:  HXk952GQGDVmhRykvG8Q/5PdpsBPgL7T5padSbDLf8k=
Decrypted String: b'\xc2]\xb5\x9d2%\xcfz\xb2,\xae,\xf2\x93pW\x16\x885L\xf7\x1c\xe0AnY\xf1*\x91\x08X\t\x9fB\xcd6f\xf8_\xfc\xacU\xbf\xf1mx\xed\x83'
</code></pre>
"	NULL	NULL	NULL	25:29.3	NULL	NULL	NULL	NULL	NULL	21270188	0	1	-2	<python><diffie-hellman><x25519>	Unable to Decrypt in Python using X25519 Keys for Cipher encrypted in Java	51	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75588743	75592636	NULL	"<p>I am trying to decipher the data presented in this format (password for decryption - 123123123, data taken from my phantom wallet):</p>
<pre><code>{
  &quot;encrypted&quot;: &quot;Cj7psrZSx4oyzdMHpmemhHT21HrRzQxZ9Qyk9v3g3sg3&quot;,
  &quot;nonce&quot;: &quot;Gs1UtjfmNJ48rwqNPwfv5MMxcwFYpvtsd&quot;,
  &quot;kdf&quot;: &quot;pbkdf2&quot;,
  &quot;salt&quot;: &quot;JHjFEhDPmLFsRVshHYMprr&quot;,
  &quot;iterations&quot;: 10000,
  &quot;digest&quot;: &quot;sha256&quot;
}
</code></pre>
<p>I wrote the following code to decode this data, but when decoding nonce via Base64 I get the error &quot;Last unit does not have enough valid bits&quot;. I thought that nonce should be trimmed, but then the error &quot;Tag mismatch&quot; appears.</p>
<pre><code>public static void main(String[] args) throws Exception {
    String encrypted = &quot;Cj7psrZSx4oyzdMHpmemhHT21HrRzQxZ9Qyk9v3g3sg3&quot;;
    String nonce = &quot;Gs1UtjfmNJ48rwqNPwfv5MMxcwFYpvtsd&quot;;
    String salt = &quot;JHjFEhDPmLFsRVshHYMprr&quot;;

    SecretKey key = getAESKeyFromPassword(&quot;123123123&quot;.toCharArray(), salt.getBytes());
    byte[] encryptedBytes = Base64.getDecoder().decode(encrypted);
    byte[] nonceBytes = Base64.getDecoder().decode(nonce);
    String decrypted = decryptAES(encryptedBytes, key, nonceBytes);
}

private static SecretKey getAESKeyFromPassword(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);
    KeySpec spec = new PBEKeySpec(password, salt, 10000, 256);
    return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), &quot;AES&quot;);
}

private static String decryptAES(byte[] cText, SecretKey secret, byte[] nonce) throws Exception {
    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);
    cipher.init(Cipher.DECRYPT_MODE, secret, new GCMParameterSpec(128, nonce));
    byte[] plainText = cipher.doFinal(cText);
    return new String(plainText, UTF_8);
}
</code></pre>
<p>Maybe someone knows how to work with this nonce?</p>
"	NULL	NULL	NULL	55:51.2	NULL	NULL	NULL	NULL	NULL	20069646	0	1	-1	<java><encryption><base64><sha256><aes-gcm>	How to decrypt pbkdf2 and aes/gcm data	71	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
75611268	75621372	NULL	"<p>I need to integrate with a third-party REST API. The body of my request (as well as the response) need to be encrypted using AES encryption using an AES key that was communicated to us. There are a few requirements:</p>
<ul>
<li>Use a Rijndael cipher</li>
<li>Electronic Code Book mode (ECB)</li>
<li>No built-in padding</li>
</ul>
<p><strong>Edit 1:</strong></p>
<p>This is an extract from the Integration Guide I was provided:</p>
<p>All URL parameters must be encrypted using AES with a shared key. Additionally, we are able to support all
widely used encryption algorithms. Standard AES encryption algorithm may be used by the client system to
generate the secure token (Integration Token). The following AES cipher attributes should be used:</p>
<ul>
<li>Rijndael cipher</li>
<li>Electronic Code Book mode (ECB)</li>
<li>No built in padding (such as PKCS)</li>
<li>Resultant encrypted buffer should be manually padded with spaces to achieve the total length a
multiple of 32. That is: length(encrypted padded string) mod 32 = 0</li>
</ul>
<p>For example, instantiate the cipher and initialize it using Java standard SunJCE cryptological library the code
would contain: Cipher cipher = Cipher.getInstance(&quot;Rijndael/ECB/NoPadding&quot;, &quot;SunJCE&quot;);</p>
<p><strong>End of Edit 1</strong></p>
<p>I tried to play a little bit with some snippets of code that I found mostly here and I wrote the following sequence:</p>
<pre><code>  var clearMessage = &quot;The brown fox jumps over the laxy dog&quot;;
  console.log(&quot;Clear message: &quot;, clearMessage);
  var encodingKey = CryptoJS.enc.Hex.parse(&quot;0123456789ABCDEF0123456789ABCDEF&quot;);
  var encryptedMessage = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(clearMessage), encodingKey, {
                                              mode: CryptoJS.mode.ECB,
                                              padding: CryptoJS.pad.NoPadding});
  console.log(&quot;Encrypted message: &quot;, encryptedMessage.ciphertext.toString());


  const decryptedMessage = CryptoJS.AES.decrypt(encryptedMessage.ciphertext.toString(), encodingKey, {
                                                mode: CryptoJS.mode.ECB,
                                                padding: CryptoJS.pad.NoPadding});
  clearMessage = decryptedMessage.toString(CryptoJS.enc.Utf8);
  console.log(&quot;Decrypted message: &quot;, clearMessage);
</code></pre>
<p>In the console of my browser, I see this output:</p>
<pre><code>Clear message:  The brown fox jumps over the laxy dog
Encrypted message:  56aaf639f44c106889aa4a765d2bf7c83a7860a379d776982991c7575eb63fd31f7c9ce3db

crypto-js.js:523 Uncaught Error: Malformed UTF-8 data
at Object.stringify (crypto-js.js:523:24)
at WordArray.init.toString (crypto-js.js:278:38)
at encryptDecrypt (index.html:157:39)
at HTMLButtonElement.onclick (index.html:46:60)
</code></pre>
<p>Spelling mistake aside (&quot;laxy dog&quot; ?!!?), what is wrong with my decrypting sequence? The error message is triggered on this line of code:</p>
<pre><code>clearMessage = decryptedMessage.toString(CryptoJS.enc.Utf8);
</code></pre>
<p><strong>Edit 2:</strong></p>
<p>This is what chatgpt has generated for this question:</p>
<pre><code>// Import the necessary libraries
var CryptoJS = require(&quot;crypto-js&quot;);

// Set the plaintext message and secret key
var message = &quot;This is a secret message!&quot;;
var secretKey = &quot;ThisIsASecretKey&quot;;

// Convert the key and message to WordArrays (required by CryptoJS)
var key = CryptoJS.enc.Utf8.parse(secretKey);
var plaintext = CryptoJS.enc.Utf8.parse(message);

// Encrypt the plaintext message using AES with Rijndael cipher, ECB mode, and no padding
var ciphertext = CryptoJS.AES.encrypt(plaintext, key, {
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.NoPadding,
  cipher: CryptoJS.algo.Rijndael
});

// Print the encrypted ciphertext in Base64 format
console.log(ciphertext.toString());

// Decrypt the ciphertext message using AES with Rijndael cipher, ECB mode, and no padding
var decrypted = CryptoJS.AES.decrypt(ciphertext, key, {
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.NoPadding,
  cipher: CryptoJS.algo.Rijndael
});

// Convert the decrypted message back to plaintext and print it
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
<p>It gives me the exact same error when I try to decode the cipher.</p>
<p><strong>End of Edit 2</strong></p>
<p>Any ideas or suggestions?</p>
<p>TIA,
Ed</p>
"	NULL	NULL	NULL	14:35.7	NULL	NULL	NULL	NULL	NULL	1652739	0	1	1	<javascript><encryption><aes><rijndael>	"Encrypt/Decrypt using AES encryption with a Rijndael cipher, ECB, NoPadding in JavaScript"	44	NULL	samp	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
